This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.firebaserc
.github/workflows/codeql.yml
.github/workflows/firebase-hosting-merge.yml
.github/workflows/firebase-hosting-pull-request.yml
.gitignore
firebase.json
firestore.indexes.json
firestore.rules
Fixed.txt
Idees.txt
package.json
public/index.html
public/manifest.json
src/App.js
src/components/admin/EventTrigger.js
src/components/alliance/AllianceBank.js
src/components/alliance/AllianceCreation.js
src/components/alliance/AllianceDiplomacy.js
src/components/alliance/AllianceForum.css
src/components/alliance/AllianceForum.js
src/components/alliance/AllianceInvitations.js
src/components/alliance/AllianceMembers.js
src/components/alliance/AllianceOverview.js
src/components/alliance/AllianceProperties.js
src/components/alliance/AllianceRanks.js
src/components/alliance/AllianceResearch.js
src/components/alliance/AllianceSettings.js
src/components/alliance/AllianceSuggestions.js
src/components/alliance/AllianceWonder.js
src/components/alliance/WonderBuilderModal.js
src/components/alliance/WonderProgressModal.js
src/components/AuthScreen.css
src/components/AuthScreen.js
src/components/chat/Chat.css
src/components/chat/Chat.js
src/components/city/AcademyMenu.css
src/components/city/AcademyMenu.js
src/components/city/AdminCheatMenu.js
src/components/city/BarracksMenu.css
src/components/city/BarracksMenu.js
src/components/city/BuildingDetailsModal.js
src/components/city/BuildingSpot.js
src/components/city/BuildQueue.js
src/components/city/CaveMenu.css
src/components/city/CaveMenu.js
src/components/city/CityModals.js
src/components/city/Cityscape.js
src/components/city/CityViewContent.js
src/components/city/DivinePowers.css
src/components/city/DivinePowers.js
src/components/city/DivineTempleMenu.css
src/components/city/DivineTempleMenu.js
src/components/city/HeroDisplay.css
src/components/city/HeroDisplay.js
src/components/city/HeroesAltar.css
src/components/city/HeroesAltar.js
src/components/city/HospitalMenu.js
src/components/city/MarketMenu.css
src/components/city/MarketMenu.js
src/components/city/PrisonMenu.css
src/components/city/PrisonMenu.js
src/components/city/RecruitmentPanel.css
src/components/city/RecruitmentPanel.js
src/components/city/RecruitmentToolTip.css
src/components/city/RecruitmentToolTip.js
src/components/city/ReinforcementModal.js
src/components/city/ResearchQueue.css
src/components/city/ResearchQueue.js
src/components/city/SenateView.css
src/components/city/SenateView.js
src/components/city/ShipyardMenu.js
src/components/city/SpecialBuildingMenu.css
src/components/city/SpecialBuildingMenu.js
src/components/city/SpecialBuildingPanel.js
src/components/city/specialBuildingPlotpls.js
src/components/city/TempleMenu.js
src/components/city/UnitQueue.css
src/components/city/UnitQueue.js
src/components/city/WithdrawModal.js
src/components/city/WorkerPresetPanel.js
src/components/city/WorshipDisplay.js
src/components/CityFounding.js
src/components/CityView.js
src/components/Game.js
src/components/icons/EyeIcon.js
src/components/icons/EyeOffIcon.js
src/components/leaderboard/Leaderboard.css
src/components/leaderboard/Leaderboard.js
src/components/management/GameDataManager.js
src/components/management/managementPanel.css
src/components/management/managementPanelpls.js
src/components/map/AllianceModal.css
src/components/map/AllianceModal.js
src/components/map/Countdown.js
src/components/map/EmptyCityModal.js
src/components/map/FarmingVillageModal.js
src/components/map/GodTownModal.js
src/components/map/MapGrid.js
src/components/map/MapModals.js
src/components/map/MapOverlay.css
src/components/map/MapOverlay.js
src/components/map/MovementIndicator.js
src/components/map/MovementItem.js
src/components/map/MovementModal.css
src/components/map/MovementModal.js
src/components/map/MovementsPanel.css
src/components/map/MovementsPanel.js
src/components/map/MovementsToolTip.css
src/components/map/MovementsToolTip.js
src/components/map/OtherCityModal.css
src/components/map/OtherCityModal.js
src/components/map/OwnActiveCityModal.js
src/components/map/OwnInactiveCityModal.js
src/components/map/RadialMenu.css
src/components/map/RadialMenu.js
src/components/map/ScoutPanel.js
src/components/map/SidebarNav.js
src/components/map/Tiles.js
src/components/map/TopBar.css
src/components/map/TopBar.js
src/components/map/TradePanel.js
src/components/map/TradesToolTip.css
src/components/map/TradesToolTip.js
src/components/MapView.js
src/components/messaging/MessagesView.css
src/components/messaging/MessagesView.js
src/components/profile/AllianceProfile.css
src/components/profile/AllianceProfile.js
src/components/profile/ProfileView.css
src/components/profile/ProfileView.js
src/components/puzzles/PuzzleRenderer.js
src/components/quests/Quests.css
src/components/quests/QuestsModal.js
src/components/QuestsButton.css
src/components/QuestsButton.js
src/components/ReportsView.css
src/components/ReportsView.js
src/components/SelectionScreen.js
src/components/shared/LoadingScreen.js
src/components/shared/Modal.js
src/components/shared/Notification.css
src/components/shared/Notification.js
src/components/shared/SettingsModal.js
src/components/shared/TextEditor.css
src/components/shared/TextEditor.js
src/components/SharedReportView.js
src/components/SideInfoPanel.js
src/components/Temple.js
src/components/TroopDisplay.js
src/components/WorldSelectionScreen.css
src/components/WorldSelectionScreen.js
src/contexts/AllianceContext.js
src/contexts/AllianceProvider.js
src/contexts/AuthContext.js
src/contexts/GameContext.js
src/contexts/NotificationContext.js
src/contexts/NotificationProvider.js
src/firebase/config.js
src/gameData/agents.json
src/gameData/alliance_wonders.json
src/gameData/allianceResearch.json
src/gameData/BuildingLayout.json
src/gameData/buildings.json
src/gameData/gods.json
src/gameData/heroes.json
src/gameData/puzzles.json
src/gameData/quests.json
src/gameData/research.json
src/gameData/ruinsResearch.json
src/gameData/specialBuildings.json
src/gameData/units.json
src/hooks/actions/useAdminActions.js
src/hooks/actions/useAgentActions.js
src/hooks/actions/useAllianceActions.js
src/hooks/actions/useAllianceBank.js
src/hooks/actions/useAllianceDiplomacy.js
src/hooks/actions/useAllianceManagement.js
src/hooks/actions/useAllianceResearch.js
src/hooks/actions/useAllianceWonderActions.js
src/hooks/actions/useBuildingActions.js
src/hooks/actions/useDivineActions.js
src/hooks/actions/useHeroActions.js
src/hooks/actions/useResearchActions.js
src/hooks/actions/useUnitActions.js
src/hooks/actions/useWorkerActions.js
src/hooks/useCityActions.js
src/hooks/useCityModalManager.js
src/hooks/useCityState.js
src/hooks/useGameManager.js
src/hooks/useKeyboardControls.js
src/hooks/useMapActions.js
src/hooks/useMapClickHandler.js
src/hooks/usemapdatapls.js
src/hooks/useMapEvents.js
src/hooks/useMapInteraction.js
src/hooks/useMapState.js
src/hooks/useModalState.js
src/hooks/useMovementProcessor.js
src/hooks/useQuestTracker.js
src/hooks/useWorldClock.js
src/index.css
src/index.js
src/styles/base.css
src/styles/components.css
src/styles/effects.css
src/styles/map.css
src/styles/panels.css
src/styles/tooltips.css
src/utils/bbcodeParser.js
src/utils/combat.js
src/utils/nationality.js
src/utils/sendSystemMessage.js
src/utils/travel.js
src/utils/worldGeneration.js
tailwind.config.js
todo.txt
Way later.txt
Zap stuff.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".firebaserc">
{
  "projects": {
    "default": "grepollike"
  }
}
</file>

<file path=".github/workflows/codeql.yml">
# For most projects, this workflow file will not need changing; you simply need
# to commit it to your repository.
#
# You may wish to alter this file to override the set of languages analyzed,
# or to provide custom queries or build logic.
#
# ******** NOTE ********
# We have attempted to detect the languages in your repository. Please check
# the `language` matrix defined below to confirm you have the correct set of
# supported CodeQL languages.
#
name: "CodeQL Advanced"

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  schedule:
    - cron: '29 3 * * 6'

jobs:
  analyze:
    name: Analyze (${{ matrix.language }})
    # Runner size impacts CodeQL analysis time. To learn more, please see:
    #   - https://gh.io/recommended-hardware-resources-for-running-codeql
    #   - https://gh.io/supported-runners-and-hardware-resources
    #   - https://gh.io/using-larger-runners (GitHub.com only)
    # Consider using larger runners or machines with greater resources for possible analysis time improvements.
    runs-on: ${{ (matrix.language == 'swift' && 'macos-latest') || 'ubuntu-latest' }}
    permissions:
      # required for all workflows
      security-events: write

      # required to fetch internal or private CodeQL packs
      packages: read

      # only required for workflows in private repositories
      actions: read
      contents: read

    strategy:
      fail-fast: false
      matrix:
        include:
        - language: actions
          build-mode: none
        - language: javascript-typescript
          build-mode: none
        # CodeQL supports the following values keywords for 'language': 'actions', 'c-cpp', 'csharp', 'go', 'java-kotlin', 'javascript-typescript', 'python', 'ruby', 'rust', 'swift'
        # Use `c-cpp` to analyze code written in C, C++ or both
        # Use 'java-kotlin' to analyze code written in Java, Kotlin or both
        # Use 'javascript-typescript' to analyze code written in JavaScript, TypeScript or both
        # To learn more about changing the languages that are analyzed or customizing the build mode for your analysis,
        # see https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning.
        # If you are analyzing a compiled language, you can modify the 'build-mode' for that language to customize how
        # your codebase is analyzed, see https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    # Add any setup steps before running the `github/codeql-action/init` action.
    # This includes steps like installing compilers or runtimes (`actions/setup-node`
    # or others). This is typically only required for manual builds.
    # - name: Setup runtime (example)
    #   uses: actions/setup-example@v1

    # Initializes the CodeQL tools for scanning.
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: ${{ matrix.language }}
        build-mode: ${{ matrix.build-mode }}
        # If you wish to specify custom queries, you can do so here or in a config file.
        # By default, queries listed here will override any specified in a config file.
        # Prefix the list here with "+" to use these queries and those in the config file.

        # For more details on CodeQL's query packs, refer to: https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs
        # queries: security-extended,security-and-quality

    # If the analyze step fails for one of the languages you are analyzing with
    # "We were unable to automatically build your code", modify the matrix above
    # to set the build mode to "manual" for that language. Then modify this step
    # to build your code.
    # ℹ️ Command-line programs to run using the OS shell.
    # 📚 See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun
    - if: matrix.build-mode == 'manual'
      shell: bash
      run: |
        echo 'If you are using a "manual" build mode for one or more of the' \
          'languages you are analyzing, replace this with the commands to build' \
          'your code, for example:'
        echo '  make bootstrap'
        echo '  make release'
        exit 1

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3
      with:
        category: "/language:${{matrix.language}}"
</file>

<file path=".github/workflows/firebase-hosting-merge.yml">
# .github/workflows/firebase-hosting-merge.yml
name: Deploy to Firebase Hosting on merge
'on':
  push:
    branches:
      - main
jobs:
  build_and_deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      # This next line is the crucial addition. It installs all the
      # dependencies, including react-scripts, before trying to build.
      - run: npm install
      - run: npm run build
      - uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: '${{ secrets.GITHUB_TOKEN }}'
          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT_GREPOLLIKE }}'
          channelId: live
          projectId: grepollike
</file>

<file path=".github/workflows/firebase-hosting-pull-request.yml">
# This file was auto-generated by the Firebase CLI
# https://github.com/firebase/firebase-tools

name: Deploy to Firebase Hosting on PR
on: pull_request
permissions:
  checks: write
  contents: read
  pull-requests: write
jobs:
  build_and_preview:
    if: ${{ github.event.pull_request.head.repo.full_name == github.repository }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm run build
      - uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: ${{ secrets.GITHUB_TOKEN }}
          firebaseServiceAccount: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_GREPOLLIKE }}
          projectId: grepollike
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
</file>

<file path="firebase.json">
{
  "hosting": {
    "public": "build",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  },
  "emulators": {
    "ui": {
      "enabled": true,
      "port": 4000
    },
    "hosting": {
      "port": 5000,
      "host": "0.0.0.0"
    },
    "auth": {
      "port": 9099,
      "host": "0.0.0.0",
      "import": "./firebase-data",
      "exportOnShutdown": true
    },
    "firestore": {
      "port": 8090,
      "rules": "firestore.rules",
      "import": "./firebase-data",
      "exportOnShutdown": true,
      "host": "0.0.0.0"
    }
  },
  "firestore": {
    "database": "(default)",
    "location": "eur3",
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  }
}
</file>

<file path="firestore.indexes.json">
{
  "indexes": [
    {
      "collectionGroup": "citySlots",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "x",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "y",
          "order": "ASCENDING"
        }
      ],
      "density": "SPARSE_ALL"
    },
    {
      "collectionGroup": "godTowns",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "x",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "y",
          "order": "ASCENDING"
        }
      ],
      "density": "SPARSE_ALL"
    },
    {
      "collectionGroup": "ruins",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "x",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "y",
          "order": "ASCENDING"
        }
      ],
      "density": "SPARSE_ALL"
    },
    {
      "collectionGroup": "villages",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "x",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "y",
          "order": "ASCENDING"
        }
      ],
      "density": "SPARSE_ALL"
    }
  ],
  "fieldOverrides": [
    {
      "collectionGroup": "games",
      "fieldPath": "worldName",
      "ttl": false,
      "indexes": [
        {
          "order": "ASCENDING",
          "queryScope": "COLLECTION"
        },
        {
          "order": "DESCENDING",
          "queryScope": "COLLECTION"
        },
        {
          "arrayConfig": "CONTAINS",
          "queryScope": "COLLECTION"
        },
        {
          "order": "ASCENDING",
          "queryScope": "COLLECTION_GROUP"
        }
      ]
    }
  ]
}
</file>

<file path="firestore.rules">
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // This rule allows the efficient collectionGroup query on the 'games' collection.
    // It's needed for features like the global leaderboard.
    match /{path=**}/games/{game} {
      allow list: if true;
    }

    // Allow everyone to read, create, update, and delete user profiles and subcollections
    match /users/{path=**} {
      allow read, create, update, delete: if true;
    }

    // Allow everyone to read, create, update, and delete world data and all its subcollections
    match /worlds/{path=**} {
      allow read, create, update, delete: if true;
    }
  }
}
</file>

<file path="Fixed.txt">
Fixed: 
- Indicator visual on both people (✅)
- Alliance doesn't work on all cities (❌)
- Demolish goes to 0 and not lowering by 1 level (✅)
- Defult troops need to be remove (✅)
- Ruins attack icon movement doesn't happen after arriving (✅)
- Chat has no limit in text (✅)
- Cave at lvl 10 is just 10k not infinite (also make it autoroctect to the amount to fill the cave) (✅)
- Can accept OLD Allince Invite (✅)
- Farm Need population to build (✅)
- Market Spaming Click Create Offer makes more (✅)
- Trading on with your other cities is not working (✅)
- Attacks show all troops in enemy cities (❌ doesn't shows ships now) 
- Agrotika xoria icons are Wrong (✅)
- Academy demolish it always with research and does not deletes them
- spamming building before they reach their max level can bypass it
- Can have the same allince in to allies and Enemies
- Building can be build and going population negative it does not stop before going negative
- Barracks last number does not get deleted there is always 1 number left when using backspace
</file>

<file path="Idees.txt">
Ideas:
If ships dont die to show enemy ships.
- be able to surrender if you have one city and you are about to lose it 
- filter islands to send messages on alliance- enemies etc only
- change city/map view three instead of button to have two icons, one that takes you to the city or out and one that zooms completely out

Idea 1:
There will be 2 special units called agents, one will be able to sabotage enemy city and lower their morale, if the morale of one city goes to -100% a revolt will start and if the player
doesnt have the troops to stop it, it will become a ghost city. The player that sends the agent will get updated with the troops of the city and with the morale. 

If the city becomes a ghost town, any player can send the other agent with troops to hold the city for 5 hours. Anyone that scout the city will be able to see the unit and the time left
for it to get conquered.

For a player to found a city we need the second agent to go inside the city with at least one villager, the more the villager the less time it will take for the city to be found.
</file>

<file path="package.json">
{
  "name": "grepolis-clone",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "firebase": "^10.12.2",
    "framer-motion": "^12.23.9",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.14.1",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [">0.2%", "not dead", "not op_mini all"],
    "development": ["last 1 chrome version", "last 1 firefox version", "last 1 safari version"]
  },
  "devDependencies": {
    "tailwindcss": "^3.4.17"
  }
}
</file>

<file path="public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="A city-building strategy game created with React and Firebase."
    />
    <link rel="apple-touch-icon" href="/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Grepolike</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
</file>

<file path="public/manifest.json">
{
  "short_name": "Grepolike",
  "name": "Grepolis Clone - A City-Building Game",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="src/App.js">
import React, { useState } from 'react';
import { useAuth } from './contexts/AuthContext';
import { GameProvider, useGame } from './contexts/GameContext';
import { AllianceProvider } from './contexts/AllianceProvider';
import { NotificationProvider } from './contexts/NotificationProvider'; // Import NotificationProvider
import AuthScreen from './components/AuthScreen';
import Game from './components/Game';
import WorldSelectionScreen from './components/WorldSelectionScreen';
import CityFounding from './components/CityFounding';
import LoadingScreen from './components/shared/LoadingScreen';

const GameController = ({ onBackToWorlds }) => {
    const { playerHasCities, worldState, loading: gameLoading } = useGame();

    if (gameLoading) {
        return <LoadingScreen message="Loading World Data..." />;
    }

    if (!worldState) {
        return (
            <div className="text-white text-center p-10">
                <p>Error: Could not load the selected world.</p>
                <button onClick={onBackToWorlds} className="btn btn-primary mt-4">Back to World Selection</button>
            </div>
        );
    }

    if (playerHasCities) {
        return <Game onBackToWorlds={onBackToWorlds} />;
    }

    return <CityFounding onCityFounded={() => {}} />;
};


function App() {
    const [selectedWorldId, setSelectedWorldId] = useState(null);
    const { currentUser, loading: authLoading } = useAuth();

    if (authLoading) {
        return <LoadingScreen message="Authenticating..." />;
    }

    if (!currentUser) {
        return <AuthScreen />;
    }

    if (selectedWorldId) {
        return (
            <NotificationProvider>
                <GameProvider worldId={selectedWorldId}>
                    <AllianceProvider>
                        <GameController onBackToWorlds={() => setSelectedWorldId(null)} />
                    </AllianceProvider>
                </GameProvider>
            </NotificationProvider>
        );
    }

    return <WorldSelectionScreen onWorldSelected={setSelectedWorldId} />;
}

export default App;
</file>

<file path="src/components/admin/EventTrigger.js">
// src/components/admin/EventTrigger.js
import React, { useState } from 'react';
import { db } from '../../firebase/config';
import { collection, doc, setDoc, getDocs, query, where, limit, updateDoc, deleteDoc } from 'firebase/firestore';
import { useGame } from '../../contexts/GameContext';
import { generateGodTowns } from '../../utils/worldGeneration';

const EventTrigger = ({ onClose }) => {
    const { worldState, worldId } = useGame();
    const [message, setMessage] = useState('');

    const handleSpawnGodTown = async () => {
        if (!worldState) {
            setMessage("World data is not loaded.");
            return;
        }
        setMessage("Spawning a God Town...");
        try {
            const newTowns = generateGodTowns(worldState.islands, worldState.width, worldState.height, 1);
            if (Object.keys(newTowns).length === 0) {
                throw new Error("Failed to find a suitable location in the sea. Try again.");
            }
            const [townId, townData] = Object.entries(newTowns)[0];

            const townDocRef = doc(db, 'worlds', worldId, 'godTowns', townId);
            await setDoc(townDocRef, townData);

            setMessage(`God Town spawned as "Strange Ruins" at (${townData.x}, ${townData.y})!`);
        } catch (error) {
            console.error("Error spawning God Town:", error);
            setMessage(`Failed to spawn God Town: ${error.message}`);
        }
    };

    const handleTransformRuins = async () => {
        setMessage("Searching for ruins to transform...");
        try {
            const godTownsRef = collection(db, 'worlds', worldId, 'godTowns');
            const q = query(godTownsRef, where('stage', '==', 'ruins'), limit(1));
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                setMessage("No God Town ruins found to transform.");
                return;
            }

            const ruinDoc = querySnapshot.docs[0];
            await updateDoc(ruinDoc.ref, { 
                stage: 'city',
                name: 'City of the Gods'
            });
            setMessage(`Ruins at (${ruinDoc.data().x}, ${ruinDoc.data().y}) transformed into a city!`);

        } catch (error) {
            console.error("Error transforming ruins:", error);
            setMessage(`Failed to transform ruins: ${error.message}`);
        }
    };

    const handleDespawnGodTown = async () => {
        setMessage("Searching for a God Town to despawn...");
        try {
            const godTownsRef = collection(db, 'worlds', worldId, 'godTowns');
            const q = query(godTownsRef, limit(1));
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                setMessage("No God Towns found to despawn.");
                return;
            }

            const townDoc = querySnapshot.docs[0];
            await deleteDoc(townDoc.ref);
            setMessage(`God Town at (${townDoc.data().x}, ${townDoc.data().y}) has been despawned.`);

        } catch (error) {
            console.error("Error despawning God Town:", error);
            setMessage(`Failed to despawn God Town: ${error.message}`);
        }
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border-2 border-gray-600" onClick={e => e.stopPropagation()}>
                <h3 className="font-title text-2xl text-white mb-4">Admin Event Triggers</h3>
                {message && <p className="text-center text-yellow-400 mb-4">{message}</p>}
                <div className="space-y-4">
                    <button onClick={handleSpawnGodTown} className="btn btn-primary w-full py-2 bg-purple-600 hover:bg-purple-500">
                        Spawn God Town Event
                    </button>
                    <button onClick={handleTransformRuins} className="btn btn-primary w-full py-2 bg-green-600 hover:bg-green-500">
                        Instantly Transform Ruins
                    </button>
                    <button onClick={handleDespawnGodTown} className="btn btn-danger w-full py-2">
                        Despawn God Town Event
                    </button>
                </div>
            </div>
        </div>
    );
};

export default EventTrigger;
</file>

<file path="src/components/alliance/AllianceBank.js">
// src/components/alliance/AllianceBank.js
import React, { useState, useEffect, useMemo } from 'react';
import { useAlliance } from '../../contexts/AllianceContext';
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { collection, query, orderBy, onSnapshot } from 'firebase/firestore';
import { db } from '../../firebase/config';
import allianceResearch from '../../gameData/allianceResearch.json';

const AllianceBank = () => {
    const { playerAlliance, donateToBank, distributeFromBank } = useAlliance();
    const { currentUser } = useAuth();
    const { gameState, worldId } = useGame();
    const [donation, setDonation] = useState({ wood: 0, stone: 0, silver: 0 });
    const [distribution, setDistribution] = useState({ wood: 0, stone: 0, silver: 0 });
    const [targetMemberName, setTargetMemberName] = useState('');
    const [targetMemberUid, setTargetMemberUid] = useState('');
    const [logs, setLogs] = useState([]);
    const [message, setMessage] = useState('');

    // Autocomplete states
    const [suggestions, setSuggestions] = useState([]);

    const bank = playerAlliance.bank || { wood: 0, stone: 0, silver: 0 };

    const bankCapacity = useMemo(() => {
        if (!playerAlliance) return 0;
        const baseCapacity = 1000000;
        const researchLevel = playerAlliance.research?.reinforced_vaults?.level || 0;
        const researchBonus = (allianceResearch.reinforced_vaults?.effect.value || 0) * researchLevel;
        return baseCapacity + researchBonus;
    }, [playerAlliance]);

    const memberRankData = useMemo(() => {
        if (!playerAlliance || !currentUser) return null;
        const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
        if (!member) return null;
        return playerAlliance.ranks.find(r => r.id === member.rank);
    }, [playerAlliance, currentUser]);

    const canManageBank = memberRankData?.permissions?.manageBank;

    useEffect(() => {
        if (!playerAlliance || !worldId) return;
        const logsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'bank_logs');
        const q = query(logsRef, orderBy('timestamp', 'desc'));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            setLogs(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
        });
        return () => unsubscribe();
    }, [playerAlliance, worldId]);

    const handleDonationChange = (e) => {
        const { name, value } = e.target;
        const amount = Math.max(0, Math.min(gameState.resources[name] || 0, parseInt(value) || 0));
        setDonation(prev => ({ ...prev, [name]: amount }));
    };

    const handleDistributionChange = (e) => {
        const { name, value } = e.target;
        const amount = Math.max(0, Math.min(bank[name] || 0, parseInt(value) || 0));
        setDistribution(prev => ({ ...prev, [name]: amount }));
    };

    const handleDonate = async () => {
        setMessage('');
        try {
            await donateToBank(donation);
            setMessage('Donation successful!');
            setDonation({ wood: 0, stone: 0, silver: 0 });
        } catch (error) {
            setMessage(`Donation failed: ${error.message}`);
        }
    };

    const handleDistribute = async () => {
        setMessage('');
        if (!targetMemberUid) {
            setMessage('Please select a valid member to distribute resources to.');
            return;
        }
        try {
            await distributeFromBank(targetMemberUid, distribution);
            setMessage('Distribution successful!');
            setDistribution({ wood: 0, stone: 0, silver: 0 });
            setTargetMemberName('');
            setTargetMemberUid('');
        } catch (error) {
            setMessage(`Distribution failed: ${error.message}`);
        }
    };

    const handleTargetMemberChange = (e) => {
        const value = e.target.value;
        setTargetMemberName(value);
        setTargetMemberUid(''); // Clear UID when name changes
        if (value.length > 0) {
            const filteredSuggestions = playerAlliance.members
                .filter(member => member.uid !== currentUser.uid)
                .filter(member => member.username.toLowerCase().startsWith(value.toLowerCase()));
            setSuggestions(filteredSuggestions);
        } else {
            setSuggestions([]);
        }
    };

    const handleSuggestionClick = (member) => {
        setTargetMemberName(member.username);
        setTargetMemberUid(member.uid);
        setSuggestions([]);
    };

    const setDistributionPercentage = (resource, percentage) => {
        const amount = Math.floor((bank[resource] || 0) * percentage);
        setDistribution(prev => ({ ...prev, [resource]: amount }));
    };

    return (
        <div className="bg-amber-100 text-gray-900 p-4 rounded-lg shadow-md">
            <h3 className="text-xl font-bold mb-4 border-b border-amber-300 pb-2">Alliance Bank</h3>
            {message && <p className="text-center text-amber-800 mb-4">{message}</p>}
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="bg-amber-50 p-4 rounded-lg border border-amber-200">
                    <h4 className="font-bold text-lg mb-2">Bank Holdings</h4>
                    <p className="text-sm text-gray-600">Capacity: {bankCapacity.toLocaleString()} per resource</p>
                    <p>Wood: {(bank.wood || 0).toLocaleString()}</p>
                    <p>Stone: {(bank.stone || 0).toLocaleString()}</p>
                    <p>Silver: {(bank.silver || 0).toLocaleString()}</p>
                </div>

                <div className="bg-amber-50 p-4 rounded-lg border border-amber-200">
                    <h4 className="font-bold text-lg mb-2">Donate Resources</h4>
                    <p className="text-xs text-gray-500 mb-2">5 min cooldown | 50,000 daily limit</p>
                    <div className="space-y-2">
                        <div>
                            <label>Wood (Your: {Math.floor(gameState.resources.wood || 0)})</label>
                            <input type="number" name="wood" value={donation.wood} onChange={handleDonationChange} className="w-full p-1 rounded border border-amber-300" />
                        </div>
                        <div>
                            <label>Stone (Your: {Math.floor(gameState.resources.stone || 0)})</label>
                            <input type="number" name="stone" value={donation.stone} onChange={handleDonationChange} className="w-full p-1 rounded border border-amber-300" />
                        </div>
                        <div>
                            <label>Silver (Your: {Math.floor(gameState.resources.silver || 0)})</label>
                            <input type="number" name="silver" value={donation.silver} onChange={handleDonationChange} className="w-full p-1 rounded border border-amber-300" />
                        </div>
                        <button onClick={handleDonate} className="btn btn-confirm w-full">Donate</button>
                    </div>
                </div>

                {canManageBank && (
                    <div className="bg-amber-50 p-4 rounded-lg border border-amber-200 md:col-span-2">
                        <h4 className="font-bold text-lg mb-2">Distribute Resources</h4>
                        <div className="grid grid-cols-1 md:grid-cols-7 gap-4 items-end">
                            <div className="md:col-span-2 autocomplete-suggestions-container">
                                <label>Member</label>
                                <input
                                    type="text"
                                    value={targetMemberName}
                                    onChange={handleTargetMemberChange}
                                    placeholder="Player Username"
                                    className="w-full p-1 rounded border border-amber-300"
                                    autoComplete="off"
                                />
                                {suggestions.length > 0 && (
                                    <ul className="autocomplete-suggestions-list light">
                                        {suggestions.map(member => (
                                            <li key={member.uid} onClick={() => handleSuggestionClick(member)}>
                                                {member.username}
                                            </li>
                                        ))}
                                    </ul>
                                )}
                            </div>
                            <div className="md:col-span-5 grid grid-cols-3 gap-x-4">
                                <div>
                                    <label>Wood</label>
                                    <input type="number" name="wood" value={distribution.wood} onChange={handleDistributionChange} className="w-full p-1 rounded border border-amber-300 mb-1" />
                                    <div className="flex items-center gap-1">
                                        <button onClick={() => setDistributionPercentage('wood', 0.25)} className="btn btn-secondary text-xs px-1 py-0.5 flex-1">25%</button>
                                        <button onClick={() => setDistributionPercentage('wood', 0.50)} className="btn btn-secondary text-xs px-1 py-0.5 flex-1">50%</button>
                                        <button onClick={() => setDistributionPercentage('wood', 1)} className="btn btn-secondary text-xs px-1 py-0.5 flex-1">Max</button>
                                    </div>
                                </div>
                                <div>
                                    <label>Stone</label>
                                    <input type="number" name="stone" value={distribution.stone} onChange={handleDistributionChange} className="w-full p-1 rounded border border-amber-300 mb-1" />
                                     <div className="flex items-center gap-1">
                                        <button onClick={() => setDistributionPercentage('stone', 0.25)} className="btn btn-secondary text-xs px-1 py-0.5 flex-1">25%</button>
                                        <button onClick={() => setDistributionPercentage('stone', 0.50)} className="btn btn-secondary text-xs px-1 py-0.5 flex-1">50%</button>
                                        <button onClick={() => setDistributionPercentage('stone', 1)} className="btn btn-secondary text-xs px-1 py-0.5 flex-1">Max</button>
                                    </div>
                                </div>
                                <div>
                                    <label>Silver</label>
                                    <input type="number" name="silver" value={distribution.silver} onChange={handleDistributionChange} className="w-full p-1 rounded border border-amber-300 mb-1" />
                                     <div className="flex items-center gap-1">
                                        <button onClick={() => setDistributionPercentage('silver', 0.25)} className="btn btn-secondary text-xs px-1 py-0.5 flex-1">25%</button>
                                        <button onClick={() => setDistributionPercentage('silver', 0.50)} className="btn btn-secondary text-xs px-1 py-0.5 flex-1">50%</button>
                                        <button onClick={() => setDistributionPercentage('silver', 1)} className="btn btn-secondary text-xs px-1 py-0.5 flex-1">Max</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button onClick={handleDistribute} className="btn btn-primary w-full mt-4">Distribute</button>
                    </div>
                )}

                <div className="bg-amber-50 p-4 rounded-lg border border-amber-200 md:col-span-2">
                    <h4 className="font-bold text-lg mb-2">Transaction History</h4>
                    <ul className="space-y-2 max-h-48 overflow-y-auto">
                        {logs.map(log => (
                            <li key={log.id} className="text-sm p-2 bg-white rounded border border-amber-200">
                                {log.type === 'donation' ? (
                                    <span><strong>{log.user}</strong> donated {Object.entries(log.resources).filter(([,a])=>a>0).map(([r,a]) => `${a.toLocaleString()} ${r}`).join(', ')}.</span>
                                ) : (
                                    <span><strong>{log.from}</strong> sent {Object.entries(log.resources).filter(([,a])=>a>0).map(([r,a]) => `${a.toLocaleString()} ${r}`).join(', ')} to <strong>{log.to}</strong>.</span>
                                )}
                                <span className="text-xs text-gray-500 float-right">{log.timestamp?.toDate().toLocaleTimeString()}</span>
                            </li>
                        ))}
                    </ul>
                </div>
            </div>
        </div>
    );
};

export default AllianceBank;
</file>

<file path="src/components/alliance/AllianceCreation.js">
// src/components/alliance/AllianceCreation.js
import React, { useState } from 'react';
import { useAlliance } from '../../contexts/AllianceContext';

const AllianceCreation = ({ onClose }) => {
    const { createAlliance } = useAlliance();
    const [name, setName] = useState('');
    const [tag, setTag] = useState('');
    const [error, setError] = useState('');

    // #comment handle create alliance and show errors
    const handleCreate = async () => {
        setError('');
        if (name.trim() && tag.trim()) {
            try {
                await createAlliance(name.trim(), tag.trim());
                onClose();
            } catch (err) {
                setError(err.message);
            }
        } else {
            setError('Both name and tag are required.');
        }
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border-2 border-gray-600 text-white" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="text-xl font-bold mb-2">Create an Alliance</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                {error && <p className="text-red-500 text-center mb-4">{error}</p>}
                <div className="flex flex-col gap-4">
                    <input
                        type="text"
                        value={name}
                        onChange={(e) => setName(e.target.value)}
                        placeholder="Alliance Name"
                        className="w-full bg-gray-900 p-2 rounded"
                    />
                    <input
                        type="text"
                        value={tag}
                        onChange={(e) => setTag(e.target.value)}
                        placeholder="Alliance Tag (e.g., ABC)"
                        maxLength="5"
                        className="w-full bg-gray-900 p-2 rounded"
                    />
                    <button onClick={handleCreate} className="btn btn-confirm">Create Alliance</button>
                </div>
            </div>
        </div>
    );
};

export default AllianceCreation;
</file>

<file path="src/components/alliance/AllianceDiplomacy.js">
import React, { useState, useEffect } from 'react';
import { useAlliance } from '../../contexts/AllianceContext';
import { db } from '../../firebase/config';
import { collection, getDocs, query, where } from 'firebase/firestore';
import { useGame } from '../../contexts/GameContext';
import TextEditor from '../shared/TextEditor';

// #comment Cache for diplomacy data to reduce reads.
const diplomacyCache = {
    alliances: null,
    allCities: null,
    timestamp: 0,
};

// #comment Local cache for alliance cities to reduce N+1 queries.
let allianceCitiesCache = {
    cities: null,
    timestamp: 0,
};

export const clearDiplomacyCache = () => {
    diplomacyCache.alliances = null;
    diplomacyCache.allCities = null;
    diplomacyCache.timestamp = 0;
    allianceCitiesCache.cities = null;
    allianceCitiesCache.timestamp = 0;
};

const AllianceDiplomacy = () => {
    const { playerAlliance, sendAllyRequest, declareEnemy, handleDiplomacyResponse, proposeTreaty } = useAlliance();
    const { worldId} = useGame();
    const [targetTag, setTargetTag] = useState('');
    const [message, setMessage] = useState('');

    // State for treaty proposals
    const [treatyTargetTag, setTreatyTargetTag] = useState('');
    const [offerType, setOfferType] = useState('resources');
    const [offerResources, setOfferResources] = useState({ wood: 0, stone: 0, silver: 0 });
    const [offerCityId, setOfferCityId] = useState('');
    const [offerAllianceAction, setOfferAllianceAction] = useState('declare_war');
    const [offerTargetAlliance, setOfferTargetAlliance] = useState('');
    const [demandType, setDemandType] = useState('resources');
    const [demandResources, setDemandResources] = useState({ wood: 0, stone: 0, silver: 0 });
    const [demandCityName, setDemandCityName] = useState('');
    const [demandAllianceAction, setDemandAllianceAction] = useState('declare_war');
    const [demandTargetAlliance, setDemandTargetAlliance] = useState('');
    const [frequency, setFrequency] = useState('once');
    const [occurrences, setOccurrences] = useState(1);
    const [treatyMessage, setTreatyMessage] = useState('');

    // Autocomplete states
    const [allAlliances, setAllAlliances] = useState([]);
    const [allCities, setAllCities] = useState([]);
    const [allAllianceCities, setAllAllianceCities] = useState([]);
    const [suggestions, setSuggestions] = useState([]);
    const [activeSuggestionInput, setActiveSuggestionInput] = useState(null);

    // #comment Fetch all alliances, world cities, and alliance cities for autocomplete and offers
    useEffect(() => {
        if (!worldId || !playerAlliance) return;

        const fetchData = async () => {
            const now = Date.now();
            const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

            if (now - diplomacyCache.timestamp < CACHE_DURATION && diplomacyCache.alliances && diplomacyCache.allCities) {
                setAllAlliances(diplomacyCache.alliances.filter(tag => tag !== playerAlliance.tag));
                setAllCities(diplomacyCache.allCities);
            } else {
                const alliancesRef = collection(db, 'worlds', worldId, 'alliances');
                const alliancesSnapshot = await getDocs(alliancesRef);
                const alliances = alliancesSnapshot.docs.map(doc => doc.data().tag);
                setAllAlliances(alliances.filter(tag => tag !== playerAlliance.tag));
                diplomacyCache.alliances = alliances;

                const citiesRef = collection(db, 'worlds', worldId, 'citySlots');
                const q = query(citiesRef, where("ownerId", "!=", null));
                const citiesSnapshot = await getDocs(q);
                const cities = citiesSnapshot.docs.map(doc => ({ name: doc.data().cityName, x: doc.data().x, y: doc.data().y }));
                setAllCities(cities);
                diplomacyCache.allCities = cities;

                diplomacyCache.timestamp = now;
            }

            // #comment Use local cache for alliance cities to prevent N+1 queries on every view
            if (now - allianceCitiesCache.timestamp < CACHE_DURATION && allianceCitiesCache.cities) {
                setAllAllianceCities(allianceCitiesCache.cities);
            } else {
                // #comment Fetch cities from all members in parallel for better performance
                const memberPromises = playerAlliance.members.map(async (member) => {
                    const citiesRef = collection(db, `users/${member.uid}/games`, worldId, 'cities');
                    const snapshot = await getDocs(citiesRef);
                    return snapshot.docs.map(doc => ({ owner: member.username, ...doc.data() }));
                });
        
                const citiesByMember = await Promise.all(memberPromises);
                const cities = citiesByMember.flat();

                setAllAllianceCities(cities);
                allianceCitiesCache.cities = cities;
                allianceCitiesCache.timestamp = now;
            }
        };

        fetchData();
    }, [worldId, playerAlliance]);


    const handleInputChange = (value, fieldSetter, fieldName) => {
        fieldSetter(value);
        setActiveSuggestionInput(fieldName);

        let sourceData = [];
        if (fieldName === 'demandCity') {
            sourceData = allCities.map(c => c.name);
        } else {

            sourceData = allAlliances;
        }

        if (value.length > 0 && sourceData.length > 0) {
            const filteredSuggestions = sourceData.filter(item =>
                item.toLowerCase().startsWith(value.toLowerCase())
            );
            setSuggestions(filteredSuggestions.slice(0, 5));
        } else {
            setSuggestions([]);
        }
    };

    const handleSuggestionClick = (value) => {
        if (activeSuggestionInput === 'targetTag') setTargetTag(value);
        if (activeSuggestionInput === 'treatyTargetTag') setTreatyTargetTag(value);
        if (activeSuggestionInput === 'offerTargetAlliance') setOfferTargetAlliance(value);
        if (activeSuggestionInput === 'demandTargetAlliance') setDemandTargetAlliance(value);
        if (activeSuggestionInput === 'demandCity') setDemandCityName(value);
        setSuggestions([]);
        setActiveSuggestionInput(null);
    };

    const handleRequest = async () => {
        if (!targetTag.trim()) return;
        setMessage('');
        try {
            await sendAllyRequest(targetTag.trim().toUpperCase());
            setMessage(`Ally request sent to [${targetTag.trim().toUpperCase()}]`);
            setTargetTag('');
        } catch (error) {
            setMessage(error.message);
        }
    };

    const handleDeclareEnemy = async () => {
        if (!targetTag.trim()) return;
        setMessage('');
        try {
            await declareEnemy(targetTag.trim().toUpperCase());
            setMessage(`[${targetTag.trim().toUpperCase()}] has been declared as an enemy.`);
            setTargetTag('');
        } catch (error) {
            setMessage(error.message);
        }
    };

    const handleResponse = async (targetAllianceId, action) => {
        setMessage('');
        try {
            await handleDiplomacyResponse(targetAllianceId, action);
            setMessage('Diplomatic status updated.');
        } catch (error) {
            setMessage(error.message);
        }
    };

    const handleProposeTreaty = async () => {
        if (!treatyTargetTag.trim()) {
            setMessage('Please enter a target alliance tag for the treaty.');
            return;
        }
        setMessage('');
        try {
            let offerPayload;
            if (offerType === 'resources') {
                offerPayload = { type: 'resources', data: offerResources };
            } else if (offerType === 'city') {
                if (!offerCityId) throw new Error("You must select a city to offer.");
                const offeredCity = allAllianceCities.find(c => c.id === offerCityId);
                if (!offeredCity) throw new Error("Offered city not found in alliance.");
                offerPayload = { type: 'city', cityId: offerCityId, cityName: offeredCity.cityName, coords: `${offeredCity.x},${offeredCity.y}` };
            } else {
                offerPayload = { type: 'alliance_action', action: offerAllianceAction, target: offerTargetAlliance };
            }

            let demandPayload;
            if (demandType === 'resources') {
                demandPayload = { type: 'resources', data: demandResources };
            } else if (demandType === 'city') {
                const demandedCity = allCities.find(c => c.name.toLowerCase() === demandCityName.toLowerCase());
                if (!demandedCity) throw new Error("The demanded city does not exist or could not be found.");
                demandPayload = { type: 'city', coords: `${demandedCity.x},${demandedCity.y}`, cityName: demandedCity.name };
            } else {
                demandPayload = { type: 'alliance_action', action: demandAllianceAction, target: demandTargetAlliance };
            }

            const details = {
                offer: offerPayload,
                demand: demandPayload,
                frequency,
                occurrences: frequency === 'once' ? 1 : occurrences,
                message: treatyMessage,
            };
            await proposeTreaty(treatyTargetTag.trim().toUpperCase(), details);
            setMessage(`Treaty proposed to [${treatyTargetTag.trim().toUpperCase()}]`);
            setTreatyTargetTag('');
        } catch (error) {
            setMessage(`Failed to propose treaty: ${error.message}`);
        }
    };

    const diplomacy = playerAlliance.diplomacy || {};
    const requests = diplomacy.requests || [];
    const allies = diplomacy.allies || [];
    const enemies = diplomacy.enemies || [];

    const allianceActionNeedsTarget = (action) => {
        return ['declare_war', 'form_pact', 'coordinated_attack'].includes(action);
    };

    return (
        <div className="bg-amber-100 text-gray-900 p-4 rounded-lg shadow-md space-y-6">
            <div>
                <h3 className="text-xl font-bold mb-4 border-b border-amber-300 pb-2">Diplomacy</h3>
                <div className="bg-amber-50 p-4 rounded-lg mb-6 border border-amber-200">
                    <h4 className="font-bold mb-2 text-gray-900">Make a Declaration</h4>
                    <div className="flex gap-2 autocomplete-suggestions-container">
                        <input
                            type="text"
                            value={targetTag}
                            onChange={(e) => handleInputChange(e.target.value, setTargetTag, 'targetTag')}
                            placeholder="Enter Alliance Tag"
                            className="w-full bg-white text-gray-900 p-2 rounded border border-amber-300"
                            maxLength="5"
                            autoComplete="off"
                        />
                        {suggestions.length > 0 && activeSuggestionInput === 'targetTag' && (
                            <ul className="autocomplete-suggestions-list light">
                                {suggestions.map(tag => (
                                    <li key={tag} onClick={() => handleSuggestionClick(tag)}>
                                        {tag}
                                    </li>
                                ))}
                            </ul>
                        )}
                        <button onClick={handleRequest} className="btn btn-confirm bg-green-600 hover:bg-green-700 text-white">Ally Request</button>
                        <button onClick={handleDeclareEnemy} className="btn btn-danger bg-red-600 hover:bg-red-700 text-white">Declare Enemy</button>
                    </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div className="bg-amber-50 p-3 rounded-lg border border-amber-200">
                        <h4 className="font-bold mb-2 text-gray-900">Incoming Requests</h4>
                        <ul className="space-y-2">
                            {requests.length > 0 ? requests.map(req => (
                                <li key={req.id} className="bg-white text-gray-900 p-2 rounded flex justify-between items-center border border-amber-200">
                                    <span>{req.name} [{req.tag}]</span>
                                    <div className="flex gap-1">
                                        <button onClick={() => handleResponse(req.id, 'accept')} className="btn btn-confirm bg-green-600 hover:bg-green-700 text-white text-xs px-2 py-1">✓</button>
                                        <button onClick={() => handleResponse(req.id, 'reject')} className="btn btn-danger bg-red-600 hover:bg-red-700 text-white text-xs px-2 py-1">✗</button>
                                    </div>
                                </li>
                            )) : <li className="text-amber-800 italic">None</li>}
                        </ul>
                    </div>

                    <div className="bg-amber-50 p-3 rounded-lg border border-amber-200">
                        <h4 className="font-bold mb-2 text-gray-900">Allies</h4>
                        <ul className="space-y-2">
                            {allies.length > 0 ? allies.map(ally => (
                                <li key={ally.id} className="bg-white text-gray-900 p-2 rounded flex justify-between items-center border border-amber-200">
                                    <span>{ally.name} [{ally.tag}]</span>
                                    <button onClick={() => handleResponse(ally.id, 'removeAlly')} className="btn btn-danger bg-red-600 hover:bg-red-700 text-white text-xs px-2 py-1">Remove</button>
                                </li>
                            )) : <li className="text-amber-800 italic">None</li>}
                        </ul>
                    </div>

                    <div className="bg-amber-50 p-3 rounded-lg border border-amber-200">
                        <h4 className="font-bold mb-2 text-gray-900">Enemies</h4>
                        <ul className="space-y-2">
                            {enemies.length > 0 ? enemies.map(enemy => (
                                <li key={enemy.id} className="bg-white text-gray-900 p-2 rounded flex justify-between items-center border border-amber-200">
                                    <span>{enemy.name} [{enemy.tag}]</span>
                                    <button onClick={() => handleResponse(enemy.id, 'removeEnemy')} className="btn btn-primary bg-blue-600 hover:bg-blue-700 text-white text-xs px-2 py-1">Remove</button>
                                </li>
                            )) : <li className="text-amber-800 italic">None</li>}
                        </ul>
                    </div>
                </div>
            </div>

            <div>
                <h3 className="text-xl font-bold mb-4 border-b border-amber-300 pb-2">Treaties</h3>
                <div className="bg-amber-50 p-4 rounded-lg border border-amber-200">
                    <h4 className="font-bold mb-2 text-gray-900">Propose a Treaty</h4>
                    <div className="space-y-3">
                        <div className="autocomplete-suggestions-container">
                            <input type="text" value={treatyTargetTag} onChange={(e) => handleInputChange(e.target.value, setTreatyTargetTag, 'treatyTargetTag')} placeholder="Target Alliance Tag" className="w-full p-2 rounded border border-amber-300" autoComplete="off" />
                            {suggestions.length > 0 && activeSuggestionInput === 'treatyTargetTag' && (
                                <ul className="autocomplete-suggestions-list light">
                                    {suggestions.map(tag => (
                                        <li key={tag} onClick={() => handleSuggestionClick(tag)}>
                                            {tag}
                                        </li>
                                    ))}
                                </ul>
                            )}
                        </div>

                        <div className="border p-2 rounded">
                            <h5 className="font-semibold">You Offer:</h5>
                            <select value={offerType} onChange={(e) => setOfferType(e.target.value)}>
                                <option value="resources">Resources</option>
                                <option value="alliance_action">Alliance Action</option>
                                <option value="city">City</option>
                            </select>
                            {offerType === 'resources' ? (
                                <div className="grid grid-cols-3 gap-2 mt-2">
                                    <input type="number" value={offerResources.wood} onChange={(e) => setOfferResources(prev => ({...prev, wood: parseInt(e.target.value) || 0}))} placeholder="Wood" />
                                    <input type="number" value={offerResources.stone} onChange={(e) => setOfferResources(prev => ({...prev, stone: parseInt(e.target.value) || 0}))} placeholder="Stone" />
                                    <input type="number" value={offerResources.silver} onChange={(e) => setOfferResources(prev => ({...prev, silver: parseInt(e.target.value) || 0}))} placeholder="Silver" />
                                </div>
                            ) : offerType === 'city' ? (
                                <select value={offerCityId} onChange={(e) => setOfferCityId(e.target.value)} className="w-full p-2 rounded border border-amber-300 mt-2">
                                    <option value="">Select a city to offer</option>
                                    {Object.values(allAllianceCities.reduce((acc, city) => {
                                        (acc[city.owner] = acc[city.owner] || []).push(city);
                                        return acc;
                                    }, {})).map((cities, index) => (
                                        <optgroup label={cities[0].owner} key={index}>
                                            {cities.map(city => (
                                                <option key={city.id} value={city.id}>{city.cityName} ({city.x},{city.y})</option>
                                            ))}
                                        </optgroup>
                                    ))}
                                </select>
                            ) : (
                                <div className="grid grid-cols-2 gap-2 mt-2 autocomplete-suggestions-container">
                                    <select value={offerAllianceAction} onChange={(e) => setOfferAllianceAction(e.target.value)}>
                                        <option value="declare_war">Declare War On</option>
                                        <option value="form_pact">Form Pact With</option>
                                        <option value="non_aggression">Non-Aggression Pact</option>
                                        <option value="coordinated_attack">Coordinated Attack On</option>
                                        <option value="offer_peace">Offer Peace</option>
                                    </select>
                                    {allianceActionNeedsTarget(offerAllianceAction) && (
                                        <input type="text" value={offerTargetAlliance} onChange={(e) => handleInputChange(e.target.value, setOfferTargetAlliance, 'offerTargetAlliance')} placeholder="Target Alliance Tag" autoComplete="off"/>
                                    )}
                                    {suggestions.length > 0 && activeSuggestionInput === 'offerTargetAlliance' && (
                                        <ul className="autocomplete-suggestions-list light">
                                            {suggestions.map(tag => (
                                                <li key={tag} onClick={() => handleSuggestionClick(tag)}>
                                                    {tag}
                                                </li>
                                            ))}
                                        </ul>
                                    )}
                                </div>
                            )}
                        </div>

                        <div className="border p-2 rounded">
                            <h5 className="font-semibold">You Demand:</h5>
                            <select value={demandType} onChange={(e) => setDemandType(e.target.value)}>
                                <option value="resources">Resources</option>
                                <option value="alliance_action">Alliance Action</option>
                                <option value="city">City</option>
                            </select>
                            {demandType === 'resources' ? (
                                <div className="grid grid-cols-3 gap-2 mt-2">
                                    <input type="number" value={demandResources.wood} onChange={(e) => setDemandResources(prev => ({...prev, wood: parseInt(e.target.value) || 0}))} placeholder="Wood" />
                                    <input type="number" value={demandResources.stone} onChange={(e) => setDemandResources(prev => ({...prev, stone: parseInt(e.target.value) || 0}))} placeholder="Stone" />
                                    <input type="number" value={demandResources.silver} onChange={(e) => setDemandResources(prev => ({...prev, silver: parseInt(e.target.value) || 0}))} placeholder="Silver" />
                                </div>
                            ) : demandType === 'city' ? (
                                <div className="autocomplete-suggestions-container mt-2">
                                    <input
                                        type="text"
                                        value={demandCityName}
                                        onChange={(e) => handleInputChange(e.target.value, setDemandCityName, 'demandCity')}
                                        placeholder="Enter City Name"
                                        className="w-full p-2 rounded border border-amber-300"
                                        autoComplete="off"
                                    />
                                    {suggestions.length > 0 && activeSuggestionInput === 'demandCity' && (
                                        <ul className="autocomplete-suggestions-list light">
                                            {suggestions.map(name => (
                                                <li key={name} onClick={() => handleSuggestionClick(name)}>
                                                    {name}
                                                </li>
                                            ))}
                                        </ul>
                                    )}
                                </div>
                            ) : (
                                <div className="grid grid-cols-2 gap-2 mt-2 autocomplete-suggestions-container">
                                    <select value={demandAllianceAction} onChange={(e) => setDemandAllianceAction(e.target.value)}>
                                        <option value="declare_war">Declare War On</option>
                                        <option value="form_pact">Form Pact With</option>
                                        <option value="non_aggression">Non-Aggression Pact</option>
                                        <option value="coordinated_attack">Coordinated Attack On</option>
                                        <option value="demand_surrender">Demand Surrender</option>
                                    </select>
                                    {allianceActionNeedsTarget(demandAllianceAction) && (
                                        <input type="text" value={demandTargetAlliance} onChange={(e) => handleInputChange(e.target.value, setDemandTargetAlliance, 'demandTargetAlliance')} placeholder="Target Alliance Tag" autoComplete="off"/>
                                    )}
                                    {suggestions.length > 0 && activeSuggestionInput === 'demandTargetAlliance' && (
                                        <ul className="autocomplete-suggestions-list light">
                                            {suggestions.map(tag => (
                                                <li key={tag} onClick={() => handleSuggestionClick(tag)}>
                                                    {tag}
                                                </li>
                                            ))}
                                        </ul>
                                    )}
                                </div>
                            )}
                        </div>

                        <div className="grid grid-cols-2 gap-2">
                            <select value={frequency} onChange={(e) => setFrequency(e.target.value)}>
                                <option value="once">Once</option>
                                <option value="daily">Daily</option>
                                <option value="weekly">Weekly</option>
                            </select>
                            {frequency !== 'once' && (
                                <input type="number" value={occurrences} onChange={(e) => setOccurrences(parseInt(e.target.value) || 1)} placeholder="Occurrences" />
                            )}
                        </div>
                        <TextEditor value={treatyMessage} onChange={setTreatyMessage} />
                        <button onClick={handleProposeTreaty} className="btn btn-confirm w-full">Propose Treaty</button>
                    </div>
                </div>
            </div>
            {message && <p className="text-sm mt-2 text-amber-800">{message}</p>}
        </div>
    );
};

export default AllianceDiplomacy;
</file>

<file path="src/components/alliance/AllianceForum.css">
.forum-container {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F); /* saddlebrown to peru */
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a; /* A dark, ink-like brown */
    font-family: 'Inter', sans-serif;
    position: fixed;
    z-index: 50;
}

.alliance-forum-header {
    cursor: move;
}

.forum-tabs-container {
    display: flex;
    flex-wrap: wrap;
    background-color: #1e3a8a;
    padding: 4px;
    border-bottom: 4px solid #8B4513;
}

.forum-tab {
    padding: 8px 16px;
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #4a2c2a;
    border: 2px solid #8B4513;
    border-bottom: none;
    border-top-left-radius: 6px;
    border-top-right-radius: 6px;
    margin-right: 4px;
    cursor: pointer;
    font-weight: bold;
}

.forum-tab:hover {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}

.forum-tab.active {
    background: #F5DEB3;
    color: #4a2c2a;
}

.new-forum-btn {
    font-size: 1.2rem;
    padding: 4px 12px;
}

.forum-header {
    background-color: #1e3a8a; /* A dark blue */
    color: #f0e68c; /* khaki */
    padding: 0.5rem 1rem;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.25rem;
    border-bottom: 2px solid #cd853f; /* peru */
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

.forum-table {
    width: 100%;
    border-collapse: collapse;
}

.forum-table thead {
    background-color: #1e3a8a;
    color: #f0e68c;
}

.forum-table th {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 2px solid #cd853f;
}

.forum-table td {
    padding: 0.75rem;
    border-bottom: 1px solid #d2b48c; /* tan */
}

.forum-table tr:hover td {
    background-color: rgba(139, 69, 19, 0.1);
    cursor: pointer;
}

.forum-btn {
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #4a2c2a;
    font-weight: bold;
    border: 2px solid #8B4513;
    border-radius: 4px;
    padding: 0.5rem 1.5rem;
    transition: all 0.2s;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
    text-shadow: 0 1px 0 rgba(255, 255, 255, 0.3);
}

.forum-btn:hover {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}

.post-view {
    padding: 1rem;
}

.post-item {
    background-color: rgba(139, 69, 19, 0.05);
    border: 1px solid #d2b48c;
    border-radius: 4px;
    padding: 1rem;
}

.post-author {
    font-weight: bold;
    color: #8B4513;
}

.post-content {
    white-space: pre-wrap;
    margin-top: 0.5rem;
    word-break: break-word; /* To wrap long words */
}

.bbcode-quote {
    border-left: 4px solid #cd853f;
    padding-left: 1rem;
    margin: 0.5rem 0;
    background-color: rgba(139, 69, 19, 0.1);
    border-radius: 4px;
    font-style: italic;
}

.bbcode-player {
    font-weight: bold;
    color: #1e3a8a;
    cursor: pointer;
}

.bbcode-player:hover {
    text-decoration: underline;
}

.post-timestamp {
    font-size: 0.75rem;
    color: #6b4a2b;
    text-align: right;
    margin-top: 0.5rem;
}

.reply-form textarea {
    width: 100%;
    min-height: 120px;
    background-color: rgba(255, 255, 255, 0.5);
    border: 1px solid #d2b48c;
    border-radius: 4px;
    padding: 0.5rem;
    color: #4a2c2a;
}

.post-actions {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
    margin-top: 0.5rem;
}

.post-action-btn {
    background: none;
    border: none;
    color: #8B4513;
    cursor: pointer;
    font-size: 0.75rem;
    font-weight: bold;
}

.post-action-btn:hover {
    text-decoration: underline;
}
</file>

<file path="src/components/alliance/AllianceForum.js">
import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import ReactDOM from 'react-dom';
import { db } from '../../firebase/config';
import { collection, query, orderBy, onSnapshot, addDoc, serverTimestamp, doc, updateDoc, setDoc, deleteDoc, getDocs, writeBatch } from 'firebase/firestore';
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { useAlliance } from '../../contexts/AllianceContext';
import TextEditor from '../shared/TextEditor';
import { parseBBCode } from '../../utils/bbcodeParser';
import SharedReportView from '../SharedReportView';
import './AllianceForum.css';


const ConfirmationModal = ({ message, onConfirm, onCancel }) => (
    <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black bg-opacity-70">
        <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-center border border-gray-600 text-white">
            <p className="mb-6 text-lg">{message}</p>
            <div className="flex justify-center space-x-4">
                <button onClick={onCancel} className="forum-btn">Cancel</button>
                <button onClick={onConfirm} className="forum-btn">Confirm</button>
            </div>
        </div>
    </div>
);

const AllianceForum = ({ onClose, onActionClick }) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId } = useGame();
    const { playerAlliance } = useAlliance();


    const [forums, setForums] = useState([]);
    const [selectedForum, setSelectedForum] = useState(null);
    const [threads, setThreads] = useState([]);
    const [selectedThread, setSelectedThread] = useState(null);
    const [posts, setPosts] = useState([]);


    const [newForumName, setNewForumName] = useState('');
    const [isNewForumSecret, setIsNewForumSecret] = useState(false);
    const [newThreadTitle, setNewThreadTitle] = useState('');
    const [newPostContent, setNewPostContent] = useState('');
    const [isCreatingForum, setIsCreatingForum] = useState(false);
    const [isCreatingThread, setIsCreatingThread] = useState(false);
    const [editingPostId, setEditingPostId] = useState(null);
    const [editingPostContent, setEditingPostContent] = useState('');
    const [confirmAction, setConfirmAction] = useState(null);
    const [editingForum, setEditingForum] = useState(null);
    const postsEndRef = useRef(null);
    const postContainerRef = useRef(null); // Ref for the post container

    const isLeader = currentUser?.uid === playerAlliance?.leader?.uid;

    const forumRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 1000) / 2,
        y: (window.innerHeight - 700) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('alliance-forum-header') || e.target.parentElement.classList.contains('alliance-forum-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);


    // #comment Get current member's rank and permissions
    const memberRankData = useMemo(() => {
        if (!playerAlliance || !currentUser) return null;
        const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
        if (!member) return null;
        return playerAlliance.ranks.find(r => r.id === member.rank);
    }, [playerAlliance, currentUser]);

    const canViewSecretForums = memberRankData?.permissions?.viewSecretForums || isLeader;


    useEffect(() => {
        if (!worldId || !playerAlliance) return;
        const forumsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'forums');
        const q = query(forumsRef, orderBy('createdAt', 'asc'));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            const forumsData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setForums(forumsData);
            if (!selectedForum && forumsData.length > 0) {
                setSelectedForum(forumsData[0]);
            }
        });
        return () => unsubscribe();
    }, [worldId, playerAlliance, selectedForum]);


    useEffect(() => {
        if (!selectedForum) return;
        const threadsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'forums', selectedForum.id, 'threads');
        const q = query(threadsRef, orderBy('lastReplyAt', 'desc'));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            setThreads(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
        });
        return () => unsubscribe();
    }, [selectedForum, worldId, playerAlliance]);


    useEffect(() => {
        if (!selectedThread) {
            setPosts([]);
            return;
        }
        const postsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'forums', selectedForum.id, 'threads', selectedThread.id, 'posts');
        const q = query(postsRef, orderBy('createdAt', 'asc'));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            setPosts(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
        });
        return () => unsubscribe();
    }, [selectedThread, selectedForum, worldId, playerAlliance]);

    useEffect(() => {
        postsEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [posts]);


    useEffect(() => {
        if (postContainerRef.current) {
            const placeholders = postContainerRef.current.querySelectorAll('.shared-report-placeholder');
            placeholders.forEach(placeholder => {
                const reportId = placeholder.dataset.reportId;
                if (reportId) {
                    ReactDOM.render(<SharedReportView reportId={reportId} worldId={worldId} onClose={() => {}} isEmbedded={true} onActionClick={onActionClick} />, placeholder);
                }
            });
        }
    }, [posts, worldId, onActionClick]);


    const handleCreateForum = async (e) => {
        e.preventDefault();
        if (!newForumName.trim() || !isLeader) return;
        const forumsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'forums');
        await addDoc(forumsRef, {
            name: newForumName,
            isSecret: isNewForumSecret,
            createdAt: serverTimestamp(),
        });
        setNewForumName('');
        setIsNewForumSecret(false);
        setIsCreatingForum(false);
    };

    // handle creation of a new thread within a forum
    const handleCreateThread = async (e) => {
        e.preventDefault();
        if (!newThreadTitle.trim() || !newPostContent.trim() || !selectedForum) return;

        const threadsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'forums', selectedForum.id, 'threads');
        const newThreadRef = doc(threadsRef);

        await setDoc(newThreadRef, {
            title: newThreadTitle,
            creatorId: currentUser.uid,
            creatorUsername: userProfile.username,
            createdAt: serverTimestamp(),
            lastReplyAt: serverTimestamp(),
            lastReplyBy: userProfile.username,
            lastReplyById: currentUser.uid,
            replyCount: 0,
        });

        const postsRef = collection(newThreadRef, 'posts');
        await addDoc(postsRef, {
            content: newPostContent,
            authorId: currentUser.uid,
            authorUsername: userProfile.username,
            createdAt: serverTimestamp(),
        });

        setNewThreadTitle('');
        setNewPostContent('');
        setIsCreatingThread(false);
    };

    // handle replying to a thread
    const handleReply = async (e) => {
        e.preventDefault();
        if (!newPostContent.trim() || !selectedThread) return;

        const threadRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'forums', selectedForum.id, 'threads', selectedThread.id);
        const postsRef = collection(threadRef, 'posts');

        await addDoc(postsRef, {
            content: newPostContent,
            authorId: currentUser.uid,
            authorUsername: userProfile.username,
            createdAt: serverTimestamp(),
        });

        await updateDoc(threadRef, {
            lastReplyAt: serverTimestamp(),
            lastReplyBy: userProfile.username,
            lastReplyById: currentUser.uid,
            replyCount: (selectedThread.replyCount || 0) + 1,
        });

        setNewPostContent('');
    };

    // handle deleting a post
    const handleDeletePost = (postId) => {
        setConfirmAction({
            message: "Are you sure you want to delete this post?",
            onConfirm: async () => {
                if (!selectedThread) return;
                const postRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'forums', selectedForum.id, 'threads', selectedThread.id, 'posts', postId);
                await deleteDoc(postRef);
                setConfirmAction(null);
            }
        });
    };


    const handleStartEdit = (post) => {
        setEditingPostId(post.id);
        setEditingPostContent(post.content);
    };


    const handleCancelEdit = () => {
        setEditingPostId(null);
        setEditingPostContent('');
    };

    // handle submitting an updated post
    const handleUpdatePost = async (e) => {
        e.preventDefault();
        if (!editingPostContent.trim() || !editingPostId) return;

        const postRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'forums', selectedForum.id, 'threads', selectedThread.id, 'posts', editingPostId);
        await updateDoc(postRef, {
            content: editingPostContent,
            editedAt: serverTimestamp(),
        });

        handleCancelEdit();
    };

    const handleUpdateForum = async (e, forumId) => {
        e.preventDefault();
        if (!editingForum || !editingForum.name.trim() || !isLeader) return;
        const forumRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'forums', forumId);
        await updateDoc(forumRef, {
            name: editingForum.name,
            isSecret: editingForum.isSecret,
        });
        setEditingForum(null);
    };

    const handleDeleteForum = (forumId) => {
        setConfirmAction({
            message: "Are you sure you want to delete this forum and all its threads? This cannot be undone.",
            onConfirm: async () => {
                if (!isLeader) return;

                const forumRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'forums', forumId);
                const threadsRef = collection(forumRef, 'threads');
                const threadsSnapshot = await getDocs(threadsRef);

                const batch = writeBatch(db);

                for (const threadDoc of threadsSnapshot.docs) {
                    const postsRef = collection(threadDoc.ref, 'posts');
                    const postsSnapshot = await getDocs(postsRef);
                    postsSnapshot.forEach(postDoc => {
                        batch.delete(postDoc.ref);
                    });
                    batch.delete(threadDoc.ref);
                }

                batch.delete(forumRef);

                await batch.commit();

                if (selectedForum?.id === forumId) {
                    setSelectedForum(null);
                    setThreads([]);
                    setSelectedThread(null);
                }
                setConfirmAction(null);
            }
        });
    };

    const handleContentClick = (e) => {
        const target = e.target;
        if (target.classList.contains('bbcode-action') && onActionClick) {
            const { actionType, actionId, actionOwnerId, actionCoordsX, actionCoordsY } = target.dataset;
            if (actionType === 'city_link') {
                onActionClick(actionType, { cityId: actionId, ownerId: actionOwnerId, coords: { x: actionCoordsX, y: actionCoordsY } });
            } else {
                const data = actionId || { x: actionCoordsX, y: actionCoordsY };
                if (actionType && data) {
                    onActionClick(actionType, data);
                }
            }
            onClose();
        }
    };

    const visibleForums = useMemo(() => {
        return forums.filter(forum => !forum.isSecret || canViewSecretForums);
    }, [forums, canViewSecretForums]);

    const renderContent = () => {
        if (isCreatingThread) {
            return (
                 <div className="p-4">
                    <h3 className="forum-header -m-4 mb-4 p-2">Create New Thread in {selectedForum?.name}</h3>
                    <form onSubmit={handleCreateThread} className="space-y-3">
                        <input type="text" value={newThreadTitle} onChange={(e) => setNewThreadTitle(e.target.value)} placeholder="Thread Title" className="w-full bg-yellow-50/50 p-2 rounded border border-yellow-800/50 text-gray-800" />
                        <TextEditor value={newPostContent} onChange={setNewPostContent} />
                        <div className="flex justify-end gap-2">
                            <button type="button" onClick={() => setIsCreatingThread(false)} className="forum-btn">Cancel</button>
                            <button type="submit" className="forum-btn">Create</button>
                        </div>
                    </form>
                </div>
            );
        }

        if (selectedThread) {
            return (
                 <div className="flex flex-col h-full">
                    <div className="forum-header -m-6 mb-4 p-2 flex items-center">
                        <button onClick={() => setSelectedThread(null)} className="text-yellow-300 hover:text-white mr-4 text-sm">{'< Back'}</button>
                        <span className="font-bold">{selectedThread.title}</span>
                    </div>
                    <div ref={postContainerRef} className="space-y-4 mb-4 flex-grow overflow-y-auto p-2" onClick={handleContentClick}>
                        {posts.map(post => (
                            <div key={post.id} className="post-item">
                                <p className="post-author" dangerouslySetInnerHTML={{ __html: parseBBCode(`[player id=${post.authorId}]${post.authorUsername}[/player]`) }} />
                                {editingPostId === post.id ? (
                                    <form onSubmit={handleUpdatePost}>
                                        <TextEditor value={editingPostContent} onChange={setEditingPostContent} />
                                        <div className="flex justify-end gap-2 mt-2">
                                            <button type="button" onClick={handleCancelEdit} className="forum-btn">Cancel</button>
                                            <button type="submit" className="forum-btn">Save</button>
                                        </div>
                                    </form>
                                ) : (
                                    <>
                                        <div className="post-content" dangerouslySetInnerHTML={{ __html: parseBBCode(post.content) }} />
                                        <div className="flex justify-between items-center">
                                            <p className="post-timestamp">
                                                {post.createdAt?.toDate().toLocaleString()}
                                                {post.editedAt && <em className="ml-2">(edited)</em>}
                                            </p>
                                            {currentUser.uid === post.authorId && (
                                                <div className="post-actions">
                                                    <button onClick={() => handleStartEdit(post)} className="post-action-btn">Edit</button>
                                                    <button onClick={() => handleDeletePost(post.id)} className="post-action-btn">Delete</button>
                                                </div>
                                            )}
                                        </div>
                                    </>
                                )}
                            </div>
                        ))}
                        <div ref={postsEndRef} />
                    </div>
                    <form onSubmit={handleReply} className="mt-auto flex-shrink-0 p-2 reply-form">
                        <TextEditor value={newPostContent} onChange={setNewPostContent} />
                        <div className="flex justify-end mt-2">
                            <button type="submit" className="forum-btn">Post Reply</button>
                        </div>
                    </form>
                </div>
            );
        }

        return (
            <div>
                <table className="forum-table">
                    <thead>
                        <tr>
                            <th className="w-2/3">Theme</th>
                            <th className="text-center">Replies</th>
                            <th>Last Post</th>
                        </tr>
                    </thead>
                    <tbody>
                        {threads.map(thread => (
                            <tr key={thread.id} onClick={() => setSelectedThread(thread)}>
                                <td>
                                    <p className="font-bold">{thread.title}</p>
                                    <p className="text-xs" dangerouslySetInnerHTML={{ __html: `by ${parseBBCode(`[player id=${thread.creatorId}]${thread.creatorUsername}[/player]`)} on ${thread.createdAt?.toDate().toLocaleDateString()}` }} />
                                </td>
                                <td className="text-center">{thread.replyCount || 0}</td>
                                <td>
                                    <p className="font-bold text-sm" dangerouslySetInnerHTML={{ __html: thread.lastReplyById ? parseBBCode(`[player id=${thread.lastReplyById}]${thread.lastReplyBy}[/player]`) : thread.lastReplyBy }} />
                                    <p className="text-xs">{thread.lastReplyAt?.toDate().toLocaleString()}</p>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
                <div className="mt-4 flex justify-start gap-4">
                    {forums.length > 0 && (
                        <button onClick={() => setIsCreatingThread(true)} className="forum-btn">New Thread</button>
                    )}
                </div>
            </div>
        );
    };

    if (!playerAlliance) {
        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
                <div className="forum-container w-full max-w-lg h-auto flex flex-col items-center justify-center p-8" onClick={e => e.stopPropagation()}>
                    <p className="text-2xl text-center">You must be in an alliance to view the forum.</p>
                    <button onClick={onClose} className="forum-btn mt-6">Close</button>
                </div>
            </div>
        );
    }

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            {confirmAction && (
                <ConfirmationModal
                    message={confirmAction.message}
                    onConfirm={confirmAction.onConfirm}
                    onCancel={() => setConfirmAction(null)}
                />
            )}
            <div 
                ref={forumRef}
                className="forum-container w-full max-w-5xl h-5/6 flex flex-col"
                onClick={e => e.stopPropagation()}
                onMouseDown={handleMouseDown}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="p-4 flex justify-between items-center alliance-forum-header">
                    <h2 className="font-title text-3xl">Alliance Forum</h2>
                    <button onClick={onClose} className="text-3xl leading-none hover:text-red-700">&times;</button>
                </div>
                <div className="forum-tabs-container">
                    {visibleForums.map(forum => (
                        <div key={forum.id} className="relative group">
                            {editingForum?.id === forum.id ? (
                                <form onSubmit={(e) => handleUpdateForum(e, forum.id)} className="p-1 flex items-center">
                                    <input
                                        type="text"
                                        value={editingForum.name}
                                        onChange={(e) => setEditingForum(prev => ({ ...prev, name: e.target.value }))}
                                        className="bg-white/20 text-white p-1 rounded text-sm"
                                        autoFocus
                                    />
                                    <label className="flex items-center ml-2 text-sm text-white">
                                        <input
                                            type="checkbox"
                                            checked={editingForum.isSecret}
                                            onChange={(e) => setEditingForum(prev => ({ ...prev, isSecret: e.target.checked }))}
                                            className="mr-1"
                                        />
                                        Secret
                                    </label>
                                    <button type="submit" className="ml-2 text-white text-xl">✓</button>
                                    <button type="button" onClick={() => setEditingForum(null)} className="ml-1 text-white text-xl">x</button>
                                </form>
                            ) : (
                                <>
                                    <button onClick={() => setSelectedForum(forum)} className={`forum-tab ${selectedForum?.id === forum.id ? 'active' : ''}`}>
                                        {forum.name} {forum.isSecret && '🔒'}
                                    </button>
                                    {isLeader && (
                                        <div className="absolute top-0 right-0 flex opacity-0 group-hover:opacity-100 transition-opacity">
                                            <button onClick={() => setEditingForum({ id: forum.id, name: forum.name, isSecret: forum.isSecret || false })} className="text-white text-xs p-1">✏️</button>
                                            <button onClick={() => handleDeleteForum(forum.id)} className="text-white text-xs p-1">🗑️</button>
                                        </div>
                                    )}
                                </>
                            )}
                        </div>
                    ))}
                    {isLeader && (
                        isCreatingForum ? (
                            <form onSubmit={handleCreateForum} className="p-1 flex items-center">
                                <input type="text" value={newForumName} onChange={(e) => setNewForumName(e.target.value)} placeholder="New Forum Name" className="bg-white/20 text-white p-1 rounded text-sm" />
                                <label className="flex items-center ml-2 text-sm text-white">
                                    <input type="checkbox" checked={isNewForumSecret} onChange={(e) => setIsNewForumSecret(e.target.checked)} className="mr-1" />
                                    Secret
                                </label>
                                <button type="submit" className="ml-2 text-white text-xl">+</button>
                                <button type="button" onClick={() => setIsCreatingForum(false)} className="ml-1 text-white text-xl">x</button>
                            </form>
                        ) : (
                            <button onClick={() => setIsCreatingForum(true)} className="forum-tab new-forum-btn">+</button>
                        )
                    )}
                </div>
                <div className="overflow-y-auto flex-grow p-4">
                    {renderContent()}
                </div>
            </div>
        </div>
    );
};

export default AllianceForum;
</file>

<file path="src/components/alliance/AllianceInvitations.js">
// src/components/alliance/AllianceInvitations.js
import React, { useState, useEffect } from 'react';
import { collection, query, where, onSnapshot, getDocs, doc } from 'firebase/firestore';
import { db } from '../../firebase/config';
import { useGame } from '../../contexts/GameContext';
import { useAlliance } from '../../contexts/AllianceContext';
import { useAuth } from '../../contexts/AuthContext';

// #comment Cache for player list to reduce reads.
export let playerCache = {
    allPlayers: null,
    timestamp: 0,
};

export const clearPlayerCache = () => {
    playerCache.allPlayers = null;
    playerCache.timestamp = 0;
};

const AllianceInvitations = ({ isLeader }) => {
    const { worldId } = useGame();
    const { playerAlliance, sendAllianceInvitation, revokeAllianceInvitation, handleApplication } = useAlliance();
    const { userProfile } = useAuth();
    const [invitedPlayerName, setInvitedPlayerName] = useState('');
    const [pendingInvites, setPendingInvites] = useState([]);
    const [applications, setApplications] = useState([]);
    const [message, setMessage] = useState('');

    // #comment Autocomplete states
    const [allPlayers, setAllPlayers] = useState([]);
    const [suggestions, setSuggestions] = useState([]);

    // #comment Fetch all players for autocomplete
    useEffect(() => {
        const fetchPlayers = async () => {
            const now = Date.now();
            const CACHE_DURATION = 10 * 60 * 1000; // 10 minutes

            if (now - playerCache.timestamp < CACHE_DURATION && playerCache.allPlayers) {
                setAllPlayers(playerCache.allPlayers);
            } else {
                const usersRef = collection(db, 'users');
                const snapshot = await getDocs(usersRef);
                const players = snapshot.docs
                    .map(doc => doc.data().username)
                    .filter(username => username !== userProfile.username); // Exclude self
                setAllPlayers(players);
                playerCache.allPlayers = players;
                playerCache.timestamp = now;
            }
        };
        fetchPlayers();
    }, [userProfile.username]);

    useEffect(() => {
        if (!worldId || !playerAlliance?.id) return;
        const invitesRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'invitations');
        const unsubscribeInvites = onSnapshot(invitesRef, (snapshot) => {
            const invitesData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setPendingInvites(invitesData);
        });
        
        // Listener for the alliance document to get applications
        const allianceRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const unsubscribeApplications = onSnapshot(allianceRef, (docSnap) => {
            if (docSnap.exists()) {
                setApplications(docSnap.data().applications || []);
            }
        });

        return () => {
            unsubscribeInvites();
            unsubscribeApplications();
        };
    }, [worldId, playerAlliance]);

    const handleInvite = async () => {
        if (!invitedPlayerName.trim()) {
            setMessage('Please enter a player name.');
            return;
        }
        setMessage(''); // Clear previous messages

        try {
            const usersQuery = query(collection(db, 'users'), where('username', '==', invitedPlayerName.trim()));
            const userSnapshot = await getDocs(usersQuery);

            if (userSnapshot.empty) {
                setMessage('Player not found.');
                return;
            }
            
            const invitedUserId = userSnapshot.docs[0].id;
            const existingInvite = pendingInvites.find(invite => invite.invitedUserId === invitedUserId);
            if (existingInvite) {
                setMessage('An invitation has already been sent to this player.');
                return;
            }

            await sendAllianceInvitation(invitedUserId);
            setMessage(`Invitation sent to ${invitedPlayerName}!`);
            setInvitedPlayerName('');
        } catch (e) {
            setMessage(e.message); // Display specific error from context
            console.error(e);
        }
    };

    const handleRevoke = async (invitedUserId) => {
        await revokeAllianceInvitation(invitedUserId);
        setMessage('Invitation revoked.');
    };

    const onApplicationAction = async (application, action) => {
        try {
            await handleApplication(application, playerAlliance.id, action);
            setMessage(`Application ${action}ed.`);
        } catch (error) {
            setMessage(`Error: ${error.message}`);
        }
    };
    
    // #comment Handle input change for autocomplete
    const handleInviteInputChange = (e) => {
        const value = e.target.value;
        setInvitedPlayerName(value);
        if (value.length > 0) {
            const filteredSuggestions = allPlayers.filter(player =>
                player.toLowerCase().startsWith(value.toLowerCase())
            );
            setSuggestions(filteredSuggestions);
        } else {
            setSuggestions([]);
        }
    };

    // #comment Handle clicking a suggestion
    const handleSuggestionClick = (username) => {
        setInvitedPlayerName(username);
        setSuggestions([]);
    };

    const canInvite = isLeader;

    return (
       <div className="p-4 alliance-bg-light alliance-text-light rounded-lg">
            <h3 className="text-xl font-bold mb-4">Invitations & Applications</h3>
            {!canInvite && <p className="text-red-400 mb-4">You do not have permission to manage invitations.</p>}
            {canInvite && (
                <div className="mb-6 space-y-2 autocomplete-suggestions-container">
                    <p className="font-semibold">Invite a Player</p>
                    <div className="flex gap-2">
                        <input
                            type="text"
                            value={invitedPlayerName}
                            onChange={handleInviteInputChange}
                            placeholder="Player Username"
                            className="w-full bg-gray-900 p-2 rounded text-white"
                            autoComplete="off"
                        />
                        <button onClick={handleInvite} className="btn btn-confirm flex-shrink-0">Invite</button>
                    </div>
                     {suggestions.length > 0 && (
                        <ul className="autocomplete-suggestions-list dark">
                            {suggestions.map(player => (
                                <li key={player} onClick={() => handleSuggestionClick(player)}>
                                    {player}
                                </li>
                            ))}
                        </ul>
                    )}
                </div>
            )}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <p className="font-semibold mb-2">Pending Invitations</p>
                    {pendingInvites.length > 0 ? (
                        <ul className="space-y-2">
                            {pendingInvites.map(invite => (
                                <li key={invite.id} className="flex justify-between items-center bg-gray-700 p-2 rounded">
                                    <span>{invite.invitedUsername}</span>
                                    {canInvite && (
                                        <button onClick={() => handleRevoke(invite.invitedUserId)} className="btn btn-danger text-sm px-2 py-1">Revoke</button>
                                    )}
                                </li>
                            ))}
                        </ul>
                    ) : (
                        <p className="text-gray-400 text-sm italic">No invitations have been sent.</p>
                    )}
                </div>
                <div>
                    <p className="font-semibold mb-2">Applications</p>
                    {applications.length > 0 ? (
                        <ul className="space-y-2">
                            {applications.map(app => (
                                <li key={app.userId} className="flex justify-between items-center bg-gray-700 p-2 rounded">
                                    <span>{app.username}</span>
                                    {canInvite && (
                                        <div className="flex gap-1">
                                            <button onClick={() => onApplicationAction(app, 'accept')} className="btn btn-confirm text-xs px-2 py-1">Accept</button>
                                            <button onClick={() => onApplicationAction(app, 'reject')} className="btn btn-danger text-xs px-2 py-1">Reject</button>
                                        </div>
                                    )}
                                </li>
                            ))}
                        </ul>
                    ) : (
                        <p className="text-gray-400 text-sm italic">No pending applications.</p>
                    )}
                </div>
            </div>
            {message && <p className="text-green-400 mt-2 text-sm">{message}</p>}
        </div>
    );
};

export default AllianceInvitations;
</file>

<file path="src/components/alliance/AllianceMembers.js">
// src/components/alliance/AllianceMembers.js
import React, { useState, useEffect, useMemo, useRef } from 'react';
import { useAlliance } from '../../contexts/AllianceContext';
import { useGame } from '../../contexts/GameContext';
import { db } from '../../firebase/config';
import { collection, query, where, getDocs, collectionGroup } from 'firebase/firestore';
import allianceResearch from '../../gameData/allianceResearch.json';
import { useAuth } from '../../contexts/AuthContext';

// #comment Cache for detailed alliance member data (points, activity, etc.).
const memberCache = {};

// #comment Function to clear the member cache, exported for admin use.
export const clearMemberCache = () => {
    for (const key in memberCache) {
        delete memberCache[key];
    }
};

const ConfirmationModal = ({ message, onConfirm, onCancel }) => (
    <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black bg-opacity-70">
        <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-center border border-gray-600 text-white">
            <p className="mb-6 text-lg">{message}</p>
            <div className="flex justify-center space-x-4">
                <button onClick={onCancel} className="btn btn-primary">Cancel</button>
                <button onClick={onConfirm} className="btn btn-danger">Confirm</button>
            </div>
        </div>
    </div>
);

const AllianceMembers = () => {
    const { playerAlliance, kickAllianceMember, banAllianceMember, updateAllianceMemberRank } = useAlliance();
    const { worldId, worldState } = useGame();
    const { currentUser } = useAuth();

    const [detailedInfo, setDetailedInfo] = useState({});
    const [loading, setLoading] = useState(true);
    const [sortConfig, setSortConfig] = useState({ key: 'username', direction: 'ascending' });
    const [confirmAction, setConfirmAction] = useState(null);
    const [message, setMessage] = useState('');
    const [editingMemberId, setEditingMemberId] = useState(null);
    const [openManageMenu, setOpenManageMenu] = useState(null);
    const manageMenuRef = useRef(null);

    const memberRankData = useMemo(() => {
        if (!playerAlliance || !currentUser) return null;
        const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
        if (!member) return null;
        return playerAlliance.ranks.find(r => r.id === member.rank);
    }, [playerAlliance, currentUser]);

    const canKickMembers = memberRankData?.permissions?.kickMembers;
    const canBanMembers = memberRankData?.permissions?.banMembers;
    const canViewActivity = memberRankData?.permissions?.viewMemberActivity;
    const canManageRanks = memberRankData?.permissions?.manageRanks;

    useEffect(() => {
        const handleClickOutside = (event) => {
            if (manageMenuRef.current && !manageMenuRef.current.contains(event.target)) {
                setOpenManageMenu(null);
            }
        };
        document.addEventListener("mousedown", handleClickOutside);
        return () => {
            document.removeEventListener("mousedown", handleClickOutside);
        };
    }, []);

    const maxMembers = useMemo(() => {
        if (!playerAlliance) return 0;
        const baseMax = 20;
        const researchLevel = playerAlliance.research?.expanded_charter?.level || 0;
        const researchBonus = allianceResearch.expanded_charter.effect.value * researchLevel;
        return baseMax + researchBonus;
    }, [playerAlliance]);

    useEffect(() => {
        const fetchMemberDetails = async () => {
            if (!playerAlliance || playerAlliance.members.length === 0 || !worldState) {
                setLoading(false);
                return;
            }
            setLoading(true);

            const memberIds = playerAlliance.members.map(m => m.uid);
            const usersData = new Map();
            const gameDataMap = new Map();

            const gamesGroupRef = collectionGroup(db, 'games');
            const qGames = query(gamesGroupRef, where('worldName', '==', worldState.name));
            const gamesSnapshot = await getDocs(qGames);
            gamesSnapshot.forEach(gameDoc => {
                const userId = gameDoc.ref.parent.parent.id;
                if (memberIds.includes(userId)) {
                    gameDataMap.set(userId, gameDoc.data());
                }
            });

            if (canViewActivity && memberIds.length > 0) {
                const usersRef = collection(db, 'users');
                const qUsers = query(usersRef, where('__name__', 'in', memberIds));
                const userDocsSnap = await getDocs(qUsers);
                userDocsSnap.forEach(doc => {
                    usersData.set(doc.id, doc.data());
                });
            }

            const memberDetailsPromises = playerAlliance.members.map(async (member) => {
                const gameData = gameDataMap.get(member.uid) || { totalPoints: 0, cityCount: 0, lastSeen: null };
                const userData = usersData.get(member.uid) || {};

                return {
                    uid: member.uid, // Ensure uid is present for mapping
                    points: gameData.totalPoints || 0,
                    cityCount: gameData.cityCount || 0,
                    lastSeen: gameData.lastSeen?.toDate() || null,
                    lastLogin: userData.lastLogin?.toDate() || null,
                };
            });

            const details = await Promise.all(memberDetailsPromises);
            const detailsMap = new Map(details.map(d => [d.uid, d]));
            
            setDetailedInfo(Object.fromEntries(detailsMap));
            memberCache[playerAlliance.id] = {
                data: Object.fromEntries(detailsMap),
                timestamp: Date.now(),
            };
            setLoading(false);
        };

        const now = Date.now();
        const twoMinutes = 2 * 60 * 1000;
        const allianceId = playerAlliance?.id;

        if (allianceId && memberCache[allianceId] && (now - memberCache[allianceId].timestamp < twoMinutes)) {
            setDetailedInfo(memberCache[allianceId].data);
            setLoading(false);
        } else if (allianceId) {
            fetchMemberDetails();
        } else {
            setLoading(false);
        }
    }, [playerAlliance, worldId, canViewActivity, worldState]);

    const detailedMembers = useMemo(() => {
        if (!playerAlliance) return [];
        return playerAlliance.members.map(member => ({
            ...member,
            ...(detailedInfo[member.uid] || { points: 0, cityCount: 0, lastSeen: null, lastLogin: null })
        }));
    }, [playerAlliance, detailedInfo]);

    const sortedMembers = useMemo(() => {
        let sortableItems = [...detailedMembers];
        if (sortConfig.key !== null) {
            sortableItems.sort((a, b) => {
                let aValue = a[sortConfig.key];
                let bValue = b[sortConfig.key];

                if (sortConfig.key === 'rank') {
                    aValue = playerAlliance.ranks.findIndex(r => r.id === a.rank);
                    bValue = playerAlliance.ranks.findIndex(r => r.id === b.rank);
                }
                
                if (sortConfig.key === 'status') {
                    const aIsOnline = a.lastSeen && (new Date() - a.lastSeen) < 5 * 60 * 1000;
                    const bIsOnline = b.lastSeen && (new Date() - b.lastSeen) < 5 * 60 * 1000;
                    if (aIsOnline && !bIsOnline) return -1;
                    if (!aIsOnline && bIsOnline) return 1;
                    aValue = b.lastSeen || b.lastLogin || 0;
                    bValue = a.lastSeen || a.lastLogin || 0;
                }

                if (aValue < bValue) {
                    return sortConfig.direction === 'ascending' ? -1 : 1;
                }
                if (aValue > bValue) {
                    return sortConfig.direction === 'ascending' ? 1 : -1;
                }
                return 0;
            });
        }
        return sortableItems;
    }, [detailedMembers, sortConfig, playerAlliance.ranks]);

    const requestSort = (key) => {
        let direction = 'ascending';
        if (sortConfig.key === key && sortConfig.direction === 'ascending') {
            direction = 'descending';
        }
        setSortConfig({ key, direction });
    };

    const getSortIndicator = (key) => {
        if (sortConfig.key === key) {
            return sortConfig.direction === 'ascending' ? ' ▲' : ' ▼';
        }
        return '';
    };

    const formatLastSeen = (lastSeen, lastLogin) => {
        const now = new Date();

        if (lastSeen && (now - lastSeen) < 5 * 60 * 1000) {
            return <span className="text-green-500 font-bold">Online</span>;
        }

        const date = lastSeen || lastLogin;

        if (!date || !(date instanceof Date)) {
            return <span className="text-gray-500">Offline</span>;
        }

        const diffSeconds = Math.round((now - date) / 1000);
        const diffMinutes = Math.round(diffSeconds / 60);
        const diffHours = Math.round(diffMinutes / 60);
        const diffDays = Math.round(diffHours / 24);

        if (diffMinutes < 60) return `${diffMinutes}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays === 1) return 'Yesterday';
        if (diffDays < 7) return `${diffDays}d ago`;
        return date.toLocaleDateString();
    };

    const handleKick = (member) => {
        setOpenManageMenu(null);
        setConfirmAction({
            message: `Are you sure you want to kick ${member.username} from the alliance?`,
            onConfirm: async () => {
                try {
                    await kickAllianceMember(member.uid);
                    setMessage(`${member.username} has been kicked.`);
                } catch (error) {
                    setMessage(`Error: ${error.message}`);
                } finally {
                    setConfirmAction(null);
                }
            }
        });
    };

    const handleBan = (member) => {
        setOpenManageMenu(null);
        setConfirmAction({
            message: `Are you sure you want to ban ${member.username}? This will kick them and prevent them from rejoining.`,
            onConfirm: async () => {
                try {
                    await banAllianceMember(member.uid);
                    setMessage(`${member.username} has been banned.`);
                } catch (error) {
                    setMessage(`Error: ${error.message}`);
                } finally {
                    setConfirmAction(null);
                }
            }
        });
    };

    const handleUpdateMemberRank = async (memberId, newRankId) => {
        try {
            await updateAllianceMemberRank(memberId, newRankId);
            setMessage('Member rank updated successfully!');
            setTimeout(() => setMessage(''), 3000);
        } catch (error) {
            setMessage('Failed to update rank. Please try again.');
            console.error('Error updating member rank:', error);
        }
    };

    if (loading) {
        return <div>Loading member data...</div>;
    }

    return (
        <div>
            {confirmAction && (
                <ConfirmationModal
                    message={confirmAction.message}
                    onConfirm={confirmAction.onConfirm}
                    onCancel={() => setConfirmAction(null)}
                />
            )}
            <h3 className="text-xl font-bold mb-2">Members ({playerAlliance.members.length} / {maxMembers})</h3>
            {message && <p className="text-center text-yellow-400 mb-2">{message}</p>}
            <table className="w-full text-left">
                <thead>
                    <tr className="bg-gray-300 text-gray-900">
                        <th className="p-2 cursor-pointer" onClick={() => requestSort('username')}>
                            Player{getSortIndicator('username')}
                        </th>
                        <th className="p-2 cursor-pointer" onClick={() => requestSort('rank')}>
                            Rank{getSortIndicator('rank')}
                        </th>
                        <th className="p-2 cursor-pointer text-right" onClick={() => requestSort('points')}>
                            Points{getSortIndicator('points')}
                        </th>
                        <th className="p-2 cursor-pointer text-right" onClick={() => requestSort('cityCount')}>
                            Cities{getSortIndicator('cityCount')}
                        </th>
                        {canViewActivity && (
                            <th className="p-2 cursor-pointer text-right" onClick={() => requestSort('status')}>
                                Status{getSortIndicator('status')}
                            </th>
                        )}
                        {(canKickMembers || canBanMembers) && <th className="p-2 text-right">Actions</th>}
                    </tr>
                </thead>
                <tbody>
                    {sortedMembers.map(member => (
                        <tr key={member.uid} className="border-b border-gray-300 text-gray-900">
                            <td className="p-2">{member.username}</td>
                            <td className="p-2">
                                {canManageRanks && member.uid !== playerAlliance.leader.uid ? (
                                    editingMemberId === member.uid ? (
                                        <select
                                            value={member.rank}
                                            onChange={(e) => {
                                                handleUpdateMemberRank(member.uid, e.target.value);
                                                setEditingMemberId(null);
                                            }}
                                            onBlur={() => setEditingMemberId(null)}
                                            autoFocus
                                            className="bg-white text-gray-900 p-1 rounded text-sm border border-amber-300"
                                        >
                                            {playerAlliance.ranks.map(rank => (
                                                <option key={rank.id} value={rank.id}>{rank.name}</option>
                                            ))}
                                        </select>
                                    ) : (
                                        <button
                                            onClick={() => setEditingMemberId(member.uid)}
                                            className="text-sm text-amber-800 hover:underline cursor-pointer bg-transparent border-none p-0"
                                        >
                                            {member.rank}
                                        </button>
                                    )
                                ) : (
                                    member.rank
                                )}
                            </td>
                            <td className="p-2 text-right">{member.points.toLocaleString()}</td>
                            <td className="p-2 text-right">{member.cityCount}</td>
                            {canViewActivity && (
                                <td className="p-2 text-right">{formatLastSeen(member.lastSeen, member.lastLogin)}</td>
                            )}
                            {(canKickMembers || canBanMembers) && (
                                <td className="p-2 text-right relative">
                                    {member.uid !== currentUser.uid && member.uid !== playerAlliance.leader.uid && (
                                        <button onClick={() => setOpenManageMenu(openManageMenu === member.uid ? null : member.uid)} className="btn btn-primary text-xs px-2 py-1">
                                            Manage
                                        </button>
                                    )}
                                    {openManageMenu === member.uid && (
                                        <div ref={manageMenuRef} className="absolute right-0 mt-2 w-32 bg-white rounded-md shadow-lg z-10 border border-gray-200">
                                            {canKickMembers && <button onClick={() => handleKick(member)} className="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Kick</button>}
                                            {canBanMembers && <button onClick={() => handleBan(member)} className="block w-full text-left px-4 py-2 text-sm text-red-700 hover:bg-red-50">Ban</button>}
                                        </div>
                                    )}
                                </td>
                            )}
                        </tr>
                    ))}
                </tbody>
            </table>
        </div>
    );
};

export default AllianceMembers;
</file>

<file path="src/components/alliance/AllianceOverview.js">
import React, { useState, useEffect } from 'react';
import { useGame } from '../../contexts/GameContext';
import { useAlliance } from '../../contexts/AllianceContext';
import { collection, query, orderBy, onSnapshot } from 'firebase/firestore';
import { db } from '../../firebase/config';

const AllianceOverview = () => {
    const { worldId } = useGame();
    const { playerAlliance } = useAlliance();
    const [events, setEvents] = useState([]);

    // #comment Fetch alliance events in real-time
    useEffect(() => {
        if (!worldId || !playerAlliance) return;
        const eventsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'events');
        const q = query(eventsRef, orderBy('timestamp', 'desc'));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            setEvents(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
        });

        return () => unsubscribe();
    }, [worldId, playerAlliance]);

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="space-y-6">
                 <div className="alliance-bg-light alliance-text-light p-4 rounded-lg">
                    <h3 className="text-xl font-bold mb-2">Internal Bulletin (Private)</h3>
                    <p className="whitespace-pre-wrap">{playerAlliance.settings.privateDescription || 'No private description provided.'}</p>
                </div>
            </div>
            <div>
                <h3 className="text-xl font-bold mb-2">Recent Events</h3>
                <ul className="space-y-2 max-h-64 overflow-y-auto bg-gray-700/50 p-3 rounded-lg">
                    {events.length > 0 ? events.map(event => (
                        <li key={event.id} className="p-2 bg-gray-800/60 rounded">
                            <p className="text-sm">{event.text}</p>
                            <p className="text-xs text-gray-400 text-right">{event.timestamp?.toDate().toLocaleString()}</p>
                        </li>
                    )) : (
                        <li className="text-gray-500 italic text-center p-4">No recent events.</li>
                    )}
                </ul>
            </div>
        </div>
    );
};

export default AllianceOverview;
</file>

<file path="src/components/alliance/AllianceProperties.js">
import React, { useState } from 'react';
import { useAlliance } from '../../contexts/AllianceContext';
import { useAuth } from '../../contexts/AuthContext';

const ConfirmationModal = ({ message, onConfirm, onCancel }) => (
    <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black bg-opacity-70">
        <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-center border border-gray-600 text-white">
            <p className="mb-6 text-lg">{message}</p>
            <div className="flex justify-center space-x-4">
                <button onClick={onCancel} className="btn btn-primary">Cancel</button>
                <button onClick={onConfirm} className="btn btn-danger">Confirm</button>
            </div>
        </div>
    </div>
);

const AllianceProperties = ({ onClose }) => {
    const { playerAlliance, leaveAlliance, disbandAlliance } = useAlliance();
    const { currentUser } = useAuth();
    const [confirmAction, setConfirmAction] = useState(null);

    const isLeader = currentUser?.uid === playerAlliance?.leader?.uid;
    const isLastMember = playerAlliance?.members?.length === 1;

    const handleLeave = () => {
        setConfirmAction({
            message: "Are you sure you want to leave this alliance?",
            action: async () => {
                try {
                    await leaveAlliance();
                    onClose();
                } catch (error) {
                    console.error(error);
                } finally {
                    setConfirmAction(null);
                }
            }
        });
    };
    
    const handleDisband = () => {
        setConfirmAction({
            message: "Are you sure you want to disband the alliance? This action is permanent and cannot be undone.",
            action: async () => {
                try {
                    await disbandAlliance();
                    onClose();
                } catch (error) {
                    console.error(error);
                } finally {
                    setConfirmAction(null);
                }
            }
        });
    };

    return (
        <div className="p-4 alliance-bg-light alliance-text-light rounded-lg">
            {confirmAction && (
                <ConfirmationModal 
                    message={confirmAction.message}
                    onConfirm={confirmAction.action}
                    onCancel={() => setConfirmAction(null)}
                />
            )}
            <h3 className="text-xl font-bold mb-4">Alliance Properties</h3>
            <div className="space-y-4">
                <div>
                    <h4 className="font-semibold text-lg mb-2">Leave Alliance</h4>
                    <p className="text-sm text-gray-400 mb-2">
                        {isLeader && !isLastMember 
                            ? "As the leader, you must pass leadership to another member before you can leave."
                            : "If you leave, you will need to be invited or apply to join another alliance."
                        }
                    </p>
                    <button 
                        onClick={handleLeave} 
                        className="btn btn-danger"
                        disabled={isLeader && !isLastMember}
                    >
                        {isLeader && isLastMember ? 'Leave and Disband' : 'Leave Alliance'}
                    </button>
                </div>
                {isLeader && (
                    <div className="border-t border-gray-600 pt-4">
                        <h4 className="font-semibold text-lg mb-2 text-red-400">Disband Alliance</h4>
                        <p className="text-sm text-gray-400 mb-2">
                            This will permanently delete the alliance for all members. This action cannot be undone.
                        </p>
                        <button onClick={handleDisband} className="btn btn-danger">Disband Alliance</button>
                    </div>
                )}
            </div>
        </div>
    );
};

export default AllianceProperties;
</file>

<file path="src/components/alliance/AllianceRanks.js">
// src/components/alliance/AllianceRanks.js
import React, { useState, useMemo } from 'react';
import { useAlliance } from '../../contexts/AllianceContext';
import { db } from '../../firebase/config';
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { collection, addDoc, serverTimestamp } from 'firebase/firestore';

const AllianceRanks = ({ alliance, isLeader }) => {
    const { createAllianceRank, updateAllianceMemberRank, updateRanksOrder, updateAllianceRank, deleteAllianceRank } = useAlliance();
    const { userProfile } = useAuth();
    const { worldId } = useGame();
    const [newRankName, setNewRankName] = useState('');
    const [newRankPermissions, setNewRankPermissions] = useState({
        manageRanks: false, manageSettings: false, manageDiplomacy: false, inviteMembers: false, kickMembers: false, recommendResearch: false, viewSecretForums: false, manageBank: false, withdrawFromBank: false, proposeTreaties: false, viewMemberActivity: false
    });
    const [message, setMessage] = useState('');
    const [editingMemberId, setEditingMemberId] = useState(null);
    const [editingRank, setEditingRank] = useState(null);

    const allPermissions = Object.keys(newRankPermissions);
    
    const handleCreateRank = () => {
        if (!isLeader) return;
        setMessage('');
        if (newRankName.trim() === '') {
            setMessage('Rank name cannot be empty.');
            return;
        }
        if (alliance.ranks.some(r => r.name.toLowerCase() === newRankName.trim().toLowerCase())) {
            setMessage('A rank with this name already exists.');
            return;
        }
        if (alliance.ranks.length >= 10) {
            setMessage('Maximum of 10 ranks reached.');
            return;
        }

        createAllianceRank({
            id: newRankName.trim(),
            name: newRankName.trim(),
            permissions: newRankPermissions,
        });

        setNewRankName('');
        setNewRankPermissions({
            manageRanks: false, manageSettings: false, manageDiplomacy: false, inviteMembers: false, kickMembers: false, recommendResearch: false, viewSecretForums: false, manageBank: false, withdrawFromBank: false, proposeTreaties: false, viewMemberActivity: false
        });
        setMessage('Rank created!');
    };

    const handleUpdateMemberRank = async (memberId, newRankId) => {
        if (!isLeader) return;
        setMessage('');
        try {
            const memberToUpdate = alliance.members.find(m => m.uid === memberId);
            const oldRankId = memberToUpdate.rank;

            await updateAllianceMemberRank(memberId, newRankId);

            if (oldRankId !== newRankId) {
                const oldRankIndex = alliance.ranks.findIndex(r => r.id === oldRankId);
                const newRankIndex = alliance.ranks.findIndex(r => r.id === newRankId);
                
                if (oldRankIndex !== -1 && newRankIndex !== -1) {
                    const actionText = newRankIndex < oldRankIndex ? 'promoted' : 'demoted';
                    const memberUsername = memberToUpdate.username;
                    const eventText = `${userProfile.username} has ${actionText} ${memberUsername} to ${newRankId}.`;

                    const eventsRef = collection(db, 'worlds', worldId, 'alliances', alliance.id, 'events');
                    await addDoc(eventsRef, {
                        type: 'rank_change',
                        text: eventText,
                        timestamp: serverTimestamp(),
                    });
                }
            }

            setMessage('Member rank updated successfully!');
            setTimeout(() => setMessage(''), 3000);
        } catch (error) {
            setMessage('Failed to update rank. Please try again.');
            console.error('Error updating member rank:', error);
        }
    };
    
    const handleMoveRank = async (index, direction) => {
        if (!isLeader || index === 0) return;

        const newRanks = [...alliance.ranks];
        const rankToMove = newRanks[index];

        if (direction === 'up' && index > 1) {
            newRanks.splice(index, 1);
            newRanks.splice(index - 1, 0, rankToMove);
        } else if (direction === 'down' && index < newRanks.length - 1) {
            newRanks.splice(index, 1);
            newRanks.splice(index + 1, 0, rankToMove);
        } else {
            return;
        }

        try {
            await updateRanksOrder(newRanks); 
            setMessage('Rank order updated.');
            setTimeout(() => setMessage(''), 3000);
        } catch (error) {
            setMessage('Failed to update rank order.');
            console.error(error);
        }
    };

    const handleStartEdit = (rank) => {
        setEditingRank({ ...rank });
    };

    const handleCancelEdit = () => {
        setEditingRank(null);
    };

    const handleSaveEdit = async () => {
        if (!editingRank || !editingRank.name.trim()) {
            setMessage("Rank name cannot be empty.");
            return;
        }
        if (alliance.ranks.some(r => r.name.toLowerCase() === editingRank.name.trim().toLowerCase() && r.id !== editingRank.id)) {
            setMessage('A rank with this name already exists.');
            return;
        }
        try {
            await updateAllianceRank(editingRank.id, { name: editingRank.name, permissions: editingRank.permissions });
            setMessage("Rank updated successfully.");
            setEditingRank(null);
        } catch (error) {
            setMessage(`Error updating rank: ${error.message}`);
        }
    };

    const handleDeleteRank = async (rankId) => {
        setMessage('');
        if (window.confirm(`Are you sure you want to delete the rank "${rankId}"? This cannot be undone.`)) {
            try {
                await deleteAllianceRank(rankId);
                setMessage("Rank deleted successfully.");
            } catch (error) {
                setMessage(`Error deleting rank: ${error.message}`);
            }
        }
    };

    const getPermissionsText = (permissions) => {
        const enabledPermissions = Object.entries(permissions || {})
            .filter(([, value]) => value)
            .map(([key]) => key.replace(/([A-Z])/g, ' $1').toLowerCase());
        
        if (enabledPermissions.length === 0) {
            return 'No special permissions.';
        }
        return `Permissions: ${enabledPermissions.join(', ')}`;
    };

    const sortedMembers = useMemo(() => {
        return [...(alliance.members || [])].sort((a, b) => {
            if (a.rank === 'Leader') return -1;
            if (b.rank === 'Leader') return 1;
            return a.username.localeCompare(b.username);
        });
    }, [alliance.members]);

     return (
        <div className="bg-amber-100 text-gray-900 p-4 rounded-lg shadow-md">
            <h3 className="text-xl font-bold mb-4 border-b border-amber-300 pb-2">Alliance Ranks</h3>
            {!isLeader && <p className="text-red-600 mb-4">Only the leader can manage ranks.</p>}
            
            <div className="space-y-6">
                <div>
                    <h4 className="font-semibold text-lg mb-2 text-gray-900">Current Ranks</h4>
                    <ul className="space-y-2">
                        {alliance.ranks.map((rank, index) => (
                            <li key={rank.id} className="bg-white text-gray-900 p-3 rounded border border-amber-200">
                                {editingRank?.id === rank.id ? (
                                    <div className="w-full">
                                        <input
                                            type="text"
                                            value={editingRank.name}
                                            onChange={(e) => setEditingRank(prev => ({ ...prev, name: e.target.value }))}
                                            className="w-full bg-amber-50 text-gray-900 p-2 rounded border border-amber-300 mb-2"
                                        />
                                        <div className="grid grid-cols-2 gap-2 text-sm mb-2">
                                            {allPermissions.map(perm => (
                                                <div key={perm} className="flex items-center">
                                                    <input
                                                        type="checkbox"
                                                        id={`edit-${perm}`}
                                                        checked={editingRank.permissions[perm]}
                                                        onChange={(e) => setEditingRank(prev => ({ ...prev, permissions: { ...prev.permissions, [perm]: e.target.checked } }))}
                                                        className="mr-2"
                                                    />
                                                    <label htmlFor={`edit-${perm}`} className="capitalize text-gray-900">{perm.replace(/([A-Z])/g, ' $1')}</label>
                                                </div>
                                            ))}
                                        </div>
                                        <div className="flex justify-end gap-2">
                                            <button onClick={handleCancelEdit} className="btn btn-secondary">Cancel</button>
                                            <button onClick={handleSaveEdit} className="btn btn-confirm">Save</button>
                                        </div>
                                    </div>
                                ) : (
                                    <div className="flex justify-between items-center w-full">
                                        <div title={getPermissionsText(rank.permissions)}>
                                            <p className="font-bold">{rank.name}</p>
                                            <p className="text-xs text-amber-800 mt-1">{getPermissionsText(rank.permissions)}</p>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            {isLeader && rank.id !== 'Leader' && (
                                                <>
                                                    <button onClick={() => handleStartEdit(rank)} className="text-xs btn btn-primary px-2 py-1">Edit</button>
                                                    <button onClick={() => handleDeleteRank(rank.id)} className="text-xs btn btn-danger px-2 py-1">Delete</button>
                                                    <div className="flex flex-col">
                                                        <button onClick={() => handleMoveRank(index, 'up')} disabled={index <= 1} className="text-gray-600 hover:text-black disabled:opacity-50">▲</button>
                                                        <button onClick={() => handleMoveRank(index, 'down')} disabled={index === alliance.ranks.length - 1} className="text-gray-600 hover:text-black disabled:opacity-50">▼</button>
                                                    </div>
                                                </>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </li>
                        ))}
                    </ul>
                </div>

                {isLeader && alliance.ranks.length < 10 && (
                    <div className="bg-amber-50 p-4 rounded-lg border border-amber-200">
                        <h4 className="font-semibold text-lg mb-2 text-gray-900">Create New Rank</h4>
                        <div className="space-y-2">
                            <input
                                type="text"
                                value={newRankName}
                                onChange={(e) => setNewRankName(e.target.value)}
                                placeholder="New Rank Name"
                                className="w-full bg-white text-gray-900 p-2 rounded border border-amber-300"
                            />
                            <div className="grid grid-cols-2 gap-2 text-sm">
                                {allPermissions.map(perm => (
                                    <div key={perm} className="flex items-center">
                                        <input
                                            type="checkbox"
                                            id={perm}
                                            checked={newRankPermissions[perm]}
                                            onChange={(e) => setNewRankPermissions(prev => ({ ...prev, [perm]: e.target.checked }))}
                                            className="mr-2"
                                        />
                                        <label htmlFor={perm} className="capitalize text-gray-900">{perm.replace(/([A-Z])/g, ' $1')}</label>
                                    </div>
                                ))}
                            </div>
                            <button onClick={handleCreateRank} className="btn btn-confirm bg-green-600 hover:bg-green-700 text-white w-full">Create Rank</button>
                        </div>
                    </div>
                )}
                
                {message && <p className="text-amber-800 mt-2 text-sm text-center">{message}</p>}

                <div className="mt-6 bg-amber-50 p-4 rounded-lg border border-amber-200">
                    <h4 className="font-semibold text-lg mb-2 text-gray-900">Assign Ranks</h4>
                    <ul className="space-y-2">
                        {sortedMembers.map(member => (
                            <li key={member.uid} className="flex justify-between items-center bg-white text-gray-900 p-2 rounded border border-amber-200">
                                <span>{member.username}</span>
                                <div className="flex items-center gap-2">
                                    {isLeader && member.uid !== alliance.leader.uid ? (
                                        editingMemberId === member.uid ? (
                                            <select
                                                value={member.rank}
                                                onChange={(e) => {
                                                    handleUpdateMemberRank(member.uid, e.target.value);
                                                    setEditingMemberId(null);
                                                }}
                                                onBlur={() => setEditingMemberId(null)}
                                                autoFocus
                                                className="bg-white text-gray-900 p-1 rounded text-sm border border-amber-300"
                                            >
                                                {alliance.ranks.map(rank => (
                                                    <option key={rank.id} value={rank.id}>{rank.name}</option>
                                                ))}
                                            </select>
                                        ) : (
                                            <button
                                                onClick={() => setEditingMemberId(member.uid)}
                                                className="text-sm text-amber-800 hover:underline cursor-pointer bg-transparent border-none p-0"
                                            >
                                                {member.rank}
                                            </button>
                                        )
                                    ) : (
                                        <span className="text-sm text-amber-800">{member.rank}</span>
                                    )}
                                </div>
                            </li>
                        ))}
                    </ul>
                </div>
            </div>
        </div>
    );
};

export default AllianceRanks;
</file>

<file path="src/components/alliance/AllianceResearch.js">
import React, { useState } from 'react';
import { useAlliance } from '../../contexts/AllianceContext';
import { useAuth } from '../../contexts/AuthContext';
import allianceResearch from '../../gameData/allianceResearch.json';

const AllianceResearch = () => {
    const { playerAlliance, donateToAllianceResearch, recommendAllianceResearch } = useAlliance();
    const { currentUser } = useAuth();
    const [donation, setDonation] = useState({ wood: 0, stone: 0, silver: 0 });
    const [selectedResearch, setSelectedResearch] = useState(null);
    const [message, setMessage] = useState('');

    const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
    const rank = playerAlliance.ranks.find(r => r.id === member?.rank);
    const canRecommend = rank?.permissions?.recommendResearch;

    const handleDonationChange = (e) => {
        setDonation({ ...donation, [e.target.name]: parseInt(e.target.value) || 0 });
    };

    const handleDonate = (researchId) => {
        donateToAllianceResearch(researchId, donation);
        setDonation({ wood: 0, stone: 0, silver: 0 });
    };

    const handleRecommend = async (researchId) => {
        try {
            await recommendAllianceResearch(researchId);
            setMessage('Research recommendation updated!');
            setTimeout(() => setMessage(''), 3000);
        } catch (error) {
            setMessage(`Error: ${error.message}`);
            setTimeout(() => setMessage(''), 3000);
        }
    };

    // #comment Toggles the donation form for a research item
    const handleSelectResearch = (id) => {
        if (selectedResearch === id) {
            setSelectedResearch(null);
        } else {
            setSelectedResearch(id);
            setDonation({ wood: 0, stone: 0, silver: 0 }); // Reset donation on new selection
        }
    };

    return (
        <div className="bg-amber-100 text-gray-900 p-4 rounded-lg shadow-md">
            <h3 className="text-xl font-bold mb-2 border-b border-amber-300 pb-2">Alliance Research</h3>
            {message && <p className="text-center text-amber-800 mb-4">{message}</p>}
            <div className="grid grid-cols-1 gap-4">
                {Object.entries(allianceResearch).map(([id, research]) => {
                    const level = playerAlliance.research[id]?.level || 0;
                    const progress = playerAlliance.research[id]?.progress || { wood: 0, stone: 0, silver: 0 };
                    const cost = {
                        wood: Math.floor(research.baseCost.wood * Math.pow(research.costMultiplier, level)),
                        stone: Math.floor(research.baseCost.stone * Math.pow(research.costMultiplier, level)),
                        silver: Math.floor(research.baseCost.silver * Math.pow(research.costMultiplier, level)),
                    };
                    const isRecommended = playerAlliance.recommendedResearch === id;
                    const isSelected = selectedResearch === id;

                    return (
                        <div
                            key={id}
                            className={`p-4 rounded-lg transition-all border ${
                                isRecommended
                                    ? 'bg-yellow-200 text-gray-900 border-yellow-400 shadow-md'
                                    : 'bg-amber-50 text-gray-900 border-amber-200'
                            }`}
                        >
                            <div className="flex flex-wrap md:flex-nowrap gap-4">
                                <div className="flex-grow">
                                    <h4 className="font-bold">{research.name} (Level {level})</h4>
                                    <p className="text-sm text-amber-800">{research.description}</p>
                                    {level < research.maxLevel ? (
                                        <>
                                            <div className="my-2 grid grid-cols-3 gap-x-2">
                                                <div>
                                                    <p className="font-semibold">Wood</p>
                                                    <p className="text-xs">{progress.wood.toLocaleString()} / {cost.wood.toLocaleString()}</p>
                                                    <div className="w-full bg-gray-300 rounded-full h-1.5 mt-1"><div className="bg-yellow-600 h-1.5 rounded-full" style={{width: `${Math.min(100, (progress.wood / cost.wood) * 100)}%`}}></div></div>
                                                </div>
                                                <div>
                                                    <p className="font-semibold">Stone</p>
                                                    <p className="text-xs">{progress.stone.toLocaleString()} / {cost.stone.toLocaleString()}</p>
                                                    <div className="w-full bg-gray-300 rounded-full h-1.5 mt-1"><div className="bg-gray-500 h-1.5 rounded-full" style={{width: `${Math.min(100, (progress.stone / cost.stone) * 100)}%`}}></div></div>
                                                </div>
                                                <div>
                                                    <p className="font-semibold">Silver</p>
                                                    <p className="text-xs">{progress.silver.toLocaleString()} / {cost.silver.toLocaleString()}</p>
                                                    <div className="w-full bg-gray-300 rounded-full h-1.5 mt-1"><div className="bg-blue-500 h-1.5 rounded-full" style={{width: `${Math.min(100, (progress.silver / cost.silver) * 100)}%`}}></div></div>
                                                </div>
                                            </div>
                                            <div className="flex gap-2 mt-2">
                                                <button onClick={() => handleSelectResearch(id)} className="btn btn-sm btn-primary">{isSelected ? 'Close' : 'Donate'}</button>
                                                {canRecommend && (
                                                    <button onClick={() => handleRecommend(id)} className={`btn btn-sm btn-secondary ${isRecommended ? 'bg-green-500 hover:bg-green-600 text-white' : ''}`}>
                                                        {isRecommended ? 'Recommended' : 'Recommend'}
                                                    </button>
                                                )}
                                            </div>
                                        </>
                                    ) : (
                                        <p className="text-green-600 font-bold mt-2">Max Level Reached</p>
                                    )}
                                </div>

                                {isSelected && (
                                    <div className="w-full md:w-64 flex-shrink-0 bg-amber-100 p-3 rounded-lg border border-amber-300">
                                        <h4 className="font-bold text-center mb-2">Donate to {research.name}</h4>
                                        <div className="flex flex-col gap-2">
                                            <input type="number" name="wood" value={donation.wood} onChange={handleDonationChange} className="w-full bg-white p-1 rounded border border-amber-300" placeholder="Wood" />
                                            <input type="number" name="stone" value={donation.stone} onChange={handleDonationChange} className="w-full bg-white p-1 rounded border border-amber-300" placeholder="Stone" />
                                            <input type="number" name="silver" value={donation.silver} onChange={handleDonationChange} className="w-full bg-white p-1 rounded border border-amber-300" placeholder="Silver" />
                                        </div>
                                        <button onClick={() => handleDonate(id)} className="btn btn-confirm w-full mt-2">Confirm Donation</button>
                                    </div>
                                )}
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

export default AllianceResearch;
</file>

<file path="src/components/alliance/AllianceSettings.js">
import React, { useState } from 'react';
import { useAlliance } from '../../contexts/AllianceContext';
import TextEditor from '../shared/TextEditor';

const AllianceSettings = ({ alliance, onClose, updateSettings, isLeader }) => {
    const { updateAllianceSettings } = useAlliance();
    const [name, setName] = useState(alliance.name);
    const [description, setDescription] = useState(alliance.settings.description);
    const [privateDescription, setPrivateDescription] = useState(alliance.settings.privateDescription || '');
    const [status, setStatus] = useState(alliance.settings.status);
    const [message, setMessage] = useState('');
    const handleSave = () => {
        if (!isLeader) return;
        if (name.trim() === '' || description.trim() === '') {
            setMessage('Name and description cannot be empty.');
            return;
        }

        updateAllianceSettings({
            name,
            description,
            privateDescription,
            status,
        });
        setMessage('Settings saved successfully!');
    };

    const getStatusBadge = () => {
        switch(status) {
            case 'open': return <span className="status-badge status-open">Open</span>;
            case 'invite_only': return <span className="status-badge status-invite_only">Invite Only</span>;
            case 'closed': return <span className="status-badge status-closed">Closed</span>;
            default: return null;
        }
    };

    return (
        <div className="settings-container">
            <div className="settings-section">
                <h3>Alliance Information</h3>
                <div className="form-group">
                    <label>Alliance Name</label>
                    <input
                        type="text"
                        value={name}
                        onChange={(e) => setName(e.target.value)}
                        className="settings-input"
                        disabled={!isLeader}
                    />
                </div>

                <div className="form-group">
                    <label>Alliance Description (Public)</label>
                    <TextEditor value={description} onChange={setDescription} disabled={!isLeader} />
                </div>
                 <div className="form-group">
                    <label>Alliance Description (Private)</label>
                    <TextEditor value={privateDescription} onChange={setPrivateDescription} disabled={!isLeader} />
                </div>
            </div>

            <div className="settings-section">
                <h3>Membership Settings</h3>
                    <div className="form-group">
                        <label>Alliance Status {getStatusBadge()}</label>
                        <select
                            value={status}
                            onChange={(e) => setStatus(e.target.value)}
                            className="settings-input alliance-text-dark alliance-bg-dark"
                            disabled={!isLeader}>
                        <option value="open">Open (Anyone can join)</option>
                        <option value="invite_only">Invite Only (Join by invite or application)</option>
                        <option value="closed">Closed (Join by invite only)</option>
                    </select>
                </div>
            </div>

            {message && (
                <div className={`message ${message.includes('success') ? 'success' : 'error'}`}>
                    {message}
                </div>
            )}

            {isLeader && (
                <div className="actions">
                    <button onClick={handleSave} className="save-button">
                        Save Settings
                    </button>
                </div>
            )}
        </div>
    );
};

export default AllianceSettings;
</file>

<file path="src/components/alliance/AllianceSuggestions.js">
// src/components/alliance/AllianceSuggestions.js
import React, { useState, useEffect } from 'react';
import { db } from '../../firebase/config';
import { collection, getDocs, query, where, collectionGroup, onSnapshot } from 'firebase/firestore'; // Import onSnapshot
import { useGame } from '../../contexts/GameContext';
import { useAlliance } from '../../contexts/AllianceContext';

// #comment Cache for player points to reduce reads. Alliance data will be real-time.
const suggestionsCache = {
    playerPointsMap: null,
    timestamp: 0,
};

export const clearSuggestionsCache = () => {
    suggestionsCache.playerPointsMap = null;
    suggestionsCache.timestamp = 0;
};

const AllianceSuggestions = ({ onAllianceClick, onOpenCreate }) => {
    const { worldId, worldState } = useGame();
    const { applyToAlliance, joinOpenAlliance } = useAlliance();
    const [alliances, setAlliances] = useState([]);
    const [loading, setLoading] = useState(true);
    const [message, setMessage] = useState(''); // State for user feedback

    useEffect(() => {
        if (!worldId || !worldState) return;

        let playerPointsMap = new Map();
        let isFetchingPoints = false;

        const alliancesRef = collection(db, 'worlds', worldId, 'alliances');
        const q = query(alliancesRef, where('settings.status', 'in', ['open', 'invite_only']));

        // #comment Set up a real-time listener for alliance changes (members, status, etc.)
        const unsubscribe = onSnapshot(q, async (snapshot) => {
            setLoading(true);
            const alliancesFromDB = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            const now = Date.now();
            const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes for points

            // #comment Fetch or use cached player points
            if (now - suggestionsCache.timestamp > CACHE_DURATION || !suggestionsCache.playerPointsMap) {
                if (!isFetchingPoints) {
                    isFetchingPoints = true;
                    const gamesGroupRef = collectionGroup(db, 'games');
                    const gamesQuery = query(gamesGroupRef, where('worldName', '==', worldState.name));
                    const gamesSnapshot = await getDocs(gamesQuery);

                    gamesSnapshot.forEach(gameDoc => {
                        const userId = gameDoc.ref.parent.parent.id;
                        playerPointsMap.set(userId, gameDoc.data().totalPoints || 0);
                    });
                    suggestionsCache.playerPointsMap = playerPointsMap;
                    suggestionsCache.timestamp = now;
                    isFetchingPoints = false;
                }
            } else {
                playerPointsMap = suggestionsCache.playerPointsMap;
            }

            // #comment Combine real-time alliance data with cached points
            const alliancesData = alliancesFromDB.map(alliance => {
                let totalPoints = 0;
                for (const member of alliance.members) {
                    totalPoints += playerPointsMap.get(member.uid) || 0;
                }
                return { ...alliance, totalPoints };
            });

            setAlliances(alliancesData);
            setLoading(false);
        });

        return () => unsubscribe(); // Cleanup listener on unmount
    }, [worldId, worldState]);

    const handleAction = async (alliance) => {
        setMessage(''); // Clear previous messages
        try {
            if (alliance.settings.status === 'open') {
                await joinOpenAlliance(alliance.id);
                // No need to set a message here, as the component will unmount on success
            } else {
                await applyToAlliance(alliance.id);
                setMessage(`Application sent to ${alliance.name}!`);
            }
        } catch (error) {
            console.error("Error performing alliance action:", error);
            setMessage(`Action failed: ${error.message}`); // Show error to user
        }
    };

    if (loading) {
        return <div className="text-center p-4">Loading alliances...</div>;
    }

    return (
        <div className="text-gray-900">
            <div className="flex justify-between items-center mb-4">
                <h3 className="text-xl font-bold">Available Alliances</h3>
                <button onClick={onOpenCreate} className="btn btn-primary">Create Your Own</button>
            </div>
            {message && <p className="text-center p-2 bg-yellow-200 rounded mb-4">{message}</p>}
            <table className="w-full text-left">
                <thead>
                    <tr className="bg-gray-300">
                        <th className="p-2">Tag</th>
                        <th className="p-2">Name</th>
                        <th className="p-2 text-center">Members</th>
                        <th className="p-2 text-right">Points</th>
                    </tr>
                </thead>
                <tbody>
                    {alliances.map(alliance => (
                        <tr key={alliance.id} className="border-b border-gray-300">
                            <td className="p-2 font-bold">[{alliance.tag}]</td>
                            <td className="p-2">
                                <button onClick={() => onAllianceClick(alliance.id)} className="font-bold text-blue-600 hover:underline">
                                    {alliance.name}
                                </button>
                            </td>
                            <td className="p-2 text-center">{alliance.members.length} / 25</td>
                            <td className="p-2 text-right">{alliance.totalPoints.toLocaleString()}</td>
                            <td className="p-2 text-center">
                                <button onClick={() => handleAction(alliance)} className="btn btn-confirm text-sm px-3 py-1">
                                    {alliance.settings.status === 'open' ? 'Join' : 'Apply'}
                                </button>
                            </td>
                        </tr>
                    ))}
                </tbody>
            </table>
        </div>
    );
};

export default AllianceSuggestions;
</file>

<file path="src/components/alliance/AllianceWonder.js">
// src/hooks/actions/useAllianceWonderActions.js
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { db } from '../../firebase/config';
import { doc, runTransaction, collection, serverTimestamp, addDoc } from "firebase/firestore";
import allianceWonders from '../../gameData/alliance_wonders.json';

// #comment Calculate the total cost to build a wonder level
const getWonderCost = (level) => {
    const costMultiplier = Math.pow(1.5, level);
    return {
        wood: Math.floor(100000 * costMultiplier),
        stone: Math.floor(100000 * costMultiplier),
        silver: Math.floor(50000 * costMultiplier)
    };
};

// #comment Get the current progress of the wonder
export const getWonderProgress = (alliance, wonderId) => {
    const progress = alliance?.wonderProgress?.[wonderId] || { wood: 0, stone: 0, silver: 0 };
    return progress;
};

// #comment This hook contains actions related to alliance wonders.
export const useAllianceWonderActions = (playerAlliance) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId, gameState } = useGame();

    const startWonder = async (wonderId, islandId, coords) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        if (playerAlliance.leader.uid !== currentUser.uid) throw new Error("Only the leader can start a wonder.");
        if (playerAlliance.allianceWonder) throw new Error("Your alliance is already building a wonder.");

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', gameState.id);
        const eventRef = doc(collection(allianceDocRef, 'events'));
        const startCost = { wood: 50000, stone: 50000, silver: 25000 };

        await runTransaction(db, async (transaction) => {
            const cityDoc = await transaction.get(cityDocRef);
            if (!cityDoc.exists()) throw new Error("Your city data was not found.");
            const cityData = cityDoc.data();

            for (const resource in startCost) {
                if ((cityData.resources[resource] || 0) < startCost[resource]) {
                    throw new Error(`You do not have enough ${resource} to start the wonder.`);
                }
            }

            const newPlayerResources = { ...cityData.resources };
            for (const resource in startCost) {
                newPlayerResources[resource] -= startCost[resource];
            }

            transaction.update(cityDocRef, { resources: newPlayerResources });

            transaction.update(allianceDocRef, {
                allianceWonder: { id: wonderId, level: 0, islandId, x: coords.x, y: coords.y },
                wonderProgress: { [wonderId]: { wood: 0, stone: 0, silver: 0 } }
            });

            const eventText = `${userProfile.username} has started construction of the ${allianceWonders[wonderId].name}.`;
            transaction.set(eventRef, {
                type: 'wonder_start',
                text: eventText,
                timestamp: serverTimestamp()
            });
        });
    };

    const donateToWonder = async (wonderId, donation) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', gameState.id);
        const eventRef = doc(collection(allianceDocRef, 'events'));

        await runTransaction(db, async (transaction) => {
            const cityDoc = await transaction.get(cityDocRef);
            const allianceDoc = await transaction.get(allianceDocRef);
            if (!cityDoc.exists() || !allianceDoc.exists()) throw new Error("City or Alliance data not found.");

            const cityData = cityDoc.data();
            const allianceData = allianceDoc.data();
            
            const currentWonder = allianceData.allianceWonder;
            if (!currentWonder || currentWonder.id !== wonderId) throw new Error("Cannot donate to this wonder, as it is not the active wonder.");

            const newPlayerResources = { ...cityData.resources };
            const newWonderProgress = { ...(allianceData.wonderProgress?.[wonderId] || { wood: 0, stone: 0, silver: 0 }) };

            for (const resource in donation) {
                if ((newPlayerResources[resource] || 0) < donation[resource]) throw new Error(`Not enough ${resource} in your city.`);
                newPlayerResources[resource] -= donation[resource];
                newWonderProgress[resource] += donation[resource];
            }

            transaction.update(cityDocRef, { resources: newPlayerResources });
            transaction.update(allianceDocRef, { [`wonderProgress.${wonderId}`]: newWonderProgress });

            const donationAmounts = Object.entries(donation).filter(([,a]) => a > 0).map(([r,a]) => `${a.toLocaleString()} ${r}`).join(', ');
            if (donationAmounts) {
                transaction.set(eventRef, {
                    type: 'wonder_donation',
                    text: `${userProfile.username} donated ${donationAmounts} to the wonder.`,
                    timestamp: serverTimestamp()
                });
            }
        });
    };

    const claimWonderLevel = async (wonderId) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        if (playerAlliance.leader.uid !== currentUser.uid) throw new Error("Only the leader can claim wonder levels.");

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const eventRef = collection(allianceDocRef, 'events');

        await runTransaction(db, async (transaction) => {
            const allianceDoc = await transaction.get(allianceDocRef);
            if (!allianceDoc.exists()) throw new Error("Alliance data not found.");

            const allianceData = allianceDoc.data();
            const currentWonder = allianceData.allianceWonder;
            const progress = allianceData.wonderProgress[wonderId] || { wood: 0, stone: 0, silver: 0 };
            const nextLevel = currentWonder.level + 1;
            const cost = getWonderCost(nextLevel -1);

            if (progress.wood < cost.wood || progress.stone < cost.stone || progress.silver < cost.silver) {
                throw new Error("Not enough resources have been donated to claim this level.");
            }

            const newProgress = {
                wood: progress.wood - cost.wood,
                stone: progress.stone - cost.stone,
                silver: progress.silver - cost.silver,
            };

            transaction.update(allianceDocRef, {
                allianceWonder: { ...currentWonder, level: nextLevel },
                [`wonderProgress.${wonderId}`]: newProgress
            });
            
            const eventText = `The ${allianceWonders[wonderId].name} has been upgraded to Level ${nextLevel}!`;
            transaction.set(doc(eventRef), {
                type: 'wonder_upgrade',
                text: eventText,
                timestamp: serverTimestamp()
            });
        });
    };

    const demolishWonder = async () => {
         if (!playerAlliance) throw new Error("You are not in an alliance.");
         if (playerAlliance.leader.uid !== currentUser.uid) throw new Error("Only the leader can demolish the wonder.");

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const eventRef = collection(allianceDocRef, 'events');

        await runTransaction(db, async (transaction) => {
            const allianceDoc = await transaction.get(allianceDocRef);
            if (!allianceDoc.exists()) throw new Error("Alliance data not found.");
            
            const currentWonder = allianceDoc.data().allianceWonder;
            if (!currentWonder) throw new Error("No wonder to demolish.");

            transaction.update(allianceDocRef, { allianceWonder: null, wonderProgress: {} });

            const eventText = `${userProfile.username} has demolished the alliance wonder, ${allianceWonders[currentWonder.id].name}.`;
            transaction.set(doc(eventRef), {
                type: 'wonder_demolish',
                text: eventText,
                timestamp: serverTimestamp()
            });
        });
    };

    return { startWonder, donateToWonder, claimWonderLevel, demolishWonder };
};
</file>

<file path="src/components/alliance/WonderBuilderModal.js">
// src/components/alliance/WonderBuilderModal.js
import React, { useState } from 'react';
import { useAlliance } from '../../contexts/AllianceContext';
import allianceWonders from '../../gameData/alliance_wonders.json';

const WonderBuilderModal = ({ onClose, islandId, coords }) => {
    const { startWonder } = useAlliance();
    const [selectedWonder, setSelectedWonder] = useState(null);
    const [message, setMessage] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);

    const handleStartWonder = async () => {
        if (!selectedWonder) {
            setMessage('Please select a wonder to build.');
            return;
        }
        setIsSubmitting(true);
        setMessage('Beginning construction...');
        try {
            await startWonder(selectedWonder, islandId, coords);
            setMessage('Construction has begun!');
            onClose();
        } catch (error) {
            setMessage(`Failed to start wonder: ${error.message}`);
            setIsSubmitting(false);
        }
    };

    const startCost = { wood: 50000, stone: 50000, silver: 25000 };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-2xl border-2 border-gray-600 text-white" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="text-xl font-bold">Construct an Alliance Wonder</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                {message && <p className="text-center text-yellow-400 mb-4">{message}</p>}
                <p className="text-sm text-gray-400 mb-4">Select a wonder to build on this island. The initial cost will be deducted from your active city's resources.</p>
                <p className="text-center font-bold mb-4">Start Cost: {startCost.wood}W, {startCost.stone}S, {startCost.silver}Ag</p>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    {Object.entries(allianceWonders).map(([id, wonder]) => (
                        <div
                            key={id}
                            onClick={() => setSelectedWonder(id)}
                            className={`p-4 rounded-lg cursor-pointer border-2 ${selectedWonder === id ? 'bg-gray-600 border-yellow-500' : 'bg-gray-700 border-gray-600 hover:border-yellow-400'}`}
                        >
                            <h4 className="font-bold text-lg">{wonder.name}</h4>
                            <p className="text-sm text-gray-400">{wonder.description}</p>
                        </div>
                    ))}
                </div>
                <button
                    onClick={handleStartWonder}
                    disabled={!selectedWonder || isSubmitting}
                    className="btn btn-confirm w-full mt-6"
                >
                    {isSubmitting ? 'Constructing...' : 'Begin Construction'}
                </button>
            </div>
        </div>
    );
};

export default WonderBuilderModal;
</file>

<file path="src/components/alliance/WonderProgressModal.js">
// src/components/alliance/WonderProgressModal.js
import React, { useState } from 'react';
import { useAlliance } from '../../contexts/AllianceContext';
import { useAuth } from '../../contexts/AuthContext';
import allianceWonders from '../../gameData/alliance_wonders.json';
import { getWonderProgress } from '../../hooks/actions/useAllianceWonderActions';

const WonderProgressModal = ({ onClose }) => {
    const { playerAlliance, donateToWonder, claimWonderLevel } = useAlliance();
    const { currentUser } = useAuth();
    const [donation, setDonation] = useState({ wood: 0, stone: 0, silver: 0 });
    const [message, setMessage] = useState('');

    const isLeader = playerAlliance?.leader?.uid === currentUser?.uid;
    const currentWonder = playerAlliance?.allianceWonder;
    const wonderConfig = currentWonder ? allianceWonders[currentWonder.id] : null;

    if (!currentWonder || !wonderConfig) {
        return null; // Or a loading/error state
    }

    const handleDonationChange = (e) => {
        const { name, value } = e.target;
        setDonation(prev => ({ ...prev, [name]: parseInt(value) || 0 }));
    };

    const handleDonate = async () => {
        setMessage('');
        try {
            await donateToWonder(currentWonder.id, donation);
            setMessage('Donation successful!');
            setDonation({ wood: 0, stone: 0, silver: 0 });
        } catch (error) {
            setMessage(`Donation failed: ${error.message}`);
        }
    };
    
    const handleClaimLevel = async () => {
        setMessage('');
        if (!isLeader) return;
        try {
            await claimWonderLevel(currentWonder.id);
            setMessage(`Wonder upgraded to level ${currentWonder.level + 1}!`);
        } catch (error) {
            setMessage(`Claim failed: ${error.message}`);
        }
    };

    const getWonderCost = (level) => {
        if (!wonderConfig) return { wood: 0, stone: 0, silver: 0 };
        const costMultiplier = Math.pow(1.5, level);
        return {
            wood: Math.floor(100000 * costMultiplier),
            stone: Math.floor(100000 * costMultiplier),
            silver: Math.floor(50000 * costMultiplier)
        };
    };

    const nextLevel = currentWonder.level + 1;
    const nextLevelCost = getWonderCost(currentWonder.level);
    const progress = getWonderProgress(playerAlliance, currentWonder.id);
    
    const totalProgress = (progress.wood || 0) + (progress.stone || 0) + (progress.silver || 0);
    const totalCost = (nextLevelCost.wood || 0) + (nextLevelCost.stone || 0) + (nextLevelCost.silver || 0);
    const progressPercent = totalCost > 0 ? (totalProgress / totalCost) * 100 : 0;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg border-2 border-gray-600 text-white" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="text-xl font-bold">{wonderConfig.name} (Level {currentWonder.level})</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                {message && <p className="text-center text-yellow-400 mb-4">{message}</p>}
                
                <p className="text-sm italic mb-4">{wonderConfig.description}</p>
                <div className="w-full bg-gray-700 rounded-full h-8 mb-4 relative">
                    <div
                        className="bg-yellow-500 h-full rounded-full transition-all duration-500"
                        style={{ width: `${Math.min(100, progressPercent)}%` }}
                    ></div>
                    <span className="absolute inset-0 flex items-center justify-center text-white font-bold">
                        {Math.min(100, progressPercent).toFixed(1)}% to Level {nextLevel}
                    </span>
                </div>
                <div className="grid grid-cols-3 gap-2 text-sm text-center mb-4">
                    <div>Wood: {progress.wood.toLocaleString()} / {nextLevelCost.wood.toLocaleString()}</div>
                    <div>Stone: {progress.stone.toLocaleString()} / {nextLevelCost.stone.toLocaleString()}</div>
                    <div>Silver: {progress.silver.toLocaleString()} / {nextLevelCost.silver.toLocaleString()}</div>
                </div>

                {isLeader && (
                    <button
                        onClick={handleClaimLevel}
                        disabled={progressPercent < 100}
                        className="btn btn-confirm w-full mb-4"
                    >
                        {progressPercent >= 100 ? `Claim Level ${nextLevel}` : `Requires more resources`}
                    </button>
                )}

                <div className="bg-gray-700 p-4 rounded-lg">
                    <h5 className="font-bold text-lg mb-2">Donate Resources</h5>
                    <div className="flex gap-2">
                        <input type="number" name="wood" value={donation.wood} onChange={handleDonationChange} className="w-full bg-gray-900 p-1 rounded" placeholder="Wood" />
                        <input type="number" name="stone" value={donation.stone} onChange={handleDonationChange} className="w-full bg-gray-900 p-1 rounded" placeholder="Stone" />
                        <input type="number" name="silver" value={donation.silver} onChange={handleDonationChange} className="w-full bg-gray-900 p-1 rounded" placeholder="Silver" />
                    </div>
                    <button onClick={handleDonate} className="btn btn-primary w-full mt-4">Donate</button>
                </div>
            </div>
        </div>
    );
};

export default WonderProgressModal;
</file>

<file path="src/components/AuthScreen.css">
/* src/components/AuthScreen.css */
.auth-screen-container {
    background-image: url('../images/login.png');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
}

/* New styles for the login/register window */
.auth-window {
    background-color: rgba(10, 10, 20, 0.85); /* Dark, semi-transparent background */
    border: 1px solid #a17c48; /* Gold-like border */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    border-radius: 10px;
    color: #f0e68c; /* Khaki text color */
    padding: 2rem;
    width: 100%;
    max-width: 28rem; /* max-w-md */
}

.auth-window h1, .auth-window h2 {
    color: #f0e68c;
    text-shadow: 1px 1px 4px rgba(0,0,0,0.6);
}

.auth-window label {
    color: #d2b48c; /* Tan color */
}

.auth-window input {
    background-color: rgba(0, 0, 0, 0.3);
    border: 1px solid #a17c48;
    color: #f0e68c;
    border-radius: 0.5rem; /* rounded-lg */
    padding: 0.5rem 1rem; /* px-4 py-2 */
    width: 100%;
}

.auth-window input:focus {
    outline: none;
    box-shadow: 0 0 0 2px #a17c48;
}

.auth-window .btn-primary {
    background: #a17c48;
    border: 1px solid #f0e68c;
    color: #1a1a2e;
    font-weight: bold;
    padding: 0.75rem; /* py-3 */
    border-radius: 0.5rem; /* rounded-lg */
    width: 100%;
    transition: background-color 0.2s;
}

.auth-window .btn-primary:hover {
     background: #f0e68c;
}

.auth-window .link-button {
    color: #a17c48;
    background: none;
    border: none;
    text-decoration: underline;
    cursor: pointer;
}

.auth-window .link-button:hover {
    color: #f0e68c;
}

.auth-window p {
    color: #d2b48c; /* Tan color for paragraphs */
}
</file>

<file path="src/components/AuthScreen.js">
import React, { useState } from 'react';
import { signInWithEmailAndPassword, createUserWithEmailAndPassword } from "firebase/auth";
import { doc, setDoc } from "firebase/firestore";
import { auth, db } from '../firebase/config';
import Modal from './shared/Modal';
import EyeIcon from './icons/EyeIcon';
import EyeOffIcon from './icons/EyeOffIcon';
import './AuthScreen.css';

const AuthScreen = () => {
    const [isFlipped, setIsFlipped] = useState(false);
    const [showPassword, setShowPassword] = useState(false);
    const [message, setMessage] = useState('');

    // Form states
    const [loginEmail, setLoginEmail] = useState('');
    const [loginPassword, setLoginPassword] = useState('');
    const [registerUsername, setRegisterUsername] = useState('');
    const [registerEmail, setRegisterEmail] = useState('');
    const [registerPassword, setRegisterPassword] = useState('');
    const [registerConfirmPassword, setRegisterConfirmPassword] = useState('');

    const validateRegistration = () => {
        if (!registerUsername || !registerEmail || !registerPassword || !registerConfirmPassword) {
            setMessage("All fields are required.");
            return false;
        }
        if (registerPassword !== registerConfirmPassword) {
            setMessage("Passwords do not match.");
            return false;
        }
        if (registerPassword.length < 6) {
            setMessage("Password must be at least 6 characters long.");
            return false;
        }
        if (registerUsername.length < 3) {
            setMessage("Username must be at least 3 characters long.");
            return false;
        }
        return true;
    };

    const handleLogin = async (e) => {
        e.preventDefault();
        setMessage('');
        try {
            await signInWithEmailAndPassword(auth, loginEmail, loginPassword);
        } catch (error) {
            setMessage("Failed to login. Please check your email and password.");
            console.error(error);
        }
    };

    const handleRegister = async (e) => {
        e.preventDefault();
        if (!validateRegistration()) return;
        setMessage('');
        try {
            const userCredential = await createUserWithEmailAndPassword(auth, registerEmail, registerPassword);
            const user = userCredential.user;
            await setDoc(doc(db, "users", user.uid), {
                username: registerUsername,
                email: user.email,
                is_admin: false
            });
        } catch (error) {
            if (error.code === 'auth/email-already-in-use') {
                setMessage("An account with this email already exists.");
            } else {
                setMessage(error.message);
            }
            console.error(error);
        }
    };

    const togglePasswordVisibility = () => setShowPassword(!showPassword);

    return (
        <div className="w-full min-h-screen flex items-center justify-center p-4 perspective auth-screen-container">
            <Modal message={message} onClose={() => setMessage('')} />
            <div className={`auth-card ${isFlipped ? 'flipped' : ''}`}>
                {/* Front Side: Login */}
                <div className="auth-card-face auth-card-front">
                    <div className="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-md">
                        <h1 className="font-title text-4xl text-center text-gray-300 mb-8">Age of Nasos</h1>
                        <h2 className="text-2xl font-bold text-center text-white mb-6">Login</h2>
                        <form onSubmit={handleLogin}>
                            <div className="mb-4">
                                <label className="block text-gray-400 mb-2">Email</label>
                                <input type="email" value={loginEmail} onChange={(e) => setLoginEmail(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" required />
                            </div>
                            <div className="mb-6 relative">
                                <label className="block text-gray-400 mb-2">Password</label>
                                <input type={showPassword ? 'text' : 'password'} value={loginPassword} onChange={(e) => setLoginPassword(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" required />
                                <button type="button" onClick={togglePasswordVisibility} className="absolute right-3 top-10 text-gray-400 hover:text-white">
                                    {showPassword ? <EyeOffIcon /> : <EyeIcon />}
                                </button>
                            </div>
                            <button type="submit" className="w-full btn btn-primary font-bold py-3 rounded-lg">Enter the Realm</button>
                        </form>
                        <p className="text-center text-gray-400 mt-6">
                            Don't have an account? <button onClick={() => setIsFlipped(true)} className="text-blue-400 hover:underline">Register here</button>
                        </p>
                    </div>
                </div>

                {/* Back Side: Register */}
                <div className="auth-card-face auth-card-back">
                    <div className="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-md">
                        <h1 className="font-title text-4xl text-center text-gray-300 mb-8">Age of Nasos</h1>
                        <h2 className="text-2xl font-bold text-center text-white mb-6">Register</h2>
                        <form onSubmit={handleRegister}>
                             <div className="mb-4">
                                <label className="block text-gray-400 mb-2">Username</label>
                                <input type="text" value={registerUsername} onChange={(e) => setRegisterUsername(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" required />
                            </div>
                            <div className="mb-4">
                                <label className="block text-gray-400 mb-2">Email</label>
                                <input type="email" value={registerEmail} onChange={(e) => setRegisterEmail(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" required />
                            </div>
                            <div className="mb-4 relative">
                                <label className="block text-gray-400 mb-2">Password</label>
                                <input type={showPassword ? 'text' : 'password'} value={registerPassword} onChange={(e) => setRegisterPassword(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" required />
                                 <button type="button" onClick={togglePasswordVisibility} className="absolute right-3 top-10 text-gray-400 hover:text-white">
                                    {showPassword ? <EyeOffIcon /> : <EyeIcon />}
                                </button>
                            </div>
                             <div className="mb-6">
                                <label className="block text-gray-400 mb-2">Confirm Password</label>
                                <input type={showPassword ? 'text' : 'password'} value={registerConfirmPassword} onChange={(e) => setRegisterConfirmPassword(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" required />
                            </div>
                            <button type="submit" className="w-full btn btn-primary font-bold py-3 rounded-lg">Forge Your Empire</button>
                        </form>
                        <p className="text-center text-gray-400 mt-6">
                            Already have an account? <button onClick={() => setIsFlipped(false)} className="text-blue-400 hover:underline">Login here</button>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default AuthScreen;
</file>

<file path="src/components/chat/Chat.css">
.chat-toggle-button {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 1000;
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #4a2c2a;
    border: 2px solid #8B4513;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    font-size: 24px;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    transition: all 0.2s ease-in-out;
}

.chat-toggle-button:hover {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
    transform: scale(1.1);
}

.chat-window {
    position: fixed;
    width: 380px;
    height: 500px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    z-index: 1000;
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a;
}

.chat-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 1rem;
    background-color: #1e3a8a;
    color: #f0e68c;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.25rem;
    border-bottom: 2px solid #cd853f;
    cursor: move;
}

.chat-header .close-btn {
    background: none;
    border: none;
    color: #f0e68c;
    font-size: 2rem;
    cursor: pointer;
}
.chat-header .close-btn:hover {
    color: white;
}

.chat-tabs {
    display: flex;
    background-color: #1e3a8a;
    padding: 4px;
    border-bottom: 4px solid #8B4513;
}

.chat-tab {
    flex-grow: 1;
    padding: 8px 16px;
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #4a2c2a;
    border: 2px solid #8B4513;
    border-bottom: none;
    margin-right: 4px;
    cursor: pointer;
    font-weight: bold;
}

.chat-tab:hover:not(:disabled) {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}

.chat-tab.active {
    background: #F5DEB3;
    color: #4a2c2a;
}

.chat-tab:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background: #d2b48c;
}

.messages-container {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.message {
    padding: 8px 12px;
    border-radius: 18px;
    max-width: 85%;
    word-wrap: break-word;
    display: flex;
    flex-direction: column;
    border: 1px solid #d2b48c; /* tan */
}

.message .author {
    font-weight: bold;
    font-size: 0.9em;
    margin-bottom: 4px;
    color: #8B4513; /* saddlebrown */
}

.message p {
    margin: 0;
    color: #4a2c2a;
}

.message.sent {
    background-color: #e6cba8; /* lighter tan */
    align-self: flex-end;
    border-bottom-right-radius: 4px;
}

.message.received {
    background-color: #d3b890;
    align-self: flex-start;
    border-bottom-left-radius: 4px;
}

.send-message-form {
    display: flex;
    padding: 10px;
    border-top: 2px solid #8B4513;
    background-color: rgba(139, 69, 19, 0.1); /* saddlebrown transparent */
}

.send-message-form input {
    flex-grow: 1;
    padding: 10px 15px;
    border-radius: 20px;
    border: 1px solid #d2b48c;
    background-color: rgba(255, 255, 255, 0.5);
    color: #4a2c2a;
    margin-right: 10px;
    outline: none;
}
.send-message-form input:focus {
    border-color: #8B4513;
}

.send-message-form button {
    padding: 10px 20px;
    border-radius: 20px;
    border: 2px solid #8B4513;
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #4a2c2a;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.2s;
}

.send-message-form button:hover {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}
</file>

<file path="src/components/chat/Chat.js">
// src/components/chat/Chat.js
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { db } from '../../firebase/config';
import { collection, addDoc, query, orderBy, onSnapshot, serverTimestamp } from 'firebase/firestore';
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { useAlliance } from '../../contexts/AllianceContext';
import './Chat.css';

const Chat = ({ isVisible, onClose }) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId } = useGame();
    const { playerAlliance } = useAlliance(); // Use the correct context for alliance data
    const [messages, setMessages] = useState([]);
    const [newMessage, setNewMessage] = useState('');
    const [activeTab, setActiveTab] = useState('world');
    const messagesEndRef = useRef(null);

    // Draggable state
    const [position, setPosition] = useState({ x: 20, y: window.innerHeight - 540 });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
    const chatWindowRef = useRef(null);

    // #comment fetch messages based on the active tab (world or alliance)
    useEffect(() => {
        if (!worldId) return;

        let chatCollectionRef;
        if (activeTab === 'world') {
            chatCollectionRef = collection(db, 'worlds', worldId, 'chat');
        } else if (activeTab === 'alliance' && playerAlliance) {
            chatCollectionRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'chat');
        } else {
            setMessages([]);
            return;
        }

        const q = query(chatCollectionRef, orderBy('timestamp', 'asc'));
        const unsubscribe = onSnapshot(q, (querySnapshot) => {
            const msgs = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setMessages(msgs);
        });

        return () => unsubscribe();
    }, [worldId, activeTab, playerAlliance]);

    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);

    // #comment send a new message to the currently active chat tab
    const handleSendMessage = async (e) => {
        e.preventDefault();
        if (newMessage.trim() === '' || !worldId || !currentUser || !userProfile) return;

        let chatCollectionRef;
        if (activeTab === 'world') {
            chatCollectionRef = collection(db, 'worlds', worldId, 'chat');
        } else if (activeTab === 'alliance' && playerAlliance) {
            chatCollectionRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'chat');
        } else {
            return; // Can't send message if no valid chat is selected
        }

        await addDoc(chatCollectionRef, {
            text: newMessage,
            timestamp: serverTimestamp(),
            uid: currentUser.uid,
            authorName: userProfile.username,
        });

        setNewMessage('');
    };
    
    // #comment handle mouse down for dragging the chat window
    const handleMouseDown = (e) => {
        if (e.target.classList.contains('chat-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    // #comment handle mouse move for dragging
    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart, setPosition]);

    // #comment handle mouse up to stop dragging
    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }

        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);


    if (!isVisible) return null;

    return (
        <div 
            className="chat-window" 
            ref={chatWindowRef}
            style={{ top: `${position.y}px`, left: `${position.x}px` }}
        >
            <div className="chat-header" onMouseDown={handleMouseDown}>
                <h4>Chat</h4>
                <button onClick={onClose} className="close-btn">&times;</button>
            </div>
            <div className="chat-tabs">
                <button 
                    className={`chat-tab ${activeTab === 'world' ? 'active' : ''}`}
                    onClick={() => setActiveTab('world')}
                >
                    World
                </button>
                <button 
                    className={`chat-tab ${activeTab === 'alliance' ? 'active' : ''}`}
                    onClick={() => setActiveTab('alliance')}
                    disabled={!playerAlliance}
                    title={!playerAlliance ? "You are not in an alliance" : "Alliance Chat"}
                >
                    Alliance
                </button>
            </div>
            <div className="messages-container">
                {messages.map((msg) => (
                    <div key={msg.id} className={`message ${msg.uid === currentUser.uid ? 'sent' : 'received'}`}>
                        <span className="author">{msg.authorName}:</span>
                        <p>{msg.text}</p>
                    </div>
                ))}
                <div ref={messagesEndRef} />
            </div>
            <form onSubmit={handleSendMessage} className="send-message-form">
                <input
                    type="text"
                    value={newMessage}
                    onChange={(e) => setNewMessage(e.target.value)}
                    placeholder="Type a message..."
                    maxLength="75"
                />
                <button type="submit">Send</button>
            </form>
        </div>
    );
};

export default Chat;
</file>

<file path="src/components/city/AcademyMenu.css">
/* src/components/city/AcademyMenu.css */
.academy-container {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3;
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a;
    width: 90%;
    max-width: 900px; /* Increased width */
    height: 80vh; /* Use vh for height */
    max-height: 700px; /* Set a max-height */
    display: flex;
    flex-direction: column;
    position: fixed;
    z-index: 50;
}

.academy-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1.5rem;
    background-color: #1e3a8a;
    color: #f0e68c;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.5rem;
    border-bottom: 2px solid #cd853f;
    flex-shrink: 0; /* Prevent header from shrinking */
    cursor: move;
}

.academy-header .close-btn {
    background: none;
    border: none;
    color: #f0e68c;
    font-size: 2.5rem;
    cursor: pointer;
    line-height: 1;
}

.academy-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 1.5rem; /* Increased gap */
    padding: 1.5rem 4rem; /* Increased horizontal padding to prevent tooltip cutoff */
    overflow-y: auto;
    flex-grow: 1;
}

.research-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    position: relative; /* Needed for tooltip positioning */
}

.research-icon {
    width: 80px;
    height: 80px;
    background-size: cover;
    border: 3px solid #8B4513;
    border-radius: 50%;
    position: relative;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    background-color: #d2b48c; /* tan background for icons */
}

.research-card.locked .research-icon {
    filter: grayscale(1);
    opacity: 0.6;
}
.research-card.researched .research-icon {
    border-color: #22c55e; /* green-500 */
    box-shadow: 0 0 10px #22c55e;
}

.research-icon:hover {
    transform: scale(1.1);
    box-shadow: 0 0 15px #f0e68c;
}

.research-icon:hover .research-tooltip {
    visibility: visible;
    opacity: 1;
    transform: translate(-50%, 0); /* Smooth transform for appearance */
}

.research-tooltip {
    visibility: hidden;
    opacity: 0;
    width: 240px; /* Increased width */
    background-color: #F5DEB3;
    color: #4a2c2a;
    text-align: left;
    border-radius: 6px;
    padding: 10px;
    position: absolute;
    z-index: 10;
    top: 110%; /* Position below the icon */
    left: 50%;
    transform: translate(-50%, -10px); /* Start slightly higher for transition */
    transition: opacity 0.3s, transform 0.3s;
    border: 2px solid #8B4513;
    box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    pointer-events: none; /* Allow clicks to pass through to the icon */
}
.research-tooltip::after {
    content: "";
    position: absolute;
    bottom: 100%; /* At the top of the tooltip */
    left: 50%;
    margin-left: -8px;
    border-width: 8px;
    border-style: solid;
    border-color: transparent transparent #8B4513 transparent; /* Arrow pointing up */
}

.tooltip-title { font-weight: bold; font-size: 1rem; color: #8B4513; border-bottom: 1px solid #d2b48c; padding-bottom: 4px; margin-bottom: 4px; }
.tooltip-desc { font-size: 0.8rem; margin: 4px 0; }
.tooltip-cost { font-size: 0.75rem; font-style: italic; }
.tooltip-req { font-size: 0.75rem; color: #dc2626; margin-top: 4px;}


.research-btn {
    width: 100%;
    padding: 4px 8px;
    font-size: 0.8rem;
}

.research-btn.completed {
    cursor: not-allowed;
    opacity: 0.6;
    background: #22c55e !important;
    color: white !important;
}
.research-btn.in-queue {
    cursor: not-allowed;
    opacity: 0.6;
    background: #f59e0b !important;
    color: white !important;
}
</file>

<file path="src/components/city/AcademyMenu.js">
import React, { useState, useEffect, useRef, useCallback } from 'react';
import researchConfig from '../../gameData/research.json';
import ResearchQueue from './ResearchQueue';
import './AcademyMenu.css';

const researchImages = {};
const imageContext = require.context('../../images/research', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '').replace('.png', '');
    researchImages[key] = imageContext(item);
});

const AcademyMenu = ({ cityGameState, onResearch, onClose, researchQueue, onCancelResearch }) => {
    const { buildings, resources, research = {}, researchPoints = 0 } = cityGameState;
    const academyLevel = buildings.academy?.level || 0;

    const academyRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 900) / 2,
        y: (window.innerHeight - 700) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('academy-header') || e.target.parentElement.classList.contains('academy-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);

    // #comment check if player can afford research
    const canAfford = (cost) => {
        return resources.wood >= cost.wood && resources.stone >= cost.stone && resources.silver >= cost.silver && researchPoints >= (cost.points || 0);
    };

    // #comment check if player meets research requirements, including items in the queue
    const meetsRequirements = (reqs) => {
        if (!reqs) return true;
        if (reqs.academy && academyLevel < reqs.academy) {
            return false;
        }
        if (reqs.research) {
            const isResearched = research[reqs.research];
            const isInQueue = (researchQueue || []).some(item => item.researchId === reqs.research);
            if (!isResearched && !isInQueue) {
                return false;
            }
        }
        return true;
    };

    // #comment generate a string of all unmet requirements for display
    const getRequirementsText = (reqs) => {
        if (!reqs) return '';
        const unmet = [];
        if (reqs.academy && academyLevel < reqs.academy) {
            unmet.push(`Academy Lvl ${reqs.academy}`);
        }
        if (reqs.research) {
            const isResearched = research[reqs.research];
            const isInQueue = (researchQueue || []).some(item => item.researchId === reqs.research);
            if (!isResearched && !isInQueue) {
                unmet.push(researchConfig[reqs.research].name);
            }
        }
        if (unmet.length > 0) {
            // #comment Join with <br /> for multi-line display
            return `Requires:<br />${unmet.join('<br />')}`;
        }
        return '';
    };

    // #comment check if research is already in queue
    const isResearchInQueue = (researchId) => {
        return (researchQueue || []).some(item => item.researchId === researchId);
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div 
                ref={academyRef}
                className="academy-container"
                onClick={e => e.stopPropagation()}
                onMouseDown={handleMouseDown}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="academy-header">
                    <h3>Academy (Level {academyLevel})</h3>
                    <p>Research Points: {researchPoints}</p>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="academy-grid">
                    {Object.entries(researchConfig).map(([id, config]) => {
                        const isResearched = cityGameState.research?.[id]?.completed;
                        const requirementsMet = meetsRequirements(config.requirements);
                        const affordable = canAfford(config.cost);
                        const inQueue = isResearchInQueue(id);
                        const isQueueFull = (researchQueue || []).length >= 5;
                        
                        const reqText = getRequirementsText(config.requirements);

                        let buttonText = 'Research';
                        let isDisabled = false;
                        if (isResearched) {
                            buttonText = 'Completed';
                            isDisabled = true;
                        } else if (inQueue) {
                            buttonText = 'In Queue';
                            isDisabled = true;
                        } else if (isQueueFull) {
                            buttonText = 'Queue Full';
                            isDisabled = true;
                        } else if (!requirementsMet) {
                            buttonText = 'Locked';
                            isDisabled = true;
                        } else if (!affordable) {
                            buttonText = 'No Resources';
                            isDisabled = true;
                        }
                        return (
                            <div key={id} className={`research-card ${isResearched ? 'researched' : ''} ${!requirementsMet ? 'locked' : ''}`}>
                                <div className="research-icon" style={{backgroundImage: `url(${researchImages[id]})`}}>
                                    <div className="research-tooltip">
                                        <h5 className="tooltip-title">{config.name}</h5>
                                        <p className="tooltip-desc">{config.description}</p>
                                        <div className="tooltip-cost">
                                            Cost: {config.cost.wood}W, {config.cost.stone}S, {config.cost.silver}Ag, {config.cost.points || 0}RP
                                        </div>
                                        {reqText && <p className="tooltip-req" dangerouslySetInnerHTML={{ __html: reqText }} />}
                                    </div>
                                </div>
                                <button
                                    onClick={() => onResearch(id)}
                                    disabled={isDisabled}
                                    className={`btn research-btn ${isResearched ? 'completed' : inQueue ? 'in-queue' : 'btn-primary'}`}
                                >
                                    {buttonText}
                                </button>
                            </div>
                        );
                    })}
                </div>
                <ResearchQueue researchQueue={researchQueue} onCancel={onCancelResearch} />
            </div>
        </div>
    );
};
export { AcademyMenu };
</file>

<file path="src/components/city/AdminCheatMenu.js">
// src/components/city/AdminCheatMenu.js
import React, { useState,  } from 'react';
import unitConfig from '../../gameData/units.json';
import researchConfig from '../../gameData/research.json'; // Import research config
import { useGame } from '../../contexts/GameContext';

const AdminCheatMenu = ({ onCheat, onClose, InstantBuildActive}) => {
    const [amounts, setAmounts] = useState({ wood: 0, stone: 0, silver: 0});
    const [troop, setTroop] = useState({ unit: 'swordsman', amount: 0 });
    const [warehouseLevels, setWarehouseLevels] = useState(0);
    const {isInstantBuild, setIsInstantBuild, isInstantResearch, setIsInstantResearch, isInstantUnits, setIsInstantUnits } = useGame();
    const [unresearchId, setUnresearchId] = useState(''); // New state for unresearch
    const [favorAmount, setFavorAmount] = useState(0); // #comment Re-added favor cheat state
    const [farmLevels, SetFarmLevel] = useState(0);
    
    

    const handleCheat = () => {
        onCheat(amounts, troop, farmLevels, warehouseLevels, isInstantBuild, unresearchId, isInstantResearch, isInstantUnits, favorAmount, false); // #comment Pass false for foundSecondCity
        onClose();
    };

    // #comment Handler for the new "Found Second City" button
    const handleFoundCity = () => {
        onCheat({}, {}, 0, false, '', false, false, 0, true); // #comment Pass true only for foundSecondCity
        onClose();
    };

    // #comment Handler for the "Force Refresh Data" button
    const handleForceRefresh = () => {
        onCheat({}, {}, 0, false, '', false, false, 0, false, true); // Pass true for forceRefresh
        onClose();
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border-2 border-gray-600" onClick={e => e.stopPropagation()}>
                <h3 className="font-title text-2xl text-white mb-4">Admin Cheats</h3>
                <div className="space-y-4">
                    {Object.keys(amounts).map(resource => (
                        <div key={resource} className="flex justify-between items-center">
                            <label className="text-white capitalize">{resource}</label>
                            <input
                                type="number"
                                value={amounts[resource]}
                                onChange={(e) => setAmounts(prev => ({ ...prev, [resource]: parseInt(e.target.value, 10) || 0 }))}
                                className="bg-gray-700 text-white rounded p-2 w-32"
                            />
                        </div>
                    ))}
                    <div className="flex justify-between items-center">
                        <label className="text-white capitalize">Add Troops</label>
                        <select
                            value={troop.unit}
                            onChange={(e) => setTroop(prev => ({ ...prev, unit: e.target.value }))}
                            className="bg-gray-700 text-white rounded p-2 w-32"
                        >
                            {Object.keys(unitConfig).map(unitId => (
                                <option key={unitId} value={unitId}>{unitConfig[unitId].name}</option>
                            ))}
                        </select>
                        <input
                            type="number"
                            value={troop.amount}
                            onChange={(e) => setTroop(prev => ({ ...prev, amount: parseInt(e.target.value, 10) || 0 }))}
                            className="bg-gray-700 text-white rounded p-2 w-24"
                        />
                    </div>
                    <div className="flex justify-between items-center">
                        <label className="text-white capitalize">Set Warehouse Level</label>
                        <input
                            type="number"
                            min="1"
                            value={warehouseLevels}
                            onChange={(e) => setWarehouseLevels(parseInt(e.target.value, 10) || 0)}
                            className="bg-gray-700 text-white rounded p-2 w-32" 
                        />
                    </div>
                    <div className="flex justify-between items-center">
                        <label className="text-white capitalize">Set Farm Level</label>
                        <input
                            type="number"
                            min="1"
                            value={farmLevels}
                            onChange={(e) => SetFarmLevel(parseInt(e.target.value, 10) || 0)}
                            className="bg-gray-700 text-white rounded p-2 w-32" 
                        />
                    </div>
                    {/* New Cheat: Unresearch Option */}
                    <div className="flex justify-between items-center pt-4 border-t border-gray-600">
                        <label htmlFor="unresearch" className="text-white">Unresearch:</label>
                        <select
                            id="unresearch"
                            value={unresearchId}
                            onChange={(e) => setUnresearchId(e.target.value)}
                            className="bg-gray-700 text-white rounded p-2 w-40"
                        >
                            <option value="">Select Research</option>
                            {Object.keys(researchConfig).map(researchKey => (
                                <option key={researchKey} value={researchKey}>
                                    {researchConfig[researchKey].name}
                                </option>
                            ))}
                        </select>
                    </div>
                    {/* #comment Re-added favor cheat option */}
                    <div className="flex justify-between items-center">
                        <label htmlFor="addFavor" className="text-white">Add Favor:</label>
                        <input
                            id="addFavor"
                            type="number"
                            value={favorAmount}
                            onChange={(e) => setFavorAmount(parseInt(e.target.value, 10) || 0)}
                            className="bg-gray-700 text-white rounded p-2 w-32"
                        />
                    </div>
                    {/* New Checkbox for Instant Build */}
                    <div className="flex justify-between items-center pt-4 border-t border-gray-600">
                        <label htmlFor="isInstantBuild" className="text-white capitalize">1-Second Builds</label>
                        <input
                            id="isInstantBuild"
                            type="checkbox"
                            checked={isInstantBuild}
                            onChange={(e) => setIsInstantBuild(e.target.checked)}
                            className="w-6 h-6 rounded"
                        />
                    </div>
                    {/* New Checkbox for Instant Research */}
                    <div className="flex justify-between items-center">
                        <label htmlFor="isInstantResearch" className="text-white capitalize">1-Second Research</label>
                        <input
                            id="isInstantResearch"
                            type="checkbox"
                            checked={isInstantResearch}
                            onChange={(e) => setIsInstantResearch(e.target.checked)}
                            className="w-6 h-6 rounded"
                        />
                    </div>
                    {/* New Checkbox for Instant Units */}
                    <div className="flex justify-between items-center">
                        <label htmlFor="isInstantUnits" className="text-white capitalize">1-Second Units</label>
                        <input
                            id="isInstantUnits"
                            type="checkbox"
                            checked={isInstantUnits}
                            onChange={(e) => setIsInstantUnits(e.target.checked)}
                            className="w-6 h-6 rounded"
                        />
                    </div>
                </div>
                <button onClick={handleFoundCity} className="btn btn-primary w-full py-2 mt-4 bg-yellow-600 hover:bg-yellow-500">
                    Found Second City
                </button>
                <button onClick={handleCheat} className="btn btn-primary w-full py-2 mt-2">
                    Apply Cheats
                </button>
                <button onClick={handleForceRefresh} className="btn btn-secondary w-full py-2 mt-2 bg-blue-600 hover:bg-blue-500">
                    Force Refresh Data
                </button>
            </div>
        </div>
    );
};

export default AdminCheatMenu;
</file>

<file path="src/components/city/BarracksMenu.css">
/* src/components/city/BarracksMenu.css */
.barracks-container {
    position: fixed;
    z-index: 50;
}

.barracks-header {
    cursor: move;
}

.unit-stats-container {
    background-color: #2D3748; /* Darker background for the stats panel */
    padding: 1rem;
    border-radius: 0.5rem;
}

.unit-stats-title {
    color: #F6E05E; /* Yellowish title */
    font-weight: bold;
    font-size: 1.25rem;
    margin-bottom: 0.75rem;
}

.unit-stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.5rem;
}

.unit-stats-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.25rem 0;
}

.unit-stats-label {
    font-size: 0.875rem;
    color: #A0AEC0; /* Lighter gray for labels */
}

.unit-stats-value {
    font-weight: bold;
    color: #E2E8F0; /* Off-white for values */
}
</file>

<file path="src/components/city/BarracksMenu.js">
import React, { useState, useEffect, useMemo, useRef, useCallback } from 'react';
import unitConfig from '../../gameData/units.json';
import UnitQueue from './UnitQueue';
import Modal from '../shared/Modal';
import { getTrainableUnits } from '../../utils/nationality';

const unitImages = {};
const imageContext = require.context('../../images/troops', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    unitImages[key] = imageContext(item);
});

// #comment A component to display unit stats in a clean, consistent way
const UnitStats = ({ unit }) => (
    <div className="w-1/2 bg-gray-900 p-4 rounded-lg space-y-2">
        <h5 className="font-bold text-lg text-yellow-300 mb-3">Unit Information</h5>
        <div className="flex items-center justify-between text-sm"><span>⚔️ Attack</span><span className="font-bold">{unit.attack}</span></div>
        <div className="flex items-center justify-between text-sm"><span>🛡️ Defense</span><span className="font-bold">{unit.defense}</span></div>
        <div className="flex items-center justify-between text-sm"><span>🐎 Speed</span><span className="font-bold">{unit.speed}</span></div>
    </div>
);

const BarracksMenu = ({ resources, availablePopulation, onTrain, onFire, onClose, cityGameState, unitQueue, onCancelTrain }) => {
    const [activeTab, setActiveTab] = useState('train');
    const barracksRef = useRef(null);
    const [position, setPosition] = useState({
        x: (window.innerWidth - 1000) / 2,
        y: (window.innerHeight - 700) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('barracks-header') || e.target.parentElement.classList.contains('barracks-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);

    const landUnits = useMemo(() => getTrainableUnits(cityGameState.playerInfo.nation).filter(id => !unitConfig[id].passive), [cityGameState.playerInfo.nation]);
    const passiveUnits = useMemo(() => Object.keys(unitConfig).filter(id => unitConfig[id].passive && unitConfig[id].type === 'land'), []);

    const [selectedUnitId, setSelectedUnitId] = useState(landUnits[0] || passiveUnits[0] || null);
    const [trainAmount, setTrainAmount] = useState('');
    const [fireAmounts, setFireAmounts] = useState({});

    useEffect(() => {
        setTrainAmount('');
    }, [selectedUnitId]);

    const cityUnits = cityGameState?.units || {};

    if (landUnits.length === 0 && passiveUnits.length === 0) {
        return (
            <Modal message="Your nation has no specific land units that can be trained in the Barracks." onClose={onClose} />
        );
    }

    const selectedUnit = selectedUnitId ? unitConfig[selectedUnitId] : null;
    const barracksUnitQueue = (unitQueue || []).filter(item => unitConfig[item.unitId]?.type === 'land' && !unitConfig[item.unitId]?.mythical);
    const numericTrainAmount = parseInt(trainAmount, 10) || 0;

    const totalCost = {
        wood: selectedUnit ? selectedUnit.cost.wood * numericTrainAmount : 0,
        stone: selectedUnit ? selectedUnit.cost.stone * numericTrainAmount : 0,
        silver: selectedUnit ? selectedUnit.cost.silver * numericTrainAmount : 0,
        population: selectedUnit ? selectedUnit.cost.population * numericTrainAmount : 0,
    };

    const canAfford = resources.wood >= totalCost.wood &&
                    resources.stone >= totalCost.stone &&
                    resources.silver >= totalCost.silver &&
                    availablePopulation >= totalCost.population;

    const handleTrain = () => {
        const amount = parseInt(trainAmount, 10) || 0;
        if (amount > 0) onTrain(selectedUnitId, amount);
    };

    const handleFireAmountChange = (unitId, value) => {
        const max = cityUnits[unitId] || 0;
        const amount = Math.max(0, Math.min(max, parseInt(value, 10) || 0));
        setFireAmounts(prev => ({ ...prev, [unitId]: amount }));
    };

    const handleFire = () => {
        const unitsToFire = Object.entries(fireAmounts).filter(([, amount]) => amount > 0);
        if (unitsToFire.length > 0) {
            if (typeof onFire === 'function') {
                onFire(Object.fromEntries(unitsToFire));
                setFireAmounts({});
            } else {
                console.error("BarracksMenu Error: onFire prop is not a function. It was not passed from the parent component.");
            }
        }
    };

    const renderUnitButton = (unitId) => {
        const unit = unitConfig[unitId];
        const isSelected = selectedUnitId === unitId;
        return (
            <button
                key={unitId}
                onClick={() => setSelectedUnitId(unitId)}
                className={`flex items-center p-2 rounded border-2 transition-colors w-full ${isSelected ? 'bg-gray-600 border-yellow-500' : 'bg-gray-700 border-gray-600 hover:border-yellow-400'}`}
            >
                <img src={unitImages[unit.image]} alt={unit.name} className="w-12 h-12 mr-3 object-contain" />
                <div>
                    <p className="font-bold text-left text-white">{unit.name}</p>
                    <p className="text-sm text-left text-gray-400">In City: {cityUnits[unitId] || 0}</p>
                </div>
            </button>
        );
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div
                ref={barracksRef}
                className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-4xl border-2 border-gray-600 flex flex-col max-h-[90vh] barracks-container"
                onClick={e => e.stopPropagation()}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="flex justify-between items-center mb-4 barracks-header" onMouseDown={handleMouseDown}>
                    <h3 className="font-title text-3xl text-white">Barracks</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                <div className="flex border-b border-gray-700 mb-4">
                    <button onClick={() => setActiveTab('train')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'train' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Train</button>
                    <button onClick={() => setActiveTab('fire')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'fire' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Dismiss</button>
                </div>
                {activeTab === 'train' && selectedUnit && (
                    <div className="flex-grow flex gap-4 overflow-y-auto">
                        <div className="w-1/3 flex flex-col gap-2">
                            {landUnits.map(renderUnitButton)}
                            {passiveUnits.length > 0 && <h4 className="font-bold text-center text-white mt-4">Passive Units</h4>}
                            {passiveUnits.map(renderUnitButton)}
                        </div>
                        <div className="w-2/3 flex flex-col gap-4">
                            <div className="bg-gray-700 p-4 rounded-lg">
                                <h4 className="font-title text-2xl text-yellow-400">{selectedUnit.name}</h4>
                                <p className="text-gray-400 italic mt-1">{selectedUnit.description}</p>
                            </div>
                            <div className="flex gap-4">
                                <div className="w-1/2 bg-gray-900 p-4 rounded-lg space-y-1">
                                    <h5 className="font-bold text-lg text-yellow-300 mb-2">Cost (Total)</h5>
                                    <p className="text-sm text-gray-300">Wood: {selectedUnit.cost.wood} ({totalCost.wood})</p>
                                    <p className="text-sm text-gray-300">Stone: {selectedUnit.cost.stone} ({totalCost.stone})</p>
                                    <p className="text-sm text-gray-300">Silver: {selectedUnit.cost.silver} ({totalCost.silver})</p>
                                    <p className="text-sm text-gray-300">Population: {selectedUnit.cost.population} ({totalCost.population})</p>
                                    <p className="text-sm text-gray-300">Time per unit: {selectedUnit.cost.time}s</p>
                                </div>
                                <UnitStats unit={selectedUnit} />
                            </div>
                            <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                                <input
                                    type="number"
                                    value={trainAmount}
                                    onChange={(e) => {
                                        const val = e.target.value;
                                        if (val === '' || (parseInt(val) >= 0 && !val.includes('.'))) {
                                            setTrainAmount(val);
                                        }
                                    }}
                                    className="bg-gray-800 text-white rounded p-2 w-24"
                                    placeholder="0"
                                />
                                <button
                                    onClick={handleTrain}
                                    disabled={!canAfford || numericTrainAmount === 0 || (barracksUnitQueue || []).length >= 5}
                                    className={`py-2 px-6 text-lg rounded-lg btn ${(canAfford && numericTrainAmount > 0 && (barracksUnitQueue || []).length < 5) ? 'btn-confirm' : 'btn-disabled'}`}
                                >
                                    {(barracksUnitQueue || []).length >= 5 ? 'Queue Full' : 'Train'}
                                </button>
                            </div>
                        </div>
                    </div>
                )}
                {activeTab === 'fire' && (
                    <div className="flex-grow overflow-y-auto pr-2">
                        <h4 className="text-xl font-semibold text-yellow-400 mb-2">Dismiss Units</h4>
                        {Object.keys(cityUnits).filter(id => unitConfig[id].type === 'land').length > 0 ? (
                            <div className="space-y-3">
                                {Object.entries(cityUnits).filter(([id]) => unitConfig[id].type === 'land').map(([unitId, count]) => {
                                    const unit = unitConfig[unitId];
                                    return (
                                        <div key={unitId} className="bg-gray-700 p-3 rounded-lg flex items-center justify-between">
                                            <div className="flex items-center gap-4">
                                                <img src={unitImages[unit.image]} alt={unit.name} className="w-12 h-12 object-contain" />
                                                <div>
                                                    <p className="font-bold text-white">{unit.name}</p>
                                                    <p className="text-sm text-gray-400">In City: {count}</p>
                                                </div>
                                            </div>
                                            <input
                                                type="number"
                                                value={fireAmounts[unitId] || ''}
                                                onChange={(e) => handleFireAmountChange(unitId, e.target.value)}
                                                className="bg-gray-800 text-white rounded p-2 w-24 text-center"
                                                placeholder="Amount"
                                                max={count}
                                                min="0"
                                            />
                                        </div>
                                    );
                                })}
                                <div className="flex justify-end mt-4">
                                    <button
                                        onClick={handleFire}
                                        disabled={Object.values(fireAmounts).reduce((a, b) => a + b, 0) === 0}
                                        className="btn btn-danger py-2 px-6"
                                    >
                                        Dismiss Selected
                                    </button>
                                </div>
                            </div>
                        ) : (
                            <p className="text-gray-500 text-center py-8">No land units in the city to dismiss.</p>
                        )}
                    </div>
                )}
                <UnitQueue unitQueue={barracksUnitQueue} onCancel={(item) => onCancelTrain(item, 'barracks')} title="Land Unit Queue" />
            </div>
        </div>
    );
};
export default BarracksMenu;
</file>

<file path="src/components/city/BuildingDetailsModal.js">
import React from 'react';
import buildingConfig from '../../gameData/buildings.json';

const BuildingDetailsModal = ({ buildingId, buildingData, onClose, getProductionRates, getWarehouseCapacity, getFarmCapacity, onOpenBarracks, onOpenShipyard, onAddWorker, onRemoveWorker, availablePopulation, getMaxWorkerSlots, onOpenMarket }) => {
    const config = buildingConfig[buildingId];
    if (!config) return null;

    const nextLevel = buildingData.level + 1;
    const isProductionBuilding = ['timber_camp', 'quarry', 'silver_mine'].includes(buildingId);
    const workers = buildingData.workers || 0;
    const maxWorkers = isProductionBuilding ? getMaxWorkerSlots(buildingData.level) : 0;

    const handleAddWorker = () => {
        if (availablePopulation >= 20) {
            onAddWorker(buildingId);
        } else {
            console.warn("Not enough available population. Each worker requires 20 population.");
        }
    };

    const getResourceType = (id) => {
        if (id === 'timber_camp') return 'wood';
        if (id === 'quarry') return 'stone';
        if (id === 'silver_mine') return 'silver';
        return '';
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border-2 border-gray-600" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-start mb-4">
                    <div>
                        <h3 className="font-title text-3xl text-white">{config.name}</h3>
                        <p className="text-yellow-300 font-bold text-lg">Level {buildingData.level}</p>
                    </div>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                <p className="text-gray-400 mt-2 mb-6">{config.description}</p>

                {isProductionBuilding && (
                    <div className="text-sm space-y-1 mb-6 text-gray-300">
                        <p className="font-semibold text-lg">Production (per hour):</p>
                        <p>Current: {getProductionRates({ [buildingId]: buildingData })[getResourceType(buildingId)].toLocaleString()}</p>
                        <p>Next Level: {getProductionRates({ [buildingId]: { level: nextLevel, workers: workers } })[getResourceType(buildingId)].toLocaleString()}</p>
                        <div className="mt-4 pt-4 border-t border-gray-700">
                            <h4 className="font-semibold text-lg mb-2">Worker Slots ({workers}/{maxWorkers})</h4>
                            <div className="flex items-center space-x-2">
                                {Array.from({ length: maxWorkers }).map((_, i) => (
                                    <div key={i} className={`w-10 h-10 rounded-full flex items-center justify-center ${i < workers ? 'bg-green-500' : 'bg-gray-600'}`}>
                                        {/* You can add an icon here if you want */}
                                    </div>
                                ))}
                                <div className="flex flex-col space-y-1">
                                     <button onClick={handleAddWorker} disabled={workers >= maxWorkers || availablePopulation < 20} className="w-6 h-6 flex items-center justify-center bg-gray-500 hover:bg-gray-400 rounded-md text-white font-bold text-lg disabled:opacity-50 disabled:cursor-not-allowed">+</button>
                                     <button onClick={() => onRemoveWorker(buildingId)} disabled={workers <= 0} className="w-6 h-6 flex items-center justify-center bg-red-600 hover:bg-red-500 rounded-md text-white font-bold text-lg disabled:opacity-50 disabled:cursor-not-allowed">-</button>
                                </div>
                            </div>
                            {/* #comment Updated text to reflect new happiness mechanic */}
                            <p className="text-xs mt-2 text-gray-400">Each worker costs 20 population, boosts production by 10%, and reduces city happiness by 5.</p>
                        </div>
                    </div>
                )}

                {buildingId === 'warehouse' && (
                    <div className="text-sm space-y-1 mb-6 text-gray-300">
                        <p className="font-semibold text-lg">Capacity:</p>
                        <p>Current: {getWarehouseCapacity(buildingData.level).toLocaleString()}</p>
                        <p>Next Level: {getWarehouseCapacity(nextLevel).toLocaleString()}</p>
                    </div>
                )}

                {buildingId === 'farm' && (
                    <div className="text-sm space-y-1 mb-6 text-gray-300">
                        <p className="font-semibold text-lg">Population Capacity:</p>
                        <p>Current: {getFarmCapacity(buildingData.level).toLocaleString()}</p>
                        <p>Next Level: {getFarmCapacity(nextLevel).toLocaleString()}</p>
                    </div>
                )}

                {buildingId === 'barracks' && (
                    <button onClick={onOpenBarracks} className="btn btn-primary w-full py-2">
                        Train Troops
                    </button>
                )}

                {buildingId === 'shipyard' && (
                    <button onClick={onOpenShipyard} className="btn btn-primary w-full py-2">
                        Build Naval Units
                    </button>
                )}
                
                {/* #comment Add button to open market from details view */}
                {buildingId === 'market' && (
                    <button onClick={onOpenMarket} className="btn btn-primary w-full py-2">
                        Open Market
                    </button>
                )}
            </div>
        </div>
    );
};

export default BuildingDetailsModal;
</file>

<file path="src/components/city/BuildingSpot.js">
// src/components/city/BuildingSpot.js
import React from 'react';

const BuildingSpot = ({ building, level, onClick, image }) => {
    const { id, name, position } = building;
    const isCityWall = id === 'city_wall';

    // Define styles based on whether it's the city wall or not
    const spotStyle = {
        top: `${position.y}px`,
        left: `${position.x}px`,
        width: isCityWall ? '2000px' : '200px',
        height: isCityWall ? '150px' : '150px', // Increased height for the wall
        backgroundImage: level > 0 && image ? `url(${image})` : 'none',
        backgroundSize: 'contain',
        backgroundRepeat: 'no-repeat',
        backgroundPosition: 'center',
    };

    if (level === 0) {
        return (
             <div
                className="building-spot absolute flex items-center justify-center p-2 rounded-lg cursor-pointer hover:bg-black/20"
                style={spotStyle}
                onClick={onClick}
                title={`Build ${name}`}
            >
                <span className="text-gray-400 text-sm">
                    {isCityWall ? `Build ${name}` : 'Empty Plot'}
                </span>
            </div>
        );
    }

    return (
        <div
            className="building-spot absolute flex flex-col items-center justify-center p-2 rounded-lg transition-colors duration-200 cursor-pointer"
            style={{
                ...spotStyle,
                backgroundColor: image ? 'transparent' : 'rgba(139, 69, 19, 0.7)', // If there's an image, the background is transparent.
            }}
            onClick={onClick}
        >
        </div>
    );
};

export default BuildingSpot;
</file>

<file path="src/components/city/BuildQueue.js">
import React, { useState, useEffect, useRef } from 'react';
import buildingConfig from '../../gameData/buildings.json';
import specialBuildingsConfig from '../../gameData/specialBuildings.json';
const buildingImages = {};
const contexts = [
    require.context('../../images/buildings', false, /\.(png|jpe?g|svg)$/),
    require.context('../../images/special_buildings', false, /\.(png|jpe?g|svg)$/)
];
contexts.forEach(context => {
    context.keys().forEach((item) => {
        const key = item.replace('./', '');
        buildingImages[key] = context(item);
    });
});
const formatTime = (seconds) => {
    if (seconds < 0) seconds = 0;
    const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
    const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
    const s = Math.floor(seconds % 60).toString().padStart(2, '0');
    return `${h}:${m}:${s}`;
};
const QueueItem = ({ item, isFirst, onCancel, isLast, onHover, onLeave, hoveredItem }) => {
    const [timeLeft, setTimeLeft] = useState(0);
    useEffect(() => {
        if (!isFirst) return;
        const calculateTimeLeft = () => {
            const endTime = (item.endTime instanceof Date) ? item.endTime : new Date(item.endTime);
            if (isNaN(endTime.getTime())) {
                setTimeLeft(0);
                return;
            }
            const remaining = Math.max(0, endTime.getTime() - Date.now());
            setTimeLeft(remaining / 1000);
        };
        calculateTimeLeft();
        const interval = setInterval(calculateTimeLeft, 1000);
        return () => clearInterval(interval);
    }, [item.endTime, isFirst]);
    const building = item.isSpecial
        ? specialBuildingsConfig[item.buildingId]
        : buildingConfig[item.buildingId];
    if (!building) return null;
    const imageSrc = buildingImages[building.image];
    const isDemolition = item.type === 'demolish';
    const title = isDemolition
        ? `Demolish ${building.name} to Lvl ${item.level}`
        : `${building.name} (Level ${item.level})`;
    const levelText = isDemolition ? ` Lvl ${item.level}` : `^${item.level}`;
    return (
        <div
            className={`relative w-16 h-16 bg-gray-700 border-2 rounded-md flex-shrink-0 ${isDemolition ? 'border-red-500' : 'border-gray-600'}`}
            title={title}
            onMouseEnter={() => onHover(item.id)}
            onMouseLeave={onLeave}
        >
            <img src={imageSrc} alt={building.name} className="w-full h-full object-contain p-1" />
             <span className={`absolute top-0 right-0 text-black text-xs font-bold px-1 rounded-bl-md z-10 ${isDemolition ? 'bg-red-500 text-white' : 'bg-yellow-500'}`}>
                {levelText}
            </span>
            {isFirst && (
                <span className="absolute bottom-0 left-0 right-0 bg-black bg-opacity-75 text-red-500 text-xs text-center py-0.5 font-mono">
                    {formatTime(timeLeft)}
                </span>
            )}
            {isLast && (
                <button
                    onClick={onCancel}
                    className="absolute -top-2 -right-2 w-5 h-5 flex items-center justify-center bg-red-600 text-white rounded-full font-bold text-xs hover:bg-red-500 transition-colors z-10"
                    title="Cancel Construction"
                >
                    &times;
                </button>
            )}
            {hoveredItem === item.id && (
                 <div className="unit-tooltip" style={{ top: '50%', left: '100%', transform: 'translate(10px, -50%)', zIndex: 100, width: '200px', pointerEvents: 'none' }}>
                    <div className="tooltip-header"><h3 className="tooltip-title">{building.name}</h3></div>
                    <div className="tooltip-body" style={{ padding: '0.5rem' }}>
                        <p className="tooltip-description" style={{ fontSize: '0.75rem' }}>{building.description}</p>
                    </div>
                </div>
            )}
        </div>
    );
};
const BuildQueue = ({ buildQueue, onCancel }) => {
    const [hoveredItem, setHoveredItem] = useState(null);
    const tooltipTimeoutRef = useRef(null);
    const queueCapacity = 5;
    const emptySlots = Array(Math.max(0, queueCapacity - (buildQueue?.length || 0))).fill(null);
    const handleMouseEnter = (itemId) => {
        clearTimeout(tooltipTimeoutRef.current);
        setHoveredItem(itemId);
    };
    const handleMouseLeave = () => {
        tooltipTimeoutRef.current = setTimeout(() => {
            setHoveredItem(null);
        }, 200);
    };
    return (
        <div className="bg-gray-900 p-2 rounded-lg mb-4 flex items-center gap-3 border border-gray-700">
            <div className="w-16 h-16 bg-gray-700 rounded-lg flex items-center justify-center text-4xl flex-shrink-0" title="Construction">
                🔨
            </div>
            <div className="flex-grow flex items-center gap-3">
                {buildQueue && buildQueue.map((item, index) => (
                    <QueueItem
                        key={item.id || `${item.buildingId}-${index}`}
                        item={item}
                        isFirst={index === 0}
                        isLast={index === buildQueue.length - 1}
                        onCancel={() => onCancel(item)}
                        onHover={handleMouseEnter}
                        onLeave={handleMouseLeave}
                        hoveredItem={hoveredItem}
                    />
                ))}
                {emptySlots.map((_, index) => (
                    <div key={`empty-${index}`} className="w-16 h-16 bg-gray-800 border-2 border-dashed border-gray-600 rounded-md flex items-center justify-center flex-shrink-0">
                        <img src={buildingImages['temple.png']} alt="Empty Slot" className="w-10 h-10 opacity-20" />
                    </div>
                ))}
            </div>
        </div>
    );
};
export default BuildQueue;
</file>

<file path="src/components/city/CaveMenu.css">
/* src/components/city/CaveMenu.css */
.cave-menu-container {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F); /* saddlebrown to peru */
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a;
    width: 90%;
    max-width: 500px;
    height: 70vh;
    display: flex;
    flex-direction: column;
    position: fixed;
    z-index: 50;
}

.cave-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1.5rem;
    background-color: #1e3a8a;
    color: #f0e68c;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.5rem;
    border-bottom: 2px solid #cd853f;
    cursor: move;
}

.cave-header .close-btn {
    background: none;
    border: none;
    color: #f0e68c;
    font-size: 2.5rem;
    cursor: pointer;
    line-height: 1;
}

.cave-content-panel {
    flex-grow: 1;
    overflow-y: auto;
}
</file>

<file path="src/components/city/CaveMenu.js">
import React, { useState, useEffect, useRef, useCallback } from 'react';
import Modal from '../shared/Modal'; // Assuming you have a Modal component
import buildingConfig from '../../gameData/buildings.json';
import { useAlliance } from '../../contexts/AllianceContext';

const CaveMenu = ({ cityGameState, onClose, saveGameState, currentUser, worldId }) => {
    const [depositAmount, setDepositAmount] = useState('');
    const [withdrawAmount, setWithdrawAmount] = useState('');
    const [message, setMessage] = useState('');
    const { playerAlliance } = useAlliance();

    const caveRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 500) / 2,
        y: (window.innerHeight - 700) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('cave-header') || e.target.parentElement.classList.contains('cave-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);


    console.log("CaveMenu rendered. cityGameState:", cityGameState); // Debugging

    if (!cityGameState) {
        console.log("CaveMenu: cityGameState is null, showing loading modal."); // Debugging
        return <Modal message="Loading city data..." onClose={onClose} />;
    }

    const caveLevel = cityGameState.buildings.cave?.level || 0;
    const maxCaveLevel = buildingConfig.cave.maxLevel;
    
    let maxSilverStorage = caveLevel === maxCaveLevel ? Infinity : caveLevel * 1000;
    if (playerAlliance?.research) {
        const caveBoostLevel = playerAlliance.research.subterranean_expansion?.level || 0;
        if (maxSilverStorage !== Infinity) {
            maxSilverStorage *= (1 + caveBoostLevel * 0.05);
        }
    }
    maxSilverStorage = Math.floor(maxSilverStorage);

    const currentSilverInCave = cityGameState.cave?.silver || 0;

    const handleDeposit = async () => {
        const amount = parseInt(depositAmount, 10);
        if (isNaN(amount) || amount <= 0) {
            setMessage('Please enter a valid amount to deposit.');
            return;
        }

        if (cityGameState.resources.silver < amount) {
            setMessage('Not enough silver in your city to deposit.');
            return;
        }

        if (currentSilverInCave + amount > maxSilverStorage) {
            setMessage(`Cannot deposit. Cave storage limit is ${maxSilverStorage.toLocaleString()}.`);
            return;
        }

        try {
            const newGameState = { ...cityGameState };
            newGameState.resources.silver -= amount;
            newGameState.cave.silver = currentSilverInCave + amount;
            
            await saveGameState(newGameState);
            setMessage(`Successfully deposited ${amount} silver.`);
            setDepositAmount('');
        } catch (error) {
            console.error("Error depositing silver: ", error);
            setMessage('Failed to deposit silver. Please try again.');
        }
    };

    const handleWithdraw = async () => {
        const amount = parseInt(withdrawAmount, 10);
        if (isNaN(amount) || amount <= 0) {
            setMessage('Please enter a valid amount to withdraw.');
            return;
        }

        if (currentSilverInCave < amount) {
            setMessage('Not enough silver in the cave to withdraw.');
            return;
        }

        try {
            const newGameState = { ...cityGameState };
            newGameState.resources.silver += amount;
            newGameState.cave.silver = currentSilverInCave - amount;

            await saveGameState(newGameState);
            setMessage(`Successfully withdrew ${amount} silver.`);
            setWithdrawAmount('');
        } catch (error) {
            console.error("Error withdrawing silver: ", error);
            setMessage('Failed to withdraw silver. Please try again.');
        }
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div
                ref={caveRef}
                className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-white cave-menu-container"
                onClick={e => e.stopPropagation()}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="flex justify-between items-center mb-4 cave-header" onMouseDown={handleMouseDown}>
                    <h2 className="text-2xl font-bold text-yellow-400">Cave (Lvl {caveLevel})</h2>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                <div className="p-4 bg-gray-800 text-white rounded-lg shadow-lg">
                    <p className="text-center mb-4">
                        Silver in Cave: <span className="font-semibold text-green-400">{currentSilverInCave.toLocaleString()}</span> / <span className="font-semibold text-blue-400">{maxSilverStorage === Infinity ? '∞' : maxSilverStorage.toLocaleString()}</span>
                    </p>
                    {message && (
                        <p className="mt-4 p-2 bg-blue-700 text-white rounded text-center">
                            {message}
                        </p>
                    )}
                    <div className="mb-6">
                        <h3 className="text-xl font-semibold mb-2 text-yellow-300">Deposit Silver</h3>
                        <input
                            type="number"
                            value={depositAmount}
                            onChange={(e) => setDepositAmount(e.target.value)}
                            placeholder="Amount to deposit"
                            className="w-full p-2 mb-2 rounded bg-gray-700 border border-gray-600 text-white placeholder-gray-400"
                        />
                        <button
                            onClick={handleDeposit}
                            className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 ease-in-out shadow-md"
                        >
                            Deposit
                        </button>
                    </div>

                    <div className="mb-6">
                        <h3 className="text-xl font-semibold mb-2 text-yellow-300">Withdraw Silver</h3>
                        <input
                            type="number"
                            value={withdrawAmount}
                            onChange={(e) => setWithdrawAmount(e.target.value)}
                            placeholder="Amount to withdraw"
                            className="w-full p-2 mb-2 rounded bg-gray-700 border border-gray-600 text-white placeholder-gray-400"
                        />
                        <button
                            onClick={handleWithdraw}
                            className="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 ease-in-out shadow-md"
                        >
                            Withdraw
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default CaveMenu;
</file>

<file path="src/components/city/CityModals.js">
import React from 'react';
import AdminCheatMenu from './AdminCheatMenu';
import BarracksMenu from './BarracksMenu';
import ShipyardMenu from './ShipyardMenu';
import BuildingDetailsModal from './BuildingDetailsModal';
import SenateView from './SenateView';
import TempleMenu from './TempleMenu';
import CaveMenu from './CaveMenu';
import HospitalMenu from './HospitalMenu';
import MarketMenu from './MarketMenu';
import { AcademyMenu } from './AcademyMenu';
import DivineTempleMenu from './DivineTempleMenu';
import SpecialBuildingMenu from './SpecialBuildingMenu';
import SpecialBuildingPanel from './SpecialBuildingPanel';
import HeroesAltar from './HeroesAltar';
import PrisonMenu from './PrisonMenu';

const CityModals = ({
  cityGameState,
  worldId,
  currentUser,
  userProfile,
  isInstantBuild,
  getUpgradeCost,
  getFarmCapacity,
  getWarehouseCapacity,
  getHospitalCapacity,
  getProductionRates,
  calculateUsedPopulation,
  saveGameState,
  handleUpgrade,
  handleCancelBuild,
  handleTrainTroops,
  handleCancelTrain,
  handleFireTroops,
  handleStartResearch,
  handleCancelResearch,
  handleWorshipGod,
  handleCheat,
  handleHealTroops,
  handleCancelHeal,
  availablePopulation,
  modalState,
  openModal,
  closeModal,
  setMessage,
  onAddWorker,
  onRemoveWorker,
  getMaxWorkerSlots,
  getMarketCapacity,
  handleBuildSpecialBuilding,
  handleDemolish,
  handleDemolishSpecialBuilding,
  handleSpawnGodTown,
  onRecruitHero,
  onActivateSkill,
  onAssignHero,
  onUnassignHero,
  onApplyWorkerPreset,
  onReleaseHero,
  onRecruitAgent,
  onAssignAgent,
  movements,
}) => {
  const {
    selectedBuildingId,
    isSenateViewOpen,
    isBarracksMenuOpen,
    isShipyardMenuOpen,
    isTempleMenuOpen,
    isCaveMenuOpen,
    isAcademyMenuOpen,
    isHospitalMenuOpen,
    isCheatMenuOpen,
    isMarketMenuOpen,
    isDivineTempleMenuOpen,
    isSpecialBuildingMenuOpen,
    isSpecialBuildingPanelOpen,
    isHeroesAltarOpen,
    isPrisonMenuOpen,
  } = modalState;

  if (!cityGameState) return null;

  const marketCapacity = getMarketCapacity(cityGameState.buildings?.market?.level);

  return (
    <>
      {selectedBuildingId && (
        <BuildingDetailsModal
          buildingId={selectedBuildingId}
          buildingData={cityGameState.buildings[selectedBuildingId]}
          onClose={() => closeModal('selectedBuildingId')}
          getProductionRates={getProductionRates}
          getWarehouseCapacity={getWarehouseCapacity}
          getFarmCapacity={getFarmCapacity}
          onOpenBarracks={() => { closeModal('selectedBuildingId'); openModal('isBarracksMenuOpen'); }}
          onOpenShipyard={() => { closeModal('selectedBuildingId'); openModal('isShipyardMenuOpen'); }}
          onOpenMarket={() => { closeModal('selectedBuildingId'); openModal('isMarketMenuOpen'); }}
          onAddWorker={onAddWorker}
          onRemoveWorker={onRemoveWorker}
          availablePopulation={availablePopulation}
          getMaxWorkerSlots={getMaxWorkerSlots}
        />
      )}
      {isSenateViewOpen && (
        <SenateView
          buildings={cityGameState.buildings}
          resources={cityGameState.resources}
          onUpgrade={handleUpgrade}
          onDemolish={handleDemolish}
          getUpgradeCost={getUpgradeCost}
          onClose={() => closeModal('isSenateViewOpen')}
          usedPopulation={calculateUsedPopulation(cityGameState)}
          maxPopulation={getFarmCapacity(cityGameState.buildings?.farm?.level)}
          buildQueue={cityGameState.buildQueue}
          onCancelBuild={handleCancelBuild}
          cityGameState={cityGameState}
          onOpenSpecialBuildingMenu={() => openModal('isSpecialBuildingMenuOpen')}
          onDemolishSpecialBuilding={handleDemolishSpecialBuilding}
          currentUser={currentUser}
          worldId={worldId}
          setMessage={setMessage}
          onAddWorker={onAddWorker}
          onRemoveWorker={onRemoveWorker}
          getMaxWorkerSlots={getMaxWorkerSlots}
          availablePopulation={availablePopulation}
          onApplyWorkerPreset={onApplyWorkerPreset}
        />
      )}
      {isBarracksMenuOpen && (
        <BarracksMenu
          resources={cityGameState.resources}
          availablePopulation={availablePopulation}
          onTrain={handleTrainTroops}
          onFire={handleFireTroops}
          onClose={() => closeModal('isBarracksMenuOpen')}
          cityGameState={cityGameState}
          unitQueue={cityGameState.barracksQueue}
          onCancelTrain={(item) => handleCancelTrain(item, 'barracks')}
        />
      )}
       {isDivineTempleMenuOpen && (
        <DivineTempleMenu
          resources={cityGameState.resources}
          availablePopulation={availablePopulation}
          onTrain={handleTrainTroops}
          onClose={() => closeModal('isDivineTempleMenuOpen')}
          unitQueue={cityGameState.divineTempleQueue}
          onCancelTrain={(item) => handleCancelTrain(item, 'divineTemple')}
          cityGameState={cityGameState}
        />
      )}
      {isShipyardMenuOpen && (
        <ShipyardMenu
          resources={cityGameState.resources}
          availablePopulation={availablePopulation}
          onTrain={handleTrainTroops}
          onClose={() => closeModal('isShipyardMenuOpen')}
          cityGameState={cityGameState}
          unitQueue={cityGameState.shipyardQueue}
          onCancelTrain={(item) => handleCancelTrain(item, 'shipyard')}
        />
      )}
      {isTempleMenuOpen && (
        <TempleMenu
          city={cityGameState}
          onWorship={handleWorshipGod}
          onClose={() => closeModal('isTempleMenuOpen')}
          favorData={cityGameState.worship || {}}
        />
      )}
      {isAcademyMenuOpen && (
        <AcademyMenu
          cityGameState={cityGameState}
          onResearch={handleStartResearch}
          onClose={() => closeModal('isAcademyMenuOpen')}
          researchQueue={cityGameState.researchQueue}
          onCancelResearch={handleCancelResearch}
        />
      )}
      {isCaveMenuOpen && (
        <CaveMenu
          cityGameState={cityGameState}
          onClose={() => closeModal('isCaveMenuOpen')}
          saveGameState={saveGameState}
          currentUser={currentUser}
          worldId={worldId}
        />
      )}
      {isHospitalMenuOpen && (
          <HospitalMenu
              cityGameState={cityGameState}
              onClose={() => closeModal('isHospitalMenuOpen')}
              onHeal={handleHealTroops}
              onCancelHeal={handleCancelHeal}
              getHospitalCapacity={getHospitalCapacity}
              availablePopulation={availablePopulation}
          />
      )}
      {isMarketMenuOpen && (
        <MarketMenu
            onClose={() => closeModal('isMarketMenuOpen')}
            cityGameState={cityGameState}
            worldId={worldId}
            marketCapacity={marketCapacity}
        />
      )}
      {isSpecialBuildingMenuOpen && (
          <SpecialBuildingMenu
            cityGameState={cityGameState}
            onBuild={handleBuildSpecialBuilding}
            onClose={() => closeModal('isSpecialBuildingMenuOpen')}
            availablePopulation={availablePopulation}
          />
      )}
      {isSpecialBuildingPanelOpen && (
        <SpecialBuildingPanel
            buildingId={cityGameState.specialBuilding}
            onClose={() => closeModal('isSpecialBuildingPanelOpen')}
            onDemolish={handleDemolishSpecialBuilding}
        />
      )}
      {isHeroesAltarOpen && (
        <HeroesAltar
            cityGameState={cityGameState}
            onRecruitHero={onRecruitHero}
            onActivateSkill={onActivateSkill}
            onClose={() => closeModal('isHeroesAltarOpen')}
            onAssignHero={onAssignHero}
            onUnassignHero={onUnassignHero}
            onRecruitAgent={onRecruitAgent}
            onAssignAgent={onAssignAgent}
            movements={movements}
        />
      )}
      {isPrisonMenuOpen && (
        <PrisonMenu
          cityGameState={cityGameState}
          onClose={() => closeModal('isPrisonMenuOpen')}
          onReleaseHero={onReleaseHero}
        />
      )}
      {isCheatMenuOpen && userProfile?.is_admin && (
        <AdminCheatMenu
          onCheat={handleCheat}
          onClose={() => closeModal('isCheatMenuOpen')}
          isInstantBuildActive={isInstantBuild}
          onSpawnGodTown={handleSpawnGodTown}
        />
      )}
    </>
  );
};
export default CityModals;
</file>

<file path="src/components/city/Cityscape.js">
import React from 'react';
import BuildingSpot from './BuildingSpot';
import SpecialBuildingPlot from './specialBuildingPlotpls';
import buildingLayout from '../../gameData/BuildingLayout.json';
import buildingConfig from '../../gameData/buildings.json';
import specialBuildingsConfig from '../../gameData/specialBuildings.json';
import cityBackground from '../../images/city_layout.png';
const Cityscape = ({ buildings, onBuildingClick, buildingImages, cityGameState, onOpenSpecialBuildingMenu }) => {
  return (
    <div
      style={{
        width: '2000px',
        height: '1700px',
        position: 'relative',
        backgroundImage: `url(${cityBackground})`,
        backgroundSize: 'cover',
        backgroundPosition: 'center',
      }}
    >
      {}
      {buildingLayout.map((building) => {
        if (building.id === 'special_building_plot') {
            if (!cityGameState) return null;
            const specialBuildingId = cityGameState.specialBuilding;
            const config = specialBuildingId ? specialBuildingsConfig[specialBuildingId] : buildingConfig.special_building_plot;
            const image = config?.image ? buildingImages[config.image] : null;
            return (
                <SpecialBuildingPlot
                    key={building.id}
                    building={building}
                    onClick={() => onBuildingClick(building.id)}
                    image={image}
                    name={config.name}
                    isConstructed={!!specialBuildingId}
                />
            );
        }
        const buildingData = buildings[building.id];
        const level = buildingData?.level || 0;
        const config = buildingConfig[building.id];
        return (
          <BuildingSpot
            key={building.id}
            building={building}
            level={level}
            onClick={() => onBuildingClick(building.id)}
            image={config?.image ? buildingImages[config.image] : null}
          />
        );
      })}
    </div>
  );
};
export default Cityscape;
</file>

<file path="src/components/city/CityViewContent.js">
// src/components/city/CityViewContent.js
import React, { useRef, useEffect, useCallback, useLayoutEffect, useState } from 'react';
import Cityscape from './Cityscape';
import SideInfoPanel from '../SideInfoPanel';
import buildingConfig from '../../gameData/buildings.json'; // Import building config

// #comment Dynamically import all building and special building images
const buildingImages = {};
const contexts = [
    require.context('../../images/buildings', false, /\.(png|jpe?g|svg)$/),
    require.context('../../images/special_buildings', false, /\.(png|jpe?g|svg)$/)
];

contexts.forEach(context => {
    context.keys().forEach((item) => {
        const key = item.replace('./', '');
        buildingImages[key] = context(item);
    });
});

const CITYSCAPE_WIDTH = 2000;
const CITYSCAPE_HEIGHT = 1700;

const CityViewContent = ({ cityGameState, handlePlotClick, onOpenPowers, gameSettings, onOpenSpecialBuildingMenu, movements }) => {
    // Panning Logic (moved from CityView.js)
    const viewportRef = useRef(null);
    const cityContainerRef = useRef(null);
    const [pan, setPan] = useState({ x: 0, y: 0 });
    const [isPanning, setIsPanning] = useState(false);
    const [startPos, setStartPos] = useState({ x: 0, y: 0 });

    const clampPan = useCallback((newPan) => {
        if (!viewportRef.current) return { x: 0, y: 0 };
        const { clientWidth, clientHeight } = viewportRef.current;
        const minX = clientWidth - CITYSCAPE_WIDTH;
        const minY = clientHeight - CITYSCAPE_HEIGHT;
        return {
            x: Math.max(minX, Math.min(0, newPan.x)),
            y: Math.max(minY, Math.min(0, newPan.y)),
        };
    }, []);

    useLayoutEffect(() => {
        if (!viewportRef.current) return;
        const { clientWidth, clientHeight } = viewportRef.current;
        setPan(clampPan({ x: (clientWidth - CITYSCAPE_WIDTH) / 2, y: (clientHeight - CITYSCAPE_HEIGHT) / 2 }));
    }, [clampPan]);

    useEffect(() => {
        const container = cityContainerRef.current;
        if (container) container.style.transform = `translate(${pan.x}px, ${pan.y}px)`;
    }, [pan]);

    const handleMouseDown = useCallback((e) => {
        if (e.button !== 0) return;
        e.preventDefault();
        setStartPos({ x: e.clientX - pan.x, y: e.clientY - pan.y });
        setIsPanning(true);
    }, [pan]);

    useEffect(() => {
        const handleMouseMove = (e) => {
            if (!isPanning) return;
            setPan(clampPan({ x: e.clientX - startPos.x, y: e.clientY - startPos.y }));
        };
        const handleMouseUp = () => setIsPanning(false);
        if (isPanning) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isPanning, startPos, clampPan]);

    if (!gameSettings.showVisuals) {
        return (
            <main className="flex-grow w-full h-full relative overflow-y-auto p-4">
                <h2 className="text-2xl font-bold mb-4">City Buildings</h2>
                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    {Object.entries(cityGameState.buildings).map(([id, data]) => {
                        if (data.level > 0) {
                            return (
                                <div key={id} className="bg-gray-800 p-3 rounded-lg cursor-pointer hover:bg-gray-700" onClick={() => handlePlotClick(id)}>
                                    <p className="font-bold text-lg text-yellow-400">{buildingConfig[id]?.name}</p>
                                    <p>Level {data.level}</p>
                                </div>
                            );
                        }
                        return null;
                    })}
                </div>
                 <SideInfoPanel 
                    gameState={cityGameState} 
                    className="absolute top-1/2 right-4 transform -translate-y-1/2 z-20" 
                    onOpenPowers={onOpenPowers}
                    movements={movements}
                />
            </main>
        );
    }

    return (
        <main className="flex-grow w-full h-full relative overflow-hidden cursor-grab" ref={viewportRef} onMouseDown={handleMouseDown}>
            <div ref={cityContainerRef} style={{ transformOrigin: '0 0' }}>
                <Cityscape 
                    buildings={cityGameState.buildings} 
                    onBuildingClick={handlePlotClick} 
                    buildingImages={buildingImages} 
                    cityGameState={cityGameState} 
                    onOpenSpecialBuildingMenu={onOpenSpecialBuildingMenu} 
                />
            </div>
            <SideInfoPanel 
                gameState={cityGameState} 
                className="absolute top-1/2 right-4 transform -translate-y-1/2 z-20 flex flex-col gap-4" 
                onOpenPowers={onOpenPowers}
                movements={movements}
            />
        </main>
    );
};

export default CityViewContent;
</file>

<file path="src/components/city/DivinePowers.css">
/* src/components/city/DivinePowers.css */
.divine-powers-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.divine-powers-modal-content {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a;
    padding: 20px;
    width: 90%;
    max-width: 600px;
    animation: fadeInScaleUp 0.3s ease-out forwards;
    position: fixed;
    z-index: 50;
}

/* #comment New styles for the menu version */
.divine-powers-menu-content {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3;
    border: 4px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 15px rgba(0,0,0,0.5);
    color: #4a2c2a;
    padding: 15px;
    width: 350px;
    max-height: 80vh;
    overflow-y: auto;
    animation: fadeInScaleUp 0.3s ease-out forwards;
}

.divine-powers-menu-content .divine-powers-header h2 {
    font-size: 1.5rem;
}


@keyframes fadeInScaleUp {
    from {
        opacity: 0;
        transform: scale(0.95);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

.divine-powers-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 10px;
    color: #4a2c2a;
    font-family: 'IM Fell English SC', serif;
    border-bottom: 2px solid #cd853f;
    cursor: move;
}

.divine-powers-header h2 {
    font-size: 2rem;
}

.close-button {
    background: none;
    border: none;
    color: #4a2c2a;
    font-size: 2rem;
    cursor: pointer;
}
.close-button:hover {
    color: #8B4513;
}

.powers-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
}

.power-card {
    background-color: rgba(139, 69, 19, 0.1); /* saddlebrown transparent */
    border: 1px solid #d2b48c; /* tan */
    border-radius: 8px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.power-card h3 {
    font-size: 1.25rem;
    color: #8B4513; /* saddlebrown */
    font-weight: bold;
    margin-bottom: 10px;
}

.power-card p {
    color: #4a2c2a;
    font-size: 0.9rem;
    flex-grow: 1;
}

.power-cost {
    color: #6b4a2b; /* darker brown */
    font-style: italic;
    margin-top: 15px;
}

.cast-spell-button {
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #4a2c2a;
    padding: 10px 15px;
    border: 2px solid #8B4513;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
    transition: all 0.3s;
    font-weight: bold;
}

.cast-spell-button:hover:not(:disabled) {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}

.cast-spell-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background: #d2b48c;
}
</file>

<file path="src/components/city/DivinePowers.js">
// src/components/city/DivinePowers.js
import React, { useState, useEffect, useRef, useCallback } from 'react';
import godsConfig from '../../gameData/gods.json';
import './DivinePowers.css';

const DivinePowers = ({ godName, playerReligion, favor, onCastSpell, onClose, targetType = 'self', isMenu = false }) => {
    const getGodDetails = (name, religion) => {
        if (!name || !religion) return null;
        const religionKey = religion.toLowerCase();
        const pantheon = godsConfig[religionKey];
        if (!pantheon) return null;
        return Object.values(pantheon).find(g => g.name === name);
    };

    const godDetails = getGodDetails(godName, playerReligion);

    const divinePowersRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 600) / 2,
        y: (window.innerHeight - 700) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('divine-powers-header') || e.target.parentElement.classList.contains('divine-powers-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);

    if (!godDetails) {
        return null;
    }

    const availablePowers = godDetails.powers.filter(power => {
        return power.effect.target === targetType || power.effect.target === 'both';
    });

    const content = (
        <div 
            ref={divinePowersRef}
            className={isMenu ? "divine-powers-menu-content" : "divine-powers-modal-content"}
            onClick={e => e.stopPropagation()}
            style={{ top: `${position.y}px`, left: `${position.x}px` }}
        >
            <div className="divine-powers-header" onMouseDown={handleMouseDown}>
                <h2>{godDetails.name}'s Powers</h2>
                <button onClick={onClose} className="close-button">&times;</button>
            </div>
            {availablePowers.length > 0 ? (
                <div className="powers-grid">
                    {availablePowers.map(power => (
                        <div key={power.name} className="power-card">
                            <h3>{power.name}</h3>
                            <p>{power.description}</p>
                            <div className="power-cost">
                                Cost: {power.favorCost} Favor
                            </div>
                            <button
                                onClick={() => onCastSpell(power)}
                                disabled={favor < power.favorCost}
                                className="cast-spell-button"
                            >
                                Cast Spell
                            </button>
                        </div>
                    ))}
                </div>
            ) : (
                <p className="text-gray-400 text-center">No {targetType === 'self' ? 'self-targeted' : 'targeted'} spells available for {godDetails.name}.</p>
            )}
        </div>
    );

    if (isMenu) {
        return content;
    }

    return (
        <div className="divine-powers-modal-overlay" onClick={onClose}>
            {content}
        </div>
    );
};

export default DivinePowers;
</file>

<file path="src/components/city/DivineTempleMenu.css">
/* src/components/city/DivineTempleMenu.css */
.divine-temple-container {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3;
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a;
    width: 90%;
    max-width: 900px;
    height: 80vh;
    max-height: 700px;
    display: flex;
    flex-direction: column;
    position: fixed;
    z-index: 50;
}

.divine-temple-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1.5rem;
    background-color: #1e3a8a;
    color: #f0e68c;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.5rem;
    border-bottom: 2px solid #cd853f;
    flex-shrink: 0;
    cursor: move;
}
.divine-temple-header .close-btn {
    background: none;
    border: none;
    color: #f0e68c;
    font-size: 2.5rem;
    cursor: pointer;
    line-height: 1;
}
</file>

<file path="src/components/city/DivineTempleMenu.js">
// src/components/city/DivineTempleMenu.js
import React, { useState, useEffect, useRef, useCallback } from 'react';
import unitConfig from '../../gameData/units.json';
import UnitQueue from './UnitQueue';
import Modal from '../shared/Modal';
import { useGame } from '../../contexts/GameContext';

const unitImages = {};
const imageContext = require.context('../../images/troops', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    unitImages[key] = imageContext(item);
});

const UnitStats = ({ unit }) => (
    <div className="w-1/2 bg-gray-900 p-4 rounded-lg space-y-2">
        <h5 className="font-bold text-lg text-yellow-300 mb-3">Unit Information</h5>
        <div className="flex items-center justify-between text-sm"><span>⚔️ Attack</span><span className="font-bold">{unit.attack}</span></div>
        <div className="flex items-center justify-between text-sm"><span>🛡️ Defense</span><span className="font-bold">{unit.defense}</span></div>
        <div className="flex items-center justify-between text-sm"><span>🐎 Speed</span><span className="font-bold">{unit.speed}</span></div>
    </div>
);

const DivineTempleMenu = ({ resources, availablePopulation, onTrain, onClose, cityGameState, unitQueue, onCancelTrain }) => {
    const { gameState } = useGame();
    const worshippedGod = gameState?.god;

    const templeRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 1000) / 2,
        y: (window.innerHeight - 700) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('divine-temple-header') || e.target.parentElement.classList.contains('divine-temple-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);

    // Filter units to only show mythical units associated with the worshipped god
    const mythicUnits = Object.keys(unitConfig).filter(id => unitConfig[id].mythical && unitConfig[id].god === worshippedGod);
    const [selectedUnitId, setSelectedUnitId] = useState(mythicUnits[0] || null);
    const [trainAmount, setTrainAmount] = useState('');
    
    useEffect(() => {
        setTrainAmount('');
    }, [selectedUnitId]);
    
    useEffect(() => {
        const availableUnits = Object.keys(unitConfig).filter(id => unitConfig[id].mythical && unitConfig[id].god === worshippedGod);
        setSelectedUnitId(availableUnits[0] || null);
    }, [worshippedGod]);

    if (!worshippedGod) {
        return <Modal message="You must worship a god to train mythical units." onClose={onClose} />;
    }
    
    if (!selectedUnitId) {
        return <Modal message={`There are no mythical units for your worshipped god, ${worshippedGod}.`} onClose={onClose} />;
    }

    const selectedUnit = unitConfig[selectedUnitId];
    const cityUnits = cityGameState?.units || {};
    const divineTempleUnitQueue = (unitQueue || []).filter(item => unitConfig[item.unitId]?.mythical);
    
    const numericTrainAmount = parseInt(trainAmount, 10) || 0;
    const totalCost = {
        wood: selectedUnit ? selectedUnit.cost.wood * numericTrainAmount : 0,
        stone: selectedUnit ? selectedUnit.cost.stone * numericTrainAmount : 0,
        silver: selectedUnit ? selectedUnit.cost.silver * numericTrainAmount : 0,
        population: selectedUnit ? selectedUnit.cost.population * numericTrainAmount : 0,
        favor: selectedUnit ? selectedUnit.cost.favor * numericTrainAmount : 0,
    };
    
    const currentFavor = cityGameState.worship?.[worshippedGod] || 0;

    const canAfford = resources.wood >= totalCost.wood &&
                    resources.stone >= totalCost.stone &&
                    resources.silver >= totalCost.silver &&
                    availablePopulation >= totalCost.population &&
                    currentFavor >= totalCost.favor;

    const handleTrain = () => {
        const amount = parseInt(trainAmount, 10) || 0;
        if (amount > 0) onTrain(selectedUnitId, amount);
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div
                ref={templeRef}
                className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-4xl border-2 border-gray-600 flex flex-col max-h-[90vh] divine-temple-container"
                onClick={e => e.stopPropagation()}
                onMouseDown={handleMouseDown}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="flex justify-between items-center mb-4 divine-temple-header">
                    <h3 className="font-title text-3xl text-white">Divine Temple</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                
                <div className="flex-grow flex gap-4 overflow-y-auto">
                    <div className="w-1/3 flex flex-col gap-2">
                        {mythicUnits.map(unitId => {
                            const unit = unitConfig[unitId];
                            const isSelected = selectedUnitId === unitId;
                            return (
                                <button
                                    key={unitId}
                                    onClick={() => setSelectedUnitId(unitId)}
                                    className={`flex items-center p-2 rounded border-2 transition-colors w-full ${isSelected ? 'bg-gray-600 border-yellow-500' : 'bg-gray-700 border-gray-600 hover:border-yellow-400'}`}
                                >
                                    <img src={unitImages[unit.image]} alt={unit.name} className="w-12 h-12 mr-3 object-contain" />
                                    <div>
                                        <p className="font-bold text-left text-white">{unit.name}</p>
                                        <p className="text-sm text-left text-gray-400">In City: {cityUnits[unitId] || 0}</p>
                                    </div>
                                </button>
                            );
                        })}
                    </div>
                    <div className="w-2/3 flex flex-col gap-4">
                        <div className="bg-gray-700 p-4 rounded-lg">
                            <h4 className="font-title text-2xl text-yellow-400">{selectedUnit.name}</h4>
                            <p className="text-gray-400 italic mt-1">{selectedUnit.description}</p>
                        </div>
                        <div className="flex gap-4">
                            <div className="w-1/2 bg-gray-900 p-4 rounded-lg space-y-1">
                                <h5 className="font-bold text-lg text-yellow-300 mb-2">Cost (Total)</h5>
                                <p className="text-sm text-gray-300">Wood: {selectedUnit.cost.wood} ({totalCost.wood})</p>
                                <p className="text-sm text-gray-300">Stone: {selectedUnit.cost.stone} ({totalCost.stone})</p>
                                <p className="text-sm text-gray-300">Silver: {selectedUnit.cost.silver} ({totalCost.silver})</p>
                                <p className="text-sm text-gray-300">Population: {selectedUnit.cost.population} ({totalCost.population})</p>
                                <p className="text-sm text-blue-300">Favor: {selectedUnit.cost.favor} ({totalCost.favor})</p>
                                <p className="text-sm text-gray-300">Time per unit: {selectedUnit.cost.time}s</p>
                            </div>
                            <UnitStats unit={selectedUnit} />
                        </div>
                        <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                            <input
                                type="number"
                                value={trainAmount}
                                onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === '' || (parseInt(val) >= 0 && !val.includes('.'))) {
                                        setTrainAmount(val);
                                    }
                                }}
                                className="bg-gray-800 text-white rounded p-2 w-24"
                                placeholder="0"
                            />
                            <button
                                onClick={handleTrain}
                                disabled={!canAfford || numericTrainAmount === 0 || (divineTempleUnitQueue || []).length >= 5}
                                className={`py-2 px-6 text-lg rounded-lg btn ${(canAfford && numericTrainAmount > 0 && (divineTempleUnitQueue || []).length < 5) ? 'btn-confirm' : 'btn-disabled'}`}
                            >
                                {(divineTempleUnitQueue || []).length >= 5 ? 'Queue Full' : 'Train'}
                            </button>
                        </div>
                    </div>
                </div>

                <UnitQueue unitQueue={divineTempleUnitQueue} onCancel={(item) => onCancelTrain(item, 'divineTemple')} title="Mythical Unit Queue" />
            </div>
        </div>
    );
};

export default DivineTempleMenu;
</file>

<file path="src/components/city/HeroDisplay.css">
.hero-display-container {
    @apply w-40 p-1.5 flex flex-col gap-1.5;
    background-image: url('../../images/bg/right_background.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    background-position: center;
    color: #4a2c2a;
}
.hero-display-header {
    @apply font-title text-lg text-center mb-1;
}
.heroes-grid {
    @apply grid grid-cols-3 gap-1;
}
.hero-item {
    @apply w-full aspect-square bg-black/10 rounded-md overflow-hidden border border-transparent hover:border-yellow-600 transition-all;
}
.hero-item img {
    @apply w-full h-full object-cover;
}

.captured-bars-overlay {
    @apply absolute inset-0 w-full h-full pointer-events-none;
    background-image: url('../../images/bar_cells.png');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
}
</file>

<file path="src/components/city/HeroDisplay.js">
import React from 'react';
import heroesConfig from '../../gameData/heroes.json';
import agentsConfig from '../../gameData/agents.json';
import './HeroDisplay.css';

const heroImages = {};
const heroImageContext = require.context('../../images/heroes', false, /\.(png|jpe?g|svg)$/);
heroImageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    heroImages[key] = heroImageContext(item);
});

const agentImages = {};
const agentImageContext = require.context('../../images/agents', false, /\.(png|jpe?g|svg)$/);
agentImageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    agentImages[key] = agentImageContext(item);
});

const HeroDisplay = ({ heroes, agents, movements, activeCityId }) => {
    // #comment Show all active heroes that are assigned to a city, captured, or currently in a movement.
    const heroesToShow = Object.keys(heroes || {}).filter(heroId => {
        const hero = heroes[heroId];
        const isTraveling = (movements || []).some(m => m.hero === heroId);
        return hero.active && (hero.cityId || hero.capturedIn || isTraveling);
    });
    const recruitedAgents = Object.keys(agents || {}).filter(agentId => agents[agentId] > 0);

    if (heroesToShow.length === 0 && recruitedAgents.length === 0) {
        return null;
    }

    return (
        <div className="hero-display-container">
            <h3 className="hero-display-header">Heroes & Agents</h3>
            <div className="heroes-grid">
                {heroesToShow.map(heroId => {
                    const hero = heroesConfig[heroId];
                    const heroData = heroes[heroId];
                    const isCaptured = !!heroData?.capturedIn;
                    const heroMovement = (movements || []).find(m => m.hero === heroId);
                    const isAway = heroData?.cityId && heroData.cityId !== activeCityId && !isCaptured && !heroMovement;

                    const woundedUntilDate = heroData.woundedUntil?.toDate ? heroData.woundedUntil.toDate() : (heroData.woundedUntil ? new Date(heroData.woundedUntil) : null);
                    const isWounded = woundedUntilDate && woundedUntilDate > new Date();

                    let statusTitle = hero.name;
                    let overlay = null;
                    let customClass = '';
                    let backgroundClass = '';

                    if (isCaptured) {
                        statusTitle = `${hero.name} (Captured)`;
                        overlay = <div className="captured-bars-overlay"></div>;
                        customClass = 'opacity-50';
                    } else if (isWounded) {
                        statusTitle = `${hero.name} (Wounded)`;
                        backgroundClass = 'bg-red-500/50';
                        customClass = 'opacity-60';
                    } else if (heroMovement) {
                        statusTitle = `${hero.name} (Traveling)`;
                        overlay = <span className="absolute inset-0 flex items-center justify-center text-white font-bold text-2xl">✈️</span>;
                        customClass = 'opacity-50';
                    } else if (isAway) {
                        statusTitle = `${hero.name} (Away)`;
                        customClass = 'opacity-50 grayscale';
                    }

                    return (
                        <div key={heroId} className={`hero-item relative ${backgroundClass}`} title={statusTitle}>
                            <img src={heroImages[hero.image]} alt={hero.name} className={customClass} />
                            {overlay}
                        </div>
                    );
                })}
                {recruitedAgents.map(agentId => {
                    const agent = agentsConfig[agentId];
                    const agentCount = agents[agentId];
                    return (
                        <div key={agentId} className="hero-item" title={`${agent.name} (x${agentCount})`}>
                            <img src={agentImages[agent.image]} alt={agent.name} />
                            <span className="troop-count">{agentCount}</span>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

export default HeroDisplay;
</file>

<file path="src/components/city/HeroesAltar.css">
/* src/components/city/HeroesAltar.css */
.heroes-altar-container {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3;
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a;
    width: 90%;
    max-width: 800px;
    height: 80vh;
    display: flex;
    flex-direction: column;
    position: fixed;
    z-index: 50;
}

.heroes-altar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1.5rem;
    background-color: #1e3a8a;
    color: #f0e68c;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.5rem;
    border-bottom: 2px solid #cd853f;
    cursor: move;
}

.close-btn {
    background: none;
    border: none;
    color: #f0e68c;
    font-size: 2.5rem;
    cursor: pointer;
    line-height: 1;
}

.heroes-altar-content {
    display: flex;
    flex-grow: 1;
    overflow: hidden;
}

.heroes-list {
    width: 220px;
    border-right: 2px solid #8B4513;
    overflow-y: auto;
    padding: 0.5rem;
}

.hero-list-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    cursor: pointer;
    padding: 0.5rem;
    margin-bottom: 0.5rem;
    border: 2px solid transparent;
    border-radius: 4px;
}

.hero-list-item.selected {
    border-color: #CD853F;
    background-color: rgba(139, 69, 19, 0.1);
}

.hero-list-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
}

.recruited-indicator {
    color: green;
    font-weight: bold;
    margin-left: auto;
}

.hero-details-panel {
    flex-grow: 1;
    padding: 1rem;
    overflow-y: auto;
}

.hero-details-content {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.hero-main-info {
    display: flex;
    gap: 1rem;
}

.hero-details-avatar {
    width: 120px;
    height: 120px;
    border-radius: 8px;
    border: 2px solid #8B4513;
}

.hero-text {
    flex-grow: 1;
}

.recruit-btn, .activate-skill-btn {
    font-weight: bold;
    padding: 0.5rem 1rem;
    border-radius: 0.375rem;
    transition: all 0.2s;
    cursor: pointer;
    color: #4a2c2a;
    border: 2px solid #8B4513;
    text-shadow: 0 1px 0 rgba(255, 255, 255, 0.3);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
}

.recruit-btn:hover:not(:disabled), .activate-skill-btn:hover:not(:disabled) {
    transform: scale(1.05);
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}


.skills-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.skill-card {
    display: flex;
    align-items: center;
    gap: 1rem;
    background-color: rgba(139, 69, 19, 0.1);
    border: 1px solid #d2b48c;
    padding: 0.75rem;
    border-radius: 4px;
}

.skill-icon {
    width: 50px;
    height: 50px;
}

.skill-info {
    flex-grow: 1;
}

.skill-type {
    font-size: 0.8rem;
    color: #6b4a2b;
}

.activate-skill-btn {
    margin-left: auto;
    flex-shrink: 0;
}

.passive-skill-info {
    margin-top: 1rem;
    padding: 0.5rem;
    background-color: rgba(139, 69, 19, 0.1);
    border: 1px solid #d2b48c;
    border-radius: 4px;
}

.passive-skill-info h5 {
    font-weight: bold;
    color: #8B4513;
}

.passive-skill-info p {
    font-size: 0.9rem;
    font-style: italic;
}
</file>

<file path="src/components/city/HeroesAltar.js">
import React, { useState, useEffect, useRef, useCallback } from 'react';
import heroesConfig from '../../gameData/heroes.json';
import agentsConfig from '../../gameData/agents.json';
import './HeroesAltar.css';
import { useGame } from '../../contexts/GameContext';
import Countdown from '../map/Countdown';

const heroImages = {};
const heroImageContext = require.context('../../images/heroes', false, /\.(png|jpe?g|svg)$/);
heroImageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    heroImages[key] = heroImageContext(item);
});

const agentImages = {};
const agentImageContext = require.context('../../images/agents', false, /\.(png|jpe?g|svg)$/);
agentImageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    agentImages[key] = agentImageContext(item);
});

const skillImages = {};
const skillImageContext = require.context('../../images/skills', false, /\.(png|jpe?g|svg)$/);
skillImageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    skillImages[key] = skillImageContext(item);
});

const HeroesAltar = ({ cityGameState, onRecruitHero, onActivateSkill, onClose, onAssignHero, onUnassignHero, onLevelUpHero, onAddHeroXp, onRecruitAgent, onAssignAgent, movements }) => {
    const [activeTab, setActiveTab] = useState('heroes');
    const [selectedHeroId, setSelectedHeroId] = useState(Object.keys(heroesConfig)[0]);
    const [selectedAgentId, setSelectedAgentId] = useState(Object.keys(agentsConfig)[0]);
    const { heroes = {}, agents = {}, activeSkills = {} } = cityGameState;
    const { activeCityId } = useGame();
    const altarRef = useRef(null);
    const [position, setPosition] = useState({
        x: (window.innerWidth - 800) / 2,
        y: (window.innerHeight - 700) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('heroes-altar-header') || e.target.parentElement.classList.contains('heroes-altar-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);

    const handleRecruitHero = (e, heroId) => {
        e.stopPropagation();
        onRecruitHero(heroId);
    };

    const handleRecruitAgent = (e, agentId) => {
        e.stopPropagation();
        onRecruitAgent(agentId);
    };

    const handleSkillActivation = (e, heroId, skill) => {
        e.stopPropagation();
        onActivateSkill(heroId, skill);
    };

    const handleAssign = (e, heroId) => {
        e.stopPropagation();
        onAssignHero(heroId);
    };

    const handleUnassign = (e, heroId) => {
        e.stopPropagation();
        onUnassignHero(heroId);
    };

    const selectedHero = heroesConfig[selectedHeroId];
    const heroData = heroes[selectedHeroId] || { level: 1, xp: 0 };
    const isHeroInThisCity = heroData?.cityId === activeCityId;
    const heroMovement = movements.find(m => m.type === 'assign_hero' && m.hero === selectedHeroId && m.targetCityId === activeCityId);

    const selectedAgent = agentsConfig[selectedAgentId];
    const agentData = agents[selectedAgentId] || 0;
    
    const woundedUntilDate = heroData.woundedUntil?.toDate ? heroData.woundedUntil.toDate() : (heroData.woundedUntil ? new Date(heroData.woundedUntil) : null);
    const isWounded = woundedUntilDate && woundedUntilDate > new Date();
    const isHeroCaptured = !!heroData?.capturedIn;


    const getEffectValue = (effect, level) => {
        if (!effect || typeof level !== 'number') return 0;
        return (effect.baseValue || 0) + ((level - 1) * (effect.valuePerLevel || 0));
    };

    const getSkillCost = (skill, level) => {
        if (!skill || !skill.cost || !skill.cost.favor || typeof level !== 'number') return 0;
        const favorCost = skill.cost.favor;
        return (favorCost.base || 0) + ((level - 1) * (favorCost.perLevel || 0));
    };

    const formatDescription = (description, effect, level) => {
        if (!description || !effect || typeof level !== 'number') return description || '';
        const currentValue = getEffectValue(effect, level) * 100;
        const perLevelValue = (effect.valuePerLevel || 0) * 100;
        let formatted = description.replace(/(\d+(\.\d+)?%)/, `${currentValue.toFixed(1)}%`);
        if (perLevelValue > 0) {
             formatted += ` (+${perLevelValue.toFixed(1)}% per level)`;
        }
        return formatted;
    };

    const xpForNextLevel = heroData.level < selectedHero.maxLevel ? selectedHero.xpPerLevel[heroData.level - 1] : Infinity;
    const canLevelUp = heroData.xp >= xpForNextLevel && heroData.level < selectedHero.maxLevel;

    const renderList = () => {
        if (activeTab === 'heroes') {
            return Object.entries(heroesConfig).map(([id, hero]) => (
                <div key={id} className={`hero-list-item ${selectedHeroId === id ? 'selected' : ''}`} onClick={() => setSelectedHeroId(id)}>
                    <img src={heroImages[hero.image]} alt={hero.name} className="hero-list-avatar" />
                    <span>{hero.name}</span>
                    {heroes[id] && <span className="recruited-indicator">✔</span>}
                </div>
            ));
        }
        if (activeTab === 'agents') {
            return Object.entries(agentsConfig).map(([id, agent]) => (
                 <div key={id} className={`hero-list-item ${selectedAgentId === id ? 'selected' : ''}`} onClick={() => setSelectedAgentId(id)}>
                    <img src={agentImages[agent.image]} alt={agent.name} className="hero-list-avatar" />
                    <span>{agent.name}</span>
                     {(agents[id] > 0) && <span className="recruited-indicator">x{agents[id]}</span>}
                </div>
            ));
        }
    };

    const renderDetails = () => {
        if (activeTab === 'heroes' && selectedHero) {
            return (
                <div className="hero-details-content">
                    <div className="hero-main-info">
                        <img src={heroImages[selectedHero.image]} alt={selectedHero.name} className="hero-details-avatar" />
                        <div className="hero-text">
                            <h4>{selectedHero.name} {heroes[selectedHeroId] && `(Lvl ${heroData.level})`}</h4>
                            <p>{selectedHero.description}</p>
                            {selectedHero.passive && (
                                <div className="passive-skill-info">
                                    <h5>Passive: {selectedHero.passive.name}</h5>
                                    <p>{formatDescription(selectedHero.passive.description, selectedHero.passive.effect, heroData.level)}</p>
                                </div>
                            )}
                            {heroes[selectedHeroId] && (
                                <div className="mt-2">
                                    <div className="w-full bg-gray-600 rounded-full h-4">
                                        <div className="bg-yellow-400 h-4 rounded-full" style={{ width: `${Math.min(100, (heroData.xp / (xpForNextLevel === Infinity ? heroData.xp : xpForNextLevel)) * 100)}%` }}></div>
                                    </div>
                                    <p className="text-xs text-center">{heroData.xp} / {xpForNextLevel === Infinity ? 'Max' : xpForNextLevel} XP</p>
                                    {canLevelUp && (
                                        <button className="recruit-btn mt-1" onClick={() => onLevelUpHero(selectedHeroId)}>
                                            Level Up ({selectedHero.levelUpCost.silver} Silver, {selectedHero.levelUpCost.favor} Favor)
                                        </button>
                                    )}
                                    <button className="text-xs" onClick={() => onAddHeroXp(selectedHeroId, 100)}>+100 XP</button>
                                </div>
                            )}
                            {!heroes[selectedHeroId] && (
                                <button className="recruit-btn" onClick={(e) => handleRecruitHero(e, selectedHeroId)}>
                                    Recruit ({selectedHero.cost.silver} Silver, {selectedHero.cost.favor} Favor)
                                </button>
                            )}
                            {heroes[selectedHeroId] && !isHeroInThisCity && !heroMovement && !isWounded && !isHeroCaptured && (
                                <button className="recruit-btn" onClick={(e) => handleAssign(e, selectedHeroId)}>
                                    Assign to this City
                                </button>
                            )}
                            {heroes[selectedHeroId] && isHeroInThisCity && !isWounded && (
                                <button className="recruit-btn" onClick={(e) => handleUnassign(e, selectedHeroId)}>
                                    Unassign from City
                                </button>
                            )}
                            {heroMovement && (
                                <div className="text-center mt-2">
                                    <p>Arriving in:</p>
                                    <Countdown arrivalTime={heroMovement.arrivalTime} />
                                </div>
                            )}
                            {isWounded && (
                                <div className="text-center mt-2 text-red-600 font-bold">
                                    <p>Wounded! Heals in:</p>
                                    <Countdown arrivalTime={heroData.woundedUntil} />
                                </div>
                            )}
                            {isHeroCaptured && (
                                <div className="text-center mt-2 text-red-600 font-bold">
                                    <p>Captured!</p>
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="skills-list">
                        {selectedHero.skills.map(skill => {
                            const currentSkillCost = getSkillCost(skill, heroData.level);
                            const skillCooldown = activeSkills[skill.name];
                            const isOnCooldown = skillCooldown && Date.now() < skillCooldown.expires;
                            const timeLeft = isOnCooldown ? Math.ceil((skillCooldown.expires - Date.now()) / 1000) : 0;
                            return (
                                <div key={skill.name} className="skill-card">
                                    <img src={skillImages[skill.icon]} alt={skill.name} className="skill-icon" />
                                    <div className="skill-info">
                                        <h5>{skill.name} <span className="skill-type">({skill.type})</span></h5>
                                        <p>{formatDescription(skill.description, skill.effect, heroData.level)}</p>
                                    </div>
                                    {heroes[selectedHeroId] && (
                                        <button
                                            className="activate-skill-btn"
                                            onClick={(e) => handleSkillActivation(e, selectedHeroId, skill)}
                                            disabled={isOnCooldown || isHeroCaptured}
                                        >
                                            {isHeroCaptured ? 'Captured' : (isOnCooldown ? `Cooldown: ${timeLeft}s` : `Activate (${currentSkillCost} Favor)`)}
                                        </button>
                                    )}
                                </div>
                            )
                        })}
                    </div>
                </div>
            );
        }
        if (activeTab === 'agents' && selectedAgent) {
             return (
                <div className="hero-details-content">
                    <div className="hero-main-info">
                        <img src={agentImages[selectedAgent.image]} alt={selectedAgent.name} className="hero-details-avatar" />
                        <div className="hero-text">
                            <h4>{selectedAgent.name} (Owned: {agentData})</h4>
                            <p>{selectedAgent.description}</p>
                            <button className="recruit-btn" onClick={(e) => handleRecruitAgent(e, selectedAgentId)}>
                                Recruit ({selectedAgent.cost.wood}W, {selectedAgent.cost.stone}S, {selectedAgent.cost.silver}Ag)
                            </button>
                        </div>
                    </div>
                     <div className="skills-list">
                        {selectedAgent.abilities.map(ability => (
                            <div key={ability.name} className="skill-card">
                                <div className="skill-info">
                                    <h5>{ability.name}</h5>
                                    <p>{ability.description}</p>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        }
        return <p>Select an item to see details.</p>;
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div
                ref={altarRef}
                className="heroes-altar-container"
                onClick={e => e.stopPropagation()}
                onMouseDown={handleMouseDown}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="heroes-altar-header">
                    <h3>Heroes & Agents Altar</h3>
                    <div className="tabs">
                        <button className={`tab-btn ${activeTab === 'heroes' ? 'active' : ''}`} onClick={() => setActiveTab('heroes')}>Heroes</button>
                        <button className={`tab-btn ${activeTab === 'agents' ? 'active' : ''}`} onClick={() => setActiveTab('agents')}>Agents</button>
                    </div>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="heroes-altar-content">
                    <div className="heroes-list">
                        {renderList()}
                    </div>
                    <div className="hero-details-panel">
                        {renderDetails()}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default HeroesAltar;
</file>

<file path="src/components/city/HospitalMenu.js">
// src/components/city/HospitalMenu.js
import React, { useState, useMemo, useRef, useCallback, useEffect } from 'react';
import unitConfig from '../../gameData/units.json';
import UnitQueue from './UnitQueue';

const unitImages = {};
const imageContext = require.context('../../images/heroes', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    unitImages[key] = imageContext(item);
});

const HospitalMenu = ({ cityGameState, onClose, onHeal, onCancelHeal, getHospitalCapacity, availablePopulation }) => {
    const [healAmounts, setHealAmounts] = useState({});
    const woundedUnits = cityGameState.wounded || {};
    const hospitalLevel = cityGameState.buildings.hospital?.level || 0;
    const capacity = getHospitalCapacity(hospitalLevel);
    const totalWounded = Object.values(woundedUnits).reduce((sum, count) => sum + count, 0);

    const hospitalRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 1000) / 2,
        y: (window.innerHeight - 700) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('hospital-header') || e.target.parentElement.classList.contains('hospital-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);

    const handleAmountChange = (unitId, value) => {
        const max = woundedUnits[unitId] || 0;
        const amount = Math.max(0, Math.min(max, parseInt(value, 10) || 0));
        setHealAmounts(prev => ({ ...prev, [unitId]: amount }));
    };

    const totalCost = useMemo(() => {
        return Object.entries(healAmounts).reduce((acc, [unitId, amount]) => {
            const unit = unitConfig[unitId];
            if (unit && unit.heal_cost) {
                acc.wood += (unit.heal_cost.wood || 0) * amount;
                acc.stone += (unit.heal_cost.stone || 0) * amount;
                acc.silver += (unit.heal_cost.silver || 0) * amount;
            }
            return acc;
        }, { wood: 0, stone: 0, silver: 0 });
    }, [healAmounts]);
    
    const populationCost = useMemo(() => {
        return Object.entries(healAmounts).reduce((acc, [unitId, amount]) => {
            const unit = unitConfig[unitId];
            if (unit) {
                acc += (unit.cost.population || 0) * amount;
            }
            return acc;
        }, 0);
    }, [healAmounts]);

    const canAfford = cityGameState.resources.wood >= totalCost.wood &&
                      cityGameState.resources.stone >= totalCost.stone &&
                      cityGameState.resources.silver >= totalCost.silver;
    const hasEnoughPopulation = availablePopulation >= populationCost;

    const handleHeal = () => {
        const unitsToHeal = Object.entries(healAmounts).filter(([, amount]) => amount > 0);
        if (unitsToHeal.length > 0) {
            onHeal(Object.fromEntries(unitsToHeal));
            setHealAmounts({});
        }
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div
                ref={hospitalRef}
                className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-4xl border-2 border-gray-600 flex flex-col max-h-[90vh] hospital-container"
                onClick={e => e.stopPropagation()}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="flex justify-between items-center mb-4 hospital-header" onMouseDown={handleMouseDown}>
                    <h3 className="font-title text-3xl text-white">Hospital (Level {hospitalLevel})</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                <p className="text-gray-400 mb-4">Capacity: {totalWounded} / {capacity}</p>
                <div className="flex-grow overflow-y-auto pr-2">
                    <h4 className="text-xl font-semibold text-yellow-400 mb-2">Wounded Units</h4>
                    {Object.keys(woundedUnits).length > 0 ? (
                        <div className="space-y-3">
                            {Object.entries(woundedUnits).map(([unitId, count]) => {
                                if (count === 0) return null;
                                const unit = unitConfig[unitId];
                                return (
                                    <div key={unitId} className="bg-gray-700 p-3 rounded-lg flex items-center justify-between">
                                        <div className="flex items-center gap-4">
                                            <img src={unitImages[unit.image]} alt={unit.name} className="w-12 h-12 object-contain" />
                                            <div>
                                                <p className="font-bold text-white">{unit.name}</p>
                                                <p className="text-sm text-gray-400">Wounded: {count}</p>
                                            </div>
                                        </div>
                                        <div className="flex items-center gap-3">
                                            <input
                                                type="number"
                                                value={healAmounts[unitId] || ''}
                                                onChange={(e) => handleAmountChange(unitId, e.target.value)}
                                                className="bg-gray-800 text-white rounded p-2 w-24 text-center"
                                                placeholder="Amount"
                                                max={count}
                                                min="0"
                                            />
                                            <div className="text-xs text-gray-300">
                                                <p>Cost/unit:</p>
                                                <p>W: {unit.heal_cost.wood}, S: {unit.heal_cost.stone}, Ag: {unit.heal_cost.silver}</p>
                                                <p>Time/unit: {unit.heal_time}s</p>
                                            </div>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    ) : (
                        <p className="text-gray-500 text-center py-8">No wounded units.</p>
                    )}
                </div>
                <div className="mt-4 pt-4 border-t border-gray-600">
                    <div className="flex justify-between items-center">
                        <div>
                            <p className="font-bold text-lg">Total Cost:</p>
                            <p className="text-sm text-gray-300">
                                Wood: {totalCost.wood}, Stone: {totalCost.stone}, Silver: {totalCost.silver}
                            </p>
                            <p className="text-sm text-gray-300">
                                Population: <span className={hasEnoughPopulation ? 'text-green-400' : 'text-red-400'}>{populationCost} / {availablePopulation}</span>
                            </p>
                        </div>
                        <button
                            onClick={handleHeal}
                            disabled={!canAfford || !hasEnoughPopulation || Object.values(healAmounts).reduce((sum, val) => sum + val, 0) === 0 || (cityGameState.healQueue || []).length >= 5}
                            className={`py-2 px-6 text-lg rounded-lg btn ${canAfford && hasEnoughPopulation && Object.values(healAmounts).reduce((sum, val) => sum + val, 0) > 0 && (cityGameState.healQueue || []).length < 5 ? 'btn-confirm' : 'btn-disabled'}`}
                        >
                            { (cityGameState.healQueue || []).length >= 5 ? 'Queue Full' : (!hasEnoughPopulation ? 'Not Enough Pop.' : 'Heal Selected') }
                        </button>
                    </div>
                </div>
                <UnitQueue 
                    unitQueue={cityGameState.healQueue || []} 
                    onCancel={onCancelHeal} 
                    title="Healing"
                />
            </div>
        </div>
    );
};
export default HospitalMenu;
</file>

<file path="src/components/city/MarketMenu.css">
/* src/components/city/MarketMenu.css */
.market-container {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F); /* saddlebrown to peru */
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a;
    font-family: 'Inter', sans-serif;
    width: 90%;
    max-width: 800px;
    height: 80vh;
    display: flex;
    flex-direction: column;
    position: fixed;
    z-index: 50;
}

.market-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1.5rem;
    background-color: #1e3a8a;
    color: #f0e68c;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.5rem;
    border-bottom: 2px solid #cd853f;
    cursor: move;
}

.market-header .close-btn {
    background: none;
    border: none;
    color: #f0e68c;
    font-size: 2.5rem;
    cursor: pointer;
    line-height: 1;
}
.market-header .close-btn:hover {
    color: white;
}

.market-tabs {
    display: flex;
    background-color: #1e3a8a;
    padding: 4px;
    border-bottom: 4px solid #8B4513;
}

.market-tabs button {
    flex-grow: 1;
    padding: 8px 16px;
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #4a2c2a;
    border: 2px solid #8B4513;
    border-bottom: none;
    margin-right: 4px;
    cursor: pointer;
    font-weight: bold;
}
.market-tabs button:last-child {
    margin-right: 0;
}
.market-tabs button:hover {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}
.market-tabs button.active {
    background: #F5DEB3;
    color: #4a2c2a;
}

.market-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 1rem;
}

.error-message {
    background-color: #ef4444;
    color: white;
    padding: 0.5rem;
    border-radius: 4px;
    text-align: center;
    margin-bottom: 1rem;
}

.market-table {
    width: 100%;
    border-collapse: collapse;
}
.market-table thead {
    background-color: rgba(30, 58, 138, 0.2);
}
.market-table th {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 2px solid #cd853f;
}
.market-table td {
    padding: 0.75rem;
    border-bottom: 1px solid #d2b48c; /* tan */
}
.market-table tr:hover td {
    background-color: rgba(139, 69, 19, 0.1);
}

.resource-cell {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}
.resource-cell img {
    width: 24px;
    height: 24px;
}

.market-btn {
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #4a2c2a;
    font-weight: bold;
    border: 2px solid #8B4513;
    border-radius: 4px;
    padding: 0.25rem 1rem;
    transition: all 0.2s;
    cursor: pointer;
}
.market-btn:hover:not(:disabled) {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}
.market-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background: #d2b48c;
}

.market-btn.cancel-btn {
    background: linear-gradient(to bottom, #fca5a5, #ef4444);
}
.market-btn.cancel-btn:hover {
    background: linear-gradient(to bottom, #fecaca, #f87171);
}

/* Create Trade Form */
.create-trade-form {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    padding: 1rem;
}
.trade-inputs {
    display: flex;
    justify-content: space-around;
    gap: 2rem;
}
.trade-group {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    background-color: rgba(139, 69, 19, 0.1);
    border: 1px solid #d2b48c;
    border-radius: 4px;
}
.trade-group label {
    font-weight: bold;
    font-size: 1.25rem;
    text-align: center;
}
.trade-group select, .trade-group input {
    width: 100%;
    padding: 0.5rem;
    border-radius: 4px;
    background-color: rgba(255, 255, 255, 0.5);
    border: 1px solid #d2b48c;
    color: #4a2c2a;
}
.trade-group p {
    font-size: 0.8rem;
    text-align: center;
    color: #6b4a2b;
}
.capacity-info {
    text-align: center;
    font-size: 0.9rem;
    font-weight: bold;
}
.market-btn.create-btn {
    padding: 0.75rem;
    font-size: 1.1rem;
}
</file>

<file path="src/components/city/MarketMenu.js">
// src/components/city/MarketMenu.js
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { db } from '../../firebase/config';
import { collection, query,onSnapshot, serverTimestamp, doc, runTransaction, orderBy } from 'firebase/firestore';
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import './MarketMenu.css';
import woodImage from '../../images/resources/wood.png';
import stoneImage from '../../images/resources/stone.png';
import silverImage from '../../images/resources/silver.png';

const resourceImages = {
    wood: woodImage,
    stone: stoneImage,
    silver: silverImage,
};

const MarketMenu = ({ onClose, cityGameState, worldId, marketCapacity }) => {
    const { currentUser, userProfile } = useAuth();
    const { activeCityId } = useGame(); // #comment Get activeCityId to reference the correct city document
    const [activeTab, setActiveTab] = useState('marketplace');
    const [trades, setTrades] = useState([]);
    const [myTrades, setMyTrades] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);

    // State for creating a new trade
    const [offerResource, setOfferResource] = useState('wood');
    const [offerAmount, setOfferAmount] = useState('');
    const [demandResource, setDemandResource] = useState('stone');
    const [demandAmount, setDemandAmount] = useState('');
    
    const marketRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 800) / 2,
        y: (window.innerHeight - 600) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('market-header') || e.target.parentElement.classList.contains('market-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);


    // #comment fetch trade offers from firestore
    useEffect(() => {
        if (!worldId) return;
        setLoading(true);
        const tradesRef = collection(db, 'worlds', worldId, 'trades');
        const q = query(tradesRef, orderBy('createdAt', 'desc'));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            const allTrades = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setTrades(allTrades.filter(t => t.playerId !== currentUser.uid));
            setMyTrades(allTrades.filter(t => t.playerId === currentUser.uid));
            setLoading(false);
        }, (err) => {
            console.error("Error fetching trades:", err);
            setError("Could not load market data.");
            setLoading(false);
        });

        return () => unsubscribe();
    }, [worldId, currentUser.uid]);

    // #comment handle creation of a new trade offer
    const handleCreateTrade = async (e) => {
        e.preventDefault();
        if (isSubmitting) return;
        setError('');
        const offerAmountNum = parseInt(offerAmount, 10);
        const demandAmountNum = parseInt(demandAmount, 10);

        if (offerResource === demandResource) {
            setError("You cannot trade a resource for itself.");
            return;
        }
        if (!offerAmountNum || !demandAmountNum || offerAmountNum <= 0 || demandAmountNum <= 0) {
            setError("Please enter valid, positive amounts for the trade.");
            return;
        }
        if (cityGameState.resources[offerResource] < offerAmountNum) {
            setError(`You do not have enough ${offerResource} to make this offer.`);
            return;
        }
        if (offerAmountNum > marketCapacity) {
            setError(`You cannot offer more than your market capacity of ${marketCapacity}.`);
            return;
        }

        setIsSubmitting(true);
        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', activeCityId);
        const tradesRef = collection(db, 'worlds', worldId, 'trades');

        try {
            await runTransaction(db, async (transaction) => {
                const cityDoc = await transaction.get(cityDocRef);
                if (!cityDoc.exists()) throw new Error("City data not found.");

                const currentResources = cityDoc.data().resources;
                if (currentResources[offerResource] < offerAmountNum) {
                    throw new Error(`Not enough ${offerResource}.`);
                }

                const newResources = {
                    ...currentResources,
                    [offerResource]: currentResources[offerResource] - offerAmountNum,
                };
                transaction.update(cityDocRef, { resources: newResources });

                const newTrade = {
                    playerId: currentUser.uid,
                    playerName: userProfile.username,
                    originCityId: activeCityId, // #comment Store which city made the offer
                    offer: { resource: offerResource, amount: offerAmountNum },
                    demand: { resource: demandResource, amount: demandAmountNum },
                    createdAt: serverTimestamp(),
                };
                transaction.set(doc(tradesRef), newTrade);
            });

            setOfferAmount('');
            setDemandAmount('');
            setActiveTab('my-trades');
            setTimeout(() => setIsSubmitting(false), 3000); // 3-second cooldown
        } catch (error) {
            console.error("Error creating trade:", error);
            setError(`Failed to create trade: ${error.message}`);
            setIsSubmitting(false);
        }
    };

    // #comment handle accepting a trade from another player
    const handleAcceptTrade = async (trade) => {
        setError('');
        if (cityGameState.resources[trade.demand.resource] < trade.demand.amount) {
            setError(`You don't have enough ${trade.demand.resource} to accept this trade.`);
            return;
        }

        const tradeRef = doc(db, 'worlds', worldId, 'trades', trade.id);
        const myCityRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', activeCityId);
        const theirCityRef = doc(db, `users/${trade.playerId}/games`, worldId, 'cities', trade.originCityId);

        try {
            await runTransaction(db, async (transaction) => {
                const tradeDoc = await transaction.get(tradeRef);
                if (!tradeDoc.exists()) throw new Error("This trade is no longer available.");

                const myCityDoc = await transaction.get(myCityRef);
                const theirCityDoc = await transaction.get(theirCityRef);
                if (!myCityDoc.exists() || !theirCityDoc.exists()) throw new Error("Could not find player data for this trade.");

                const myResources = myCityDoc.data().resources;
                const theirResources = theirCityDoc.data().resources;

                if (myResources[trade.demand.resource] < trade.demand.amount) {
                    throw new Error(`You do not have enough ${trade.demand.resource}.`);
                }

                // Update my resources
                const myNewResources = { ...myResources };
                myNewResources[trade.demand.resource] -= trade.demand.amount;
                myNewResources[trade.offer.resource] = (myNewResources[trade.offer.resource] || 0) + trade.offer.amount;
                transaction.update(myCityRef, { resources: myNewResources });

                // Update their resources
                const theirNewResources = { ...theirResources };
                theirNewResources[trade.demand.resource] = (theirNewResources[trade.demand.resource] || 0) + trade.demand.amount;
                transaction.update(theirCityRef, { resources: theirNewResources });

                // Delete the trade
                transaction.delete(tradeRef);
            });
        } catch (error) {
            console.error("Error accepting trade:", error);
            setError(`Failed to accept trade: ${error.message}`);
        }
    };

    // #comment handle canceling one of your own trades
    const handleCancelTrade = async (trade) => {
        setError('');
        const tradeRef = doc(db, 'worlds', worldId, 'trades', trade.id);
        const myCityRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', trade.originCityId);

        try {
            await runTransaction(db, async (transaction) => {
                const tradeDoc = await transaction.get(tradeRef);
                if (!tradeDoc.exists()) throw new Error("This trade no longer exists.");

                const myCityDoc = await transaction.get(myCityRef);
                if (!myCityDoc.exists()) throw new Error("Your city data could not be found.");

                const myResources = myCityDoc.data().resources;
                const myNewResources = { ...myResources };
                myNewResources[trade.offer.resource] = (myNewResources[trade.offer.resource] || 0) + trade.offer.amount;

                transaction.update(myCityRef, { resources: myNewResources });
                transaction.delete(tradeRef);
            });
        } catch (error) {
            console.error("Error canceling trade:", error);
            setError(`Failed to cancel trade: ${error.message}`);
        }
    };

    const renderTrades = (tradeList, isMyTrade) => {
        if (loading) return <p>Loading trades...</p>;
        if (tradeList.length === 0) return <p className="text-center p-4">No trades found.</p>;

        return (
            <table className="market-table">
                <thead>
                    <tr>
                        <th>Player</th>
                        <th>Offering</th>
                        <th>Demanding</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    {tradeList.map(trade => {
                        const canAfford = cityGameState.resources[trade.demand.resource] >= trade.demand.amount;
                        return (
                            <tr key={trade.id}>
                                <td>{trade.playerName}</td>
                                <td className="resource-cell">
                                    <img src={resourceImages[trade.offer.resource]} alt={trade.offer.resource} />
                                    {trade.offer.amount.toLocaleString()}
                                </td>
                                <td className="resource-cell">
                                    <img src={resourceImages[trade.demand.resource]} alt={trade.demand.resource} />
                                    {trade.demand.amount.toLocaleString()}
                                </td>
                                <td>
                                    {isMyTrade ? (
                                        <button onClick={() => handleCancelTrade(trade)} className="market-btn cancel-btn">Cancel</button>
                                    ) : (
                                        <button onClick={() => handleAcceptTrade(trade)} disabled={!canAfford} className="market-btn accept-btn">
                                            {canAfford ? 'Accept' : 'Too Costly'}
                                        </button>
                                    )}
                                </td>
                            </tr>
                        );
                    })}
                </tbody>
            </table>
        );
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div
                ref={marketRef}
                className="market-container"
                onClick={e => e.stopPropagation()}
                onMouseDown={handleMouseDown}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="market-header">
                    <h2>Marketplace</h2>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="market-tabs">
                    <button onClick={() => setActiveTab('marketplace')} className={activeTab === 'marketplace' ? 'active' : ''}>Marketplace</button>
                    <button onClick={() => setActiveTab('my-trades')} className={activeTab === 'my-trades' ? 'active' : ''}>My Trades</button>
                    <button onClick={() => setActiveTab('create')} className={activeTab === 'create' ? 'active' : ''}>Create Trade</button>
                </div>
                <div className="market-content">
                    {error && <p className="error-message">{error}</p>}
                    {activeTab === 'marketplace' && renderTrades(trades, false)}
                    {activeTab === 'my-trades' && renderTrades(myTrades, true)}
                    {activeTab === 'create' && (
                        <form onSubmit={handleCreateTrade} className="create-trade-form">
                            <div className="trade-inputs">
                                <div className="trade-group">
                                    <label>You Offer</label>
                                    <select value={offerResource} onChange={e => setOfferResource(e.target.value)}>
                                        <option value="wood">Wood</option>
                                        <option value="stone">Stone</option>
                                        <option value="silver">Silver</option>
                                    </select>
                                    <input type="number" value={offerAmount} onChange={e => setOfferAmount(e.target.value)} placeholder="Amount" />
                                    <p>Your Wood: {Math.floor(cityGameState.resources.wood)}</p>
                                </div>
                                <div className="trade-group">
                                    <label>You Demand</label>
                                    <select value={demandResource} onChange={e => setDemandResource(e.target.value)}>
                                        <option value="wood">Wood</option>
                                        <option value="stone">Stone</option>
                                        <option value="silver">Silver</option>
                                    </select>
                                    <input type="number" value={demandAmount} onChange={e => setDemandAmount(e.target.value)} placeholder="Amount" />
                                    <p>Your Stone: {Math.floor(cityGameState.resources.stone)}</p>
                                </div>
                            </div>
                             <p className="capacity-info">Your Silver: {Math.floor(cityGameState.resources.silver)} | Market Capacity: {marketCapacity}</p>
                            <button type="submit" className="market-btn create-btn" disabled={isSubmitting}>
                                {isSubmitting ? 'Creating...' : 'Create Offer'}
                            </button>
                        </form>
                    )}
                </div>
            </div>
        </div>
    );
};

export default MarketMenu;
</file>

<file path="src/components/city/PrisonMenu.css">
/* src/components/city/PrisonMenu.css */
.prison-menu-container {
    /* Reusing styles from other menus */
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3;
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a;
    width: 90%;
    max-width: 500px;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    position: fixed;
    z-index: 50;
}

.prison-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1.5rem;
    background-color: #1e3a8a;
    color: #f0e68c;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.5rem;
    border-bottom: 2px solid #cd853f;
    cursor: move;
}

.prison-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.prisoner-item {
    display: flex;
    gap: 1rem;
    align-items: center; /* Vertically align items */
    background-color: rgba(139, 69, 19, 0.1);
    border: 1px solid #d2b48c;
    padding: 0.75rem;
    border-radius: 4px;
}

.prisoner-avatar {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    border: 2px solid #8B4513;
    flex-shrink: 0; /* Prevent avatar from shrinking */
}

.prisoner-info {
    flex-grow: 1;
}

.prisoner-name {
    font-weight: bold;
    font-size: 1.2rem;
    color: #8B4513;
}

.prisoner-owner {
    font-size: 0.9rem;
}

.prisoner-city {
    font-size: 0.8rem;
    font-style: italic;
    color: #6b4a2b;
}

.execution-timer {
    font-size: 0.9rem;
    font-weight: bold;
    color: #dc2626;
}

.prisoner-actions {
    margin-left: auto; /* Push actions to the right */
}

.release-btn {
    background: linear-gradient(to bottom, #a3be8c, #8fbcbb); /* A calming green/blue */
    color: #2e3440;
    font-weight: bold;
    border: 2px solid #4c566a;
    border-radius: 4px;
    padding: 0.25rem 0.75rem;
    font-size: 0.8rem;
    cursor: pointer;
    transition: background-color 0.2s;
}

.release-btn:hover {
    background: linear-gradient(to bottom, #b4d0a8, #9cc7c6);
}

.prison-footer {
    padding: 0.75rem;
    background-color: rgba(0,0,0,0.1);
    border-top: 1px solid #d2b48c;
}
</file>

<file path="src/components/city/PrisonMenu.js">
// src/components/city/PrisonMenu.js
import React, { useState, useEffect, useRef, useCallback } from 'react';
import heroesConfig from '../../gameData/heroes.json';
import Countdown from '../map/Countdown';
import './PrisonMenu.css';

const heroImages = {};
const heroImageContext = require.context('../../images/heroes', false, /\.(png|jpe?g|svg)$/);
heroImageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    heroImages[key] = heroImageContext(item);
});

/**
 * Safely converts various timestamp formats into a JS Date object.
 * This handles Firestore Timestamps (live and serialized), JS Dates, and millisecond numbers.
 * @param {object|Date|number} timestamp - The timestamp to convert.
 * @returns {Date|null} A valid Date object or null if the timestamp is invalid.
 */
const getSafeDate = (timestamp) => {
    if (!timestamp) return null;
    // Handles live Firestore Timestamp objects
    if (typeof timestamp.toDate === 'function') {
        return timestamp.toDate();
    }
    // Handles serialized Firestore Timestamps (from JSON, etc.)
    if (timestamp.seconds && typeof timestamp.seconds === 'number') {
        return new Date(timestamp.seconds * 1000);
    }
    // Handles JS Dates or millisecond numbers
    const date = new Date(timestamp);
    if (!isNaN(date.getTime())) {
        return date;
    }
    return null;
};

const PrisonMenu = ({ cityGameState, onClose, onReleaseHero }) => { // Added onReleaseHero prop
    const prisoners = cityGameState.prisoners || [];
    const prisonLevel = cityGameState.buildings.prison?.level || 0;
    // Capacity starts at 5 and increases by 1 per level, up to 29 at max level 25.
    const capacity = prisonLevel > 0 ? prisonLevel + 4 : 0;

    const prisonRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 500) / 2,
        y: (window.innerHeight - 700) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('prison-header') || e.target.parentElement.classList.contains('prison-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);


    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div
                ref={prisonRef}
                className="prison-menu-container"
                onClick={e => e.stopPropagation()}
                onMouseDown={handleMouseDown}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="prison-header">
                    <h3>Prison (Level {prisonLevel})</h3>
                    <p>Capacity: {prisoners.length} / {capacity}</p>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="prison-content">
                    {prisoners.length > 0 ? (
                        prisoners.map((prisoner, index) => { // Added index for a unique key
                            const hero = heroesConfig[prisoner.heroId];
                            if (!hero) return null;
                            
                            // Duration starts at 8 hours and increases up to 3 days at max level.
                            const durationSeconds = 28800 + (prisonLevel - 1) * 9600;
                            
                            // Use the new helper function to safely get the date
                            const capturedTime = getSafeDate(prisoner.capturedAt);
                            const executionTime = capturedTime ? new Date(capturedTime.getTime() + durationSeconds * 1000) : null;

                            return (
                                // Using index in the key to ensure it's unique, preventing rendering issues.
                                <div key={`${prisoner.heroId}-${index}`} className="prisoner-item">
                                    <img src={heroImages[hero.image]} alt={hero.name} className="prisoner-avatar" />
                                    <div className="prisoner-info">
                                        <p className="prisoner-name">{hero.name}</p>
                                        <p className="prisoner-owner">Owner: {prisoner.ownerUsername}</p>
                                        {/* Display the city the hero was captured from */}
                                        <p className="prisoner-city">From: {prisoner.originCityName || 'Unknown City'}</p>
                                        <p className="execution-timer">
                                            Execution in: 
                                            {executionTime ? <Countdown arrivalTime={executionTime} /> : 'Calculating...'}
                                        </p>
                                    </div>
                                    <div className="prisoner-actions">
                                        {/* Added Release button, will call the onReleaseHero function */}
                                        <button onClick={() => onReleaseHero(prisoner)} className="release-btn">Release</button>
                                    </div>
                                </div>
                            );
                        })
                    ) : (
                        <p className="text-center text-gray-500">The prison is empty.</p>
                    )}
                </div>
                 <div className="prison-footer">
                    <p className="text-xs italic">Heroes are executed after their timer runs out. Executed heroes can only be revived with a 'Soulstone'. If this city is conquered, all prisoners will be freed.</p>
                </div>
            </div>
        </div>
    );
};

export default PrisonMenu;
</file>

<file path="src/components/city/RecruitmentPanel.css">
// src/components/city/RecruitmentPanel.js
import React from 'react';
import UnitQueue from './UnitQueue';
import './RecruitmentPanel.css';

const RecruitmentPanel = ({ playerCities, onCancelTrain, onClose }) => {
    const allQueues = Object.values(playerCities).map(city => ({
        cityName: city.cityName,
        unitQueue: city.unitQueue || [],
        healQueue: city.healQueue || [],
        cityId: city.id,
    })).filter(city => city.unitQueue.length > 0 || city.healQueue.length > 0);

    return (
        <div className="fixed inset-0 z-40 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="recruitment-panel-bg w-full max-w-2xl rounded-lg" onClick={e => e.stopPropagation()}>
                <div className="recruitment-header rounded-t-sm">
                    <h3>Recruitment & Healing Overview</h3>
                </div>
                <div className="max-h-[60vh] overflow-y-auto p-4 space-y-4">
                    {allQueues.length > 0 ? (
                        allQueues.map(city => (
                            <div key={city.cityId}>
                                <h4 className="font-bold text-xl mb-2">{city.cityName}</h4>
                                {city.unitQueue.length > 0 && (
                                    <UnitQueue
                                        unitQueue={city.unitQueue}
                                        onCancel={(index) => onCancelTrain(city.cityId, index, false)}
                                        title="Training"
                                    />
                                )}
                                {city.healQueue.length > 0 && (
                                     <UnitQueue
                                        unitQueue={city.healQueue}
                                        onCancel={(index) => onCancelTrain(city.cityId, index, true)}
                                        title="Healing"
                                    />
                                )}
                            </div>
                        ))
                    ) : (
                        <p className="p-8 text-center text-gray-700 italic">No active recruitment or healing queues.</p>
                    )}
                </div>
            </div>
        </div>
    );
};

export default RecruitmentPanel;
</file>

<file path="src/components/city/RecruitmentPanel.js">
// src/components/city/RecruitmentToolTip.js
import React from 'react';
import Countdown from '../map/Countdown';
import unitConfig from '../../gameData/units.json';
import './RecruitmentToolTip.css';

const images = {};
const imageContext = require.context('../../images/troops', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    images[key] = imageContext(item);
});

const RecruitmentTooltip = ({ playerCities, onCancelTrain, isLocked, countdown }) => {
    // #comment Safely converts Firestore Timestamps or JS Dates into a JS Date object
    const getSafeDate = (timestamp) => {
        if (!timestamp) return null;
        if (typeof timestamp.toDate === 'function') {
            return timestamp.toDate(); // It's a Firestore Timestamp
        }
        return new Date(timestamp); // It's a JS Date or milliseconds
    };
    
    // #comment Combine all relevant queues (barracks, shipyard, divine, heal) from all cities
    const allQueues = Object.values(playerCities).flatMap(city => {
        const barracks = (city.barracksQueue || []).map((item, index) => ({ ...item, cityId: city.id, cityName: city.cityName, isHealing: false, queueType: 'barracks', index }));
        const shipyard = (city.shipyardQueue || []).map((item, index) => ({ ...item, cityId: city.id, cityName: city.cityName, isHealing: false, queueType: 'shipyard', index }));
        const divine = (city.divineTempleQueue || []).map((item, index) => ({ ...item, cityId: city.id, cityName: city.cityName, isHealing: false, queueType: 'divineTemple', index }));
        const healing = (city.healQueue || []).map((item, index) => ({ ...item, cityId: city.id, cityName: city.cityName, isHealing: true, queueType: 'heal', index }));
        return [...barracks, ...shipyard, ...divine, ...healing];
    })
    .filter(item => {
        const endDate = getSafeDate(item.endTime);
        return endDate && endDate > new Date(); // Filter out completed items
    })
    .sort((a, b) => {
        const dateA = getSafeDate(a.endTime) || new Date(0);
        const dateB = getSafeDate(b.endTime) || new Date(0);
        return dateA - dateB;
    });


    if (allQueues.length === 0) {
        return (
            <div className="activity-tooltip">
                <p className="p-4 text-center text-sm">No active recruitments.</p>
            </div>
        );
    }

    return (
        <div className="activity-tooltip">
            {allQueues.map((item) => {
                const unit = unitConfig[item.unitId];
                return (
                    <div key={`${item.cityId}-${item.queueType}-${item.index}`} className="tooltip-item">
                        <img src={images[unit.image]} alt={unit.name} className="tooltip-item-image" />
                        <div className="tooltip-item-details">
                            <p className="font-bold">{item.amount}x {unit.name} <span className="text-xs text-gray-400">({item.cityName})</span></p>
                            <div className="tooltip-timer">
                                <Countdown arrivalTime={item.endTime} />
                            </div>
                        </div>
                        <button onClick={() => onCancelTrain(item, item.queueType)} className="tooltip-cancel-btn">&times;</button>
                    </div>
                );
            })}
            <div className="tooltip-lock-timer">
                {isLocked ? '🔒' : countdown}
            </div>
        </div>
    );
};

export default RecruitmentTooltip;
</file>

<file path="src/components/city/RecruitmentToolTip.css">
/* src/components/city/RecruitmentTooltip.css */
.recruitment-tooltip {
    position: absolute; 
    top: calc(100% + 10px);
    left: 50%; /* Center the tooltip */
    transform: translateX(-50%); /* Adjust for centering */
    width: 350px;
    background-color: #F5DEB3;
    border: 4px solid #8B4513;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    z-index: 100;
    color: #4a2c2a;
}

.recruitment-tooltip-item {
    display: flex;
    align-items: center;
    padding: 8px;
    border-bottom: 1px solid #d2b48c;
}
.recruitment-tooltip-item:last-child {
    border-bottom: none;
}

.recruitment-tooltip-item-image {
    width: 48px;
    height: 48px;
    margin-right: 12px;
    background-color: rgba(0,0,0,0.1);
    border-radius: 4px;
    padding: 2px;
}

.recruitment-tooltip-item-details {
    flex-grow: 1;
}

.recruitment-tooltip-timer {
    font-family: monospace;
    font-weight: bold;
    background-color: #333;
    color: #f0e68c;
    padding: 2px 6px;
    border-radius: 4px;
    display: inline-block;
}

.recruitment-tooltip-cancel-btn {
    background-color: #c0392b;
    color: white;
    border: 1px solid #a03022;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    font-weight: bold;
    font-size: 16px;
    cursor: pointer;
    margin-left: 12px;
}
.recruitment-tooltip-cancel-btn:hover {
    background-color: #e74c3c;
}

.recruitment-tooltip-lock-timer {
    position: absolute;
    bottom: -14px; /* Position half outside */
    right: -14px; /* Position half outside */
    width: 28px;
    height: 28px;
    background-color: #4a2c2a;
    color: #f0e68c;
    border: 2px solid #8B4513;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: bold;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    z-index: 101; /* Ensure timer is on top */
    pointer-events: all; /* Allow clicking the timer */
     min-width: 28px;
}
</file>

<file path="src/components/city/RecruitmentToolTip.js">
// src/components/city/RecruitmentToolTip.js
import React from 'react';
import Countdown from '../map/Countdown';
import unitConfig from '../../gameData/units.json';
import './RecruitmentToolTip.css';

const images = {};
const imageContext = require.context('../../images/troops', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    images[key] = imageContext(item);
});

const RecruitmentTooltip = ({ playerCities, onCancelTrain, isLocked, countdown }) => {
    // #comment Safely converts Firestore Timestamps or JS Dates into a JS Date object
    const getSafeDate = (timestamp) => {
        if (!timestamp) return null;
        if (typeof timestamp.toDate === 'function') {
            return timestamp.toDate(); // It's a Firestore Timestamp
        }
        return new Date(timestamp); // It's a JS Date or milliseconds
    };
    
    // #comment Combine all relevant queues (barracks, shipyard, divine, heal) from all cities
    const allQueues = Object.values(playerCities).flatMap(city => {
        const barracks = (city.barracksQueue || []).map((item, index) => ({ ...item, cityId: city.id, cityName: city.cityName, isHealing: false, queueType: 'barracks', index }));
        const shipyard = (city.shipyardQueue || []).map((item, index) => ({ ...item, cityId: city.id, cityName: city.cityName, isHealing: false, queueType: 'shipyard', index }));
        const divine = (city.divineTempleQueue || []).map((item, index) => ({ ...item, cityId: city.id, cityName: city.cityName, isHealing: false, queueType: 'divineTemple', index }));
        const healing = (city.healQueue || []).map((item, index) => ({ ...item, cityId: city.id, cityName: city.cityName, isHealing: true, queueType: 'heal', index }));
        return [...barracks, ...shipyard, ...divine, ...healing];
    })
    .filter(item => {
        const endDate = getSafeDate(item.endTime);
        return endDate && endDate > new Date(); // Filter out completed items
    })
    .sort((a, b) => {
        const dateA = getSafeDate(a.endTime) || new Date(0);
        const dateB = getSafeDate(b.endTime) || new Date(0);
        return dateA - dateB;
    });

    const content = allQueues.length > 0 ? (
        allQueues.map((item) => {
            const unit = unitConfig[item.unitId];
            return (
                <div key={`${item.cityId}-${item.queueType}-${item.index}`} className="recruitment-tooltip-item">
                    <img src={images[unit.image]} alt={unit.name} className="recruitment-tooltip-item-image" />
                    <div className="recruitment-tooltip-item-details">
                        <p className="font-bold">{item.amount}x {unit.name} <span className="text-xs text-gray-400">({item.cityName})</span></p>
                        <div className="recruitment-tooltip-timer">
                            <Countdown arrivalTime={item.endTime} />
                        </div>
                    </div>
                    <button onClick={() => onCancelTrain(item, item.queueType)} className="recruitment-tooltip-cancel-btn">&times;</button>
                </div>
            );
        })
    ) : (
        <p className="p-4 text-center text-sm">No active recruitments.</p>
    );

    return (
        <div className="recruitment-tooltip">
            {content}
            <div className="recruitment-tooltip-lock-timer">
                {isLocked ? '🔒' : countdown}
            </div>
        </div>
    );
};

export default RecruitmentTooltip;
</file>

<file path="src/components/city/ReinforcementModal.js">
import React from 'react';
import unitConfig from '../../gameData/units.json';
import { useAuth } from '../../contexts/AuthContext';

const images = {};
const imageContext = require.context('../../images/troops', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    images[key] = imageContext(item);
});

const ReinforcementsModal = ({ city, onClose, onOpenWithdraw }) => {
    const { currentUser } = useAuth();
    const reinforcements = city.reinforcements || {};

    const renderUnit = ([unitId, count]) => {
        const unit = unitConfig[unitId];
        if (!unit || !unit.image) return null;
        const imageUrl = images[unit.image];
        if (!imageUrl) return null;
        return (
            <div key={unitId} className="flex items-center gap-2">
                <img src={imageUrl} alt={unit.name} className="w-8 h-8 object-contain" />
                <span>{unit.name}: {count}</span>
            </div>
        );
    };

    const canWithdraw = Object.values(reinforcements).some(reinf => reinf.ownerId === currentUser.uid);

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-2xl border-2 border-gray-600 flex flex-col max-h-[90vh]" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="font-title text-3xl text-white">Reinforcements in {city.cityName}</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>

                <div className="flex-grow overflow-y-auto pr-2 space-y-4">
                    {Object.keys(reinforcements).length > 0 ? (
                        Object.entries(reinforcements).map(([originCityId, reinfData]) => (
                            <div key={originCityId} className="bg-gray-700 p-3 rounded-lg">
                                <h4 className="font-bold text-yellow-400 mb-2">From: {reinfData.originCityName}</h4>
                                <div className="space-y-1">
                                    {Object.entries(reinfData.units || {}).map(renderUnit)}
                                </div>
                            </div>
                        ))
                    ) : (
                        <p className="text-center text-gray-400">No reinforcements in this city.</p>
                    )}
                </div>

                <div className="mt-4 pt-4 border-t border-gray-600 flex justify-end">
                    {canWithdraw && (
                        <button onClick={() => onOpenWithdraw(city)} className="btn btn-confirm py-2 px-6">
                            Withdraw Troops
                        </button>
                    )}
                </div>
            </div>
        </div>
    );
};

export default ReinforcementsModal;
</file>

<file path="src/components/city/ResearchQueue.css">
/* src/components/city/ResearchQueue.css */
.research-queue-tooltip {
    /* Position is now handled by inline styles */
    width: 280px;
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 4px solid #8B4513; /* saddlebrown */
    box-shadow: 0 0 15px rgba(0,0,0,0.5);
    color: #4a2c2a;
    padding: 12px;
    border-radius: 6px;
    z-index: 110; /* Ensure it's on top */
    pointer-events: none; /* So it doesn't interfere with mouse events on the item */
    text-align: left;
}

.research-tooltip-title {
    font-family: 'IM Fell English SC', serif;
    font-size: 1.25rem;
    text-align: center;
    margin-bottom: 12px;
    border-bottom: 1px solid #d2b48c;
    padding-bottom: 8px;
}

.research-tooltip-info {
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 8px;
    align-items: center;
}

.research-tooltip-info dt {
    font-weight: bold;
}

.research-tooltip-info dd {
    font-family: monospace;
    background-color: rgba(0,0,0,0.7);
    color: #f0e68c;
    padding: 4px 8px;
    border-radius: 4px;
    text-align: center;
}
</file>

<file path="src/components/city/ResearchQueue.js">
// src/components/city/ResearchQueue.js
import React, { useState, useEffect, useRef } from 'react';
import researchConfig from '../../gameData/research.json';
import './ResearchQueue.css'; // #comment Import new CSS

const formatTime = (seconds) => {
    if (seconds < 0) seconds = 0;
    const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
    const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
    const s = Math.floor(seconds % 60).toString().padStart(2, '0');
    return `${h}:${m}:${s}`;
};

const ResearchQueueItem = ({ item, onCancel, isFirst, isLast, onHover, onLeave }) => {
    const [timeLeft, setTimeLeft] = useState(0);
    const itemRef = useRef(null);

    useEffect(() => {
        if (!isFirst) return; // Only calculate time for the first item.

        const calculateTimeLeft = () => {
            const endTime = (item.endTime instanceof Date) ? item.endTime : new Date(item.endTime);
            if (isNaN(endTime.getTime())) {
                setTimeLeft(0);
                return;
            }
            const remaining = Math.max(0, endTime.getTime() - Date.now());
            setTimeLeft(remaining / 1000);
        };

        calculateTimeLeft();
        const interval = setInterval(calculateTimeLeft, 1000);
        return () => clearInterval(interval);
    }, [item.endTime, isFirst]);

    const research = researchConfig[item.researchId];
    if (!research) return null;

    return (
        <div
            ref={itemRef}
            className="relative p-2 bg-amber-100/50 rounded flex justify-between items-center"
            onMouseEnter={() => onHover(item, itemRef.current)}
            onMouseLeave={onLeave}
        >
            <span className="font-semibold">{research.name}</span>
            <div className="flex items-center gap-4">
                {isFirst && <span className="font-mono text-gray-800 bg-white/50 px-2 py-1 rounded">{formatTime(timeLeft)}</span>}
                {isLast && (
                    <button
                        onClick={onCancel}
                        className="text-red-600 hover:text-red-500 font-bold text-xl leading-none px-2 rounded-full"
                        title="Cancel Research"
                    >
                        &times;
                    </button>
                )}
            </div>
        </div>
    );
};

const ResearchQueue = ({ researchQueue, onCancel }) => {
    const [hoveredItem, setHoveredItem] = useState(null);
    const [tooltipStyle, setTooltipStyle] = useState({ display: 'none' });
    const tooltipTimeoutRef = useRef(null);
    const queueContainerRef = useRef(null);

    // #comment handle mouse enter to show tooltip and calculate its position
    const handleMouseEnter = (item, element) => {
        clearTimeout(tooltipTimeoutRef.current);
        if (element && queueContainerRef.current) {
            const itemRect = element.getBoundingClientRect();

            setTooltipStyle({
                position: 'fixed', // Use fixed to break out of the modal
                bottom: `${window.innerHeight - itemRect.top + 8}px`, // Position above the item
                left: `${itemRect.left + (itemRect.width / 2)}px`,
                transform: 'translateX(-50%)',
            });
            setHoveredItem(item);
        }
    };

    // #comment handle mouse leave to hide tooltip
    const handleMouseLeave = () => {
        tooltipTimeoutRef.current = setTimeout(() => {
            setHoveredItem(null);
        }, 200);
    };
    
    // #comment Get the completion time of the last item in the queue
    const totalCompletionTime = researchQueue && researchQueue.length > 0
        ? researchQueue[researchQueue.length - 1].endTime
        : null;

    const renderTooltip = () => {
        if (!hoveredItem) return null;
        const research = researchConfig[hoveredItem.researchId];
        const totalCompletionTimeString = totalCompletionTime ? new Date(totalCompletionTime).toLocaleTimeString() : 'N/A';

        return (
            <div className="research-queue-tooltip" style={tooltipStyle}>
                <h3 className="research-tooltip-title">{research.name}</h3>
                <p className="text-sm mb-2">{research.description}</p>
                <dl className="research-tooltip-info">
                    <dt>Time:</dt>
                    <dd>{formatTime(research.cost.time)}</dd>
                    <dt>Queue Completion:</dt>
                    <dd>{totalCompletionTimeString}</dd>
                </dl>
            </div>
        );
    };

    if (!researchQueue || researchQueue.length === 0) {
        return (
            <div className="bg-gray-900/80 p-3 mt-auto flex-shrink-0">
                <h4 className="text-lg font-semibold text-gray-400 text-center">Research queue is empty.</h4>
            </div>
        );
    }

    return (
        <div className="bg-gray-900/80 p-3 mt-auto flex-shrink-0" ref={queueContainerRef}>
            <h4 className="text-lg font-semibold text-yellow-400 mb-2">Research Queue ({researchQueue.length}/5)</h4>
            <div className="space-y-2">
                {researchQueue.map((item, index) => (
                    <ResearchQueueItem
                        key={`${item.researchId}-${index}`}
                        item={item}
                        onCancel={() => onCancel(index)}
                        isFirst={index === 0}
                        isLast={index === researchQueue.length - 1}
                        onHover={handleMouseEnter}
                        onLeave={handleMouseLeave}
                    />
                ))}
            </div>
            {renderTooltip()}
        </div>
    );
};

export default ResearchQueue;
</file>

<file path="src/components/city/SenateView.css">
.senate-view-container {
    background-image: url('../../images/bg/senate_view_bg.png');
    background-size: 100% 100%;
    background-position: center;
    background-repeat: no-repeat;
    color: #4a2c2a; /* Dark brown text for readability on parchment */
    position: fixed;
    z-index: 50;
}

.senate-header {
    cursor: move;
}

/* Make inner containers semi-transparent to show the background */
.senate-view-container .bg-gray-900,
.senate-view-container .bg-gray-800,
.senate-view-container .bg-gray-700,
.senate-view-container .bg-gray-700\/80 {
    background-color: rgba(245, 222, 179, 0.6) !important; /* Semi-transparent wheat color */
    border-color: #8B4513 !important; /* Saddle brown for borders */
}

/* Adjust text colors for better contrast on the new background */
.senate-view-container .text-white,
.senate-view-container .text-gray-300,
.senate-view-container .text-gray-400 {
    color: #4a2c2a !important; /* Dark brown */
}

.senate-view-container .text-yellow-300 {
    color: #8B4513 !important; /* Saddle brown for titles */
}

.senate-view-container .text-yellow-400 {
    color: #5D4037 !important; /* Darker brown for main titles */
}

.senate-view-container .text-green-400 {
    color: #228B22 !important; /* Forest green for positive numbers */
}

.senate-view-container .text-blue-300 {
    color: #00008B !important; /* Dark blue */
}


/* Style the tabs to look like old paper/stone */
.senate-view-container .flex-1.p-2.text-lg.font-bold {
    background-color: rgba(210, 180, 140, 0.7) !important; /* Tan color */
    border-bottom: 2px solid transparent !important;
}

.senate-view-container .flex-1.p-2.text-lg.font-bold.bg-gray-700 {
    background-color: rgba(139, 69, 19, 0.7) !important; /* Saddle brown for active tab */
    border-bottom-color: #f0e68c !important; /* Khaki for active indicator */
    color: #f0e68c !important;
}

/* Style building cards */
.building-card-senate {
    background-color: rgba(210, 180, 140, 0.8) !important;
    border: 2px solid #8B4513 !important;
}

.btn-upgrade-senate {
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #4a2c2a;
}

.btn-disabled-senate {
    background: #d2b48c !important;
    color: #6b4a2b !important;
}

.dependency-line {
    stroke: #d4af37; /* Gold color */
    stroke-width: 2;
    filter: drop-shadow(0 0 3px #fde047) drop-shadow(0 0 5px #fef08a);
    transition: all 0.3s ease;
}
</file>

<file path="src/components/city/SenateView.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { collection, onSnapshot, doc, setDoc, deleteDoc } from 'firebase/firestore';
import { db } from '../../firebase/config';
import buildingConfig from '../../gameData/buildings.json';
import specialBuildingsConfig from '../../gameData/specialBuildings.json';
import BuildQueue from './BuildQueue';
import './SenateView.css'; // Import the new CSS file

const buildingImages = {};
const contexts = [
    require.context('../../images/buildings', false, /\.(png|jpe?g|svg)$/),
    require.context('../../images/special_buildings', false, /\.(png|jpe?g|svg)$/)
];
contexts.forEach(context => {
    context.keys().forEach((item) => {
        const key = item.replace('./', '');
        buildingImages[key] = context(item);
    });
});

// #comment A reusable confirmation modal
const ConfirmationModal = ({ message, onConfirm, onCancel }) => (
    <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[100]">
        <div className="bg-gray-800 p-6 rounded-lg text-white">
            <p className="mb-4">{message}</p>
            <div className="flex justify-end gap-2">
                <button onClick={onCancel} className="btn btn-secondary">Cancel</button>
                <button onClick={onConfirm} className="btn btn-danger">Confirm</button>
            </div>
        </div>
    </div>
);

// #comment Component to manage workers in production buildings
const WorkerManager = ({ buildings, onAddWorker, onRemoveWorker, getMaxWorkerSlots, availablePopulation }) => {
    const productionBuildings = ['timber_camp', 'quarry', 'silver_mine'];
    return (
        <div className="bg-gray-900 rounded-lg p-4">
            <h3 className="text-xl font-bold font-title text-yellow-300 mb-3 text-center">Worker Management</h3>
            <div className="space-y-3">
                {productionBuildings.map(id => {
                    const building = buildings[id];
                    if (!building || building.level === 0) return null;
                    const workers = building.workers || 0;
                    const maxWorkers = getMaxWorkerSlots(building.level);
                    return (
                        <div key={id} className="bg-gray-700 p-3 rounded-lg flex justify-between items-center">
                            <div>
                                <h4 className="font-semibold text-white">{buildingConfig[id].name}</h4>
                                <p className="text-sm text-gray-400">Workers: {workers} / {maxWorkers}</p>
                            </div>
                            <div className="flex items-center gap-2">
                                <button
                                    onClick={() => onRemoveWorker(id)}
                                    disabled={workers <= 0}
                                    className="btn btn-danger w-8 h-8 flex items-center justify-center text-lg"
                                >-</button>
                                <button
                                    onClick={() => onAddWorker(id)}
                                    disabled={workers >= maxWorkers || availablePopulation < 20}
                                    className="btn btn-confirm w-8 h-8 flex items-center justify-center text-lg"
                                >+</button>
                            </div>
                        </div>
                    );
                })}
            </div>
             <p className="text-xs mt-2 text-gray-400 text-center">Each worker costs 20 population.</p>
        </div>
    );
};

const PresetManager = ({ presets, selectedPresetId, setSelectedPresetId, handleApplyPreset, setIsSavingPreset, handleDeletePreset }) => {
    const selectedPreset = presets.find(p => p.id === selectedPresetId);
    return (
        <div className="bg-gray-900 rounded-lg p-4">
            <h3 className="text-xl font-bold font-title text-yellow-300 mb-3 text-center">Worker Presets</h3>
            <div className="flex items-center gap-2">
                <select
                    value={selectedPresetId}
                    onChange={(e) => setSelectedPresetId(e.target.value)}
                    className="bg-gray-700 text-white p-2 rounded w-full"
                >
                    <option value="">Select a Preset</option>
                    {presets.map(p => <option key={p.id} value={p.id}>{p.name}</option>)}
                </select>
                <button onClick={handleApplyPreset} disabled={!selectedPresetId} className="btn btn-primary text-sm py-2 px-3 flex-shrink-0">Apply</button>
                <button onClick={() => setIsSavingPreset(true)} disabled={presets.length >= 3} className="btn btn-primary text-sm py-2 px-3 flex-shrink-0" title={presets.length >= 3 ? "Maximum of 3 presets reached" : "Save current layout"}>Save</button>
                <button onClick={handleDeletePreset} disabled={!selectedPresetId} className="btn btn-danger text-sm py-2 px-3 flex-shrink-0">Delete</button>
            </div>
            {selectedPreset && (
                <div className="mt-4 p-2 bg-gray-800 rounded-lg max-h-48 overflow-y-auto">
                    <h4 className="font-semibold text-center mb-2">Preset Workers</h4>
                    <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                        {selectedPreset.workers && Object.entries(selectedPreset.workers)
                            .sort(([idA], [idB]) => buildingConfig[idA].name.localeCompare(buildingConfig[idB].name))
                            .map(([id, count]) => (
                                <div key={id} className="flex justify-between">
                                    <span>{buildingConfig[id].name}</span>
                                    <span className="font-bold">{count}</span>
                                </div>
                            ))}
                    </div>
                </div>
            )}
        </div>
    );
};

const BuildingCard = ({ id, config, level, finalQueuedLevel, cost, canAfford, onUpgrade, isQueueFull, isMaxLevel }) => {
    let buttonText;
    if (level === 0 && finalQueuedLevel === 0) {
        buttonText = 'Build';
    } else {
        buttonText = `Expand to ${finalQueuedLevel + 1}`;
    }
    if (isMaxLevel) buttonText = 'Max Level';
    let disabledReason = '';
    if (isMaxLevel) disabledReason = 'Max Level';
    else if (isQueueFull) disabledReason = 'Queue Full';
    else if (!canAfford) disabledReason = 'Not enough resources/pop';

    return (
        <div className="bg-gray-700/80 border-2 border-gray-600 rounded-lg p-2 w-48 text-center flex flex-col items-center relative shadow-lg">
            <div className="absolute -top-6 left-1/2 -translate-x-1/2 w-0.5 h-6 bg-gray-500/50"></div>
            <h4 className="font-bold text-yellow-400 text-base">{config.name}</h4>
            <p className="text-sm text-gray-300 font-semibold">
                Level {level} {finalQueuedLevel > level ? `(-> ${finalQueuedLevel})` : ''}
            </p>
            <img src={buildingImages[config.image]} alt={config.name} className="w-20 h-20 object-contain my-1" />
            <div className="text-xs text-gray-400 mb-2">
                <span>{cost.wood}W</span>, <span>{cost.stone}S</span>, <span>{cost.silver}Ag</span>, <span>{cost.population}P</span>
            </div>
            <button
                onClick={() => onUpgrade(id)}
                disabled={!canAfford || isQueueFull || isMaxLevel}
                className={`w-full py-1.5 rounded font-bold text-sm transition-colors ${!canAfford || isQueueFull || isMaxLevel ? 'btn-disabled' : 'btn-upgrade'}`}
            >
                {disabledReason || buttonText}
            </button>
        </div>
    );
};

const SpecialBuildingCard = ({ cityGameState, onOpenSpecialBuildingMenu }) => {
    const specialBuildingId = cityGameState.specialBuilding;
    const config = specialBuildingId ? specialBuildingsConfig[specialBuildingId] : buildingConfig.special_building_plot;
    return (
        <div className="bg-gray-700/80 border-2 border-gray-600 rounded-lg p-2 w-48 text-center flex flex-col items-center relative shadow-lg">
            <div className="absolute -top-6 left-1/2 -translate-x-1/2 w-0.5 h-6 bg-gray-500/50 z-0"></div>
            <h4 className="font-bold text-yellow-400 text-base">{config.name}</h4>
            <p className="text-sm text-gray-300 font-semibold">{specialBuildingId ? 'Constructed' : 'Empty Plot'}</p>
            <img src={buildingImages[config.image]} alt={config.name} className="w-20 h-20 object-contain my-1" />
            <p className="text-xs text-gray-400 mb-2 h-8 overflow-hidden">{config.description}</p>
            <button
                onClick={onOpenSpecialBuildingMenu}
                disabled={!!specialBuildingId}
                className={`w-full py-1.5 rounded font-bold text-sm transition-colors ${!!specialBuildingId ? 'btn-disabled' : 'btn-upgrade'}`}
            >
                {specialBuildingId ? 'Constructed' : 'Build Wonder'}
            </button>
        </div>
    );
};

const SenateView = ({ buildings, resources, onUpgrade, onDemolish, getUpgradeCost, onClose, usedPopulation, maxPopulation, buildQueue = [], onCancelBuild, setMessage, cityGameState, onOpenSpecialBuildingMenu, onDemolishSpecialBuilding, currentUser, worldId, onAddWorker, onRemoveWorker, getMaxWorkerSlots, availablePopulation, onApplyWorkerPreset }) => {
    const [activeTab, setActiveTab] = useState('upgrade');
    const [presets, setPresets] = useState([]);
    const [selectedPresetId, setSelectedPresetId] = useState('');
    const [isSavingPreset, setIsSavingPreset] = useState(false);
    const [newPresetName, setNewPresetName] = useState('');
    const [confirmAction, setConfirmAction] = useState(null);
    const senateRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 1000) / 2,
        y: (window.innerHeight - 650) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('senate-header') || e.target.parentElement.classList.contains('senate-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);
    

    const buildingRows = [
        ['senate'],
        ['timber_camp', 'quarry', 'silver_mine', 'farm'],
        ['warehouse', 'market', 'barracks', 'shipyard'],
        ['academy', 'temple', 'divine_temple', 'hospital'],
        ['city_wall', 'cave', 'prison', 'heroes_altar'],
        ['special_building_plot']
    ];

    // #comment Fetch user's building presets
    useEffect(() => {
        if (!currentUser || !worldId) return;
        const presetsRef = collection(db, `users/${currentUser.uid}/games/${worldId}/presets`);
        const unsubscribe = onSnapshot(presetsRef, (snapshot) => {
            const presetsData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setPresets(presetsData);
        });
        return () => unsubscribe();
    }, [currentUser, worldId]);

    const getFinalLevelInQueue = (buildingId) => {
        let finalLevel = buildings[buildingId]?.level || 0;
        const tasksForBuilding = (buildQueue || []).filter(task => task.buildingId === buildingId && task.type !== 'demolish');
        const demolishTasks = (buildQueue || []).filter(task => task.buildingId === buildingId && task.type === 'demolish');
        if (tasksForBuilding.length > 0) {
            finalLevel = Math.max(...tasksForBuilding.map(t => t.level));
        }
        if(demolishTasks.length > 0) {
            finalLevel = Math.min(...demolishTasks.map(t => t.level));
        }
        return finalLevel;
    };

    const handleSavePreset = async () => {
        if (!newPresetName.trim()) {
            setMessage("Please enter a name for the preset.");
            return;
        }
        const presetId = newPresetName.trim().toLowerCase().replace(/\s+/g, '-');
        const presetDocRef = doc(db, `users/${currentUser.uid}/games/${worldId}/presets`, presetId);
        const existingPreset = presets.find(p => p.id === presetId);
        if (presets.length >= 3 && !existingPreset) {
            setMessage("You can only have a maximum of 3 presets. Delete one to save a new one.");
            setIsSavingPreset(false);
            return;
        }

        const onConfirmSave = async () => {
            const currentWorkers = {};
            const productionBuildings = ['timber_camp', 'quarry', 'silver_mine'];
            productionBuildings.forEach(id => {
                currentWorkers[id] = buildings[id]?.workers || 0;
            });
            const presetData = {
                name: newPresetName.trim(),
                workers: currentWorkers
            };
            await setDoc(presetDocRef, presetData);
            setNewPresetName('');
            setIsSavingPreset(false);
            setSelectedPresetId(presetId);
            setConfirmAction(null);
            setMessage(`Preset '${presetData.name}' saved successfully!`);
        };

        if (existingPreset) {
            setConfirmAction({
                message: `A preset named "${newPresetName.trim()}" already exists. Do you want to overwrite it?`,
                onConfirm: onConfirmSave
            });
        } else {
            await onConfirmSave();
        }
    };

    // #comment Delete the selected preset after confirmation
    const handleDeletePreset = async () => {
        if (!selectedPresetId) return;
        const presetName = presets.find(p => p.id === selectedPresetId)?.name;
        setConfirmAction({
            message: `Are you sure you want to delete the preset "${presetName}"?`,
            onConfirm: async () => {
                const presetDocRef = doc(db, `users/${currentUser.uid}/games/${worldId}/presets`, selectedPresetId);
                await deleteDoc(presetDocRef);
                setSelectedPresetId('');
                setConfirmAction(null);
                setMessage(`Preset '${presetName}' deleted.`);
            }
        });
    };

    // #comment Apply worker distribution from the selected preset
    const handleApplyPreset = () => {
        const selectedPreset = presets.find(p => p.id === selectedPresetId);
        if (!selectedPreset) {
            setMessage("Please select a preset to apply.");
            return;
        }
        onApplyWorkerPreset(selectedPreset);
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center z-30">
            {confirmAction && (
                <ConfirmationModal
                    message={confirmAction.message}
                    onConfirm={confirmAction.onConfirm}
                    onCancel={() => setConfirmAction(null)}
                />
            )}
            {isSavingPreset && (
                <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[100]">
                    <div className="bg-gray-800 p-6 rounded-lg">
                        <h3 className="text-lg font-bold mb-4 text-white">Save Worker Preset</h3>
                        <input
                            type="text"
                            value={newPresetName}
                            onChange={(e) => setNewPresetName(e.target.value)}
                            placeholder="Enter preset name..."
                            className="w-full bg-gray-700 p-2 rounded mb-4 text-white"
                        />
                        <div className="flex justify-end gap-2">
                            <button onClick={() => setIsSavingPreset(false)} className="btn btn-secondary">Cancel</button>
                            <button onClick={handleSavePreset} className="btn btn-confirm">Save</button>
                        </div>
                    </div>
                </div>
            )}
            <div
                ref={senateRef}
                className="senate-view-container text-white p-6 rounded-lg shadow-xl w-full max-w-6xl max-h-[90vh] flex flex-col"
                onClick={e => e.stopPropagation()}
                onMouseDown={handleMouseDown}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="flex justify-between items-center border-b border-gray-600 pb-3 mb-4 senate-header">
                    <h2 className="text-3xl font-bold font-title text-yellow-300">Senate</h2>
                    <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl">&times;</button>
                </div>
                <BuildQueue buildQueue={buildQueue} onCancel={onCancelBuild} />
                <div className='flex justify-between items-center mb-4 p-3 bg-gray-900 rounded-lg'>
                    <p className="text-lg">Population: <span className="font-bold text-green-400">{availablePopulation}</span> / {maxPopulation}</p>
                    <div className="flex gap-4">
                        <p>Wood: <span className='font-bold text-yellow-300'>{Math.floor(resources.wood)}</span></p>
                        <p>Stone: <span className='font-bold text-gray-300'>{Math.floor(resources.stone)}</span></p>
                        <p>Silver: <span className='font-bold text-blue-300'>{Math.floor(resources.silver)}</span></p>
                    </div>
                </div>
                <div className="flex border-b border-gray-600 mb-4">
                    <button onClick={() => setActiveTab('upgrade')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'upgrade' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Upgrade</button>
                    <button onClick={() => setActiveTab('demolish')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'demolish' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Demolish</button>
                    <button onClick={() => setActiveTab('management')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'management' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Management</button>
                </div>
                <div className="overflow-y-auto pr-2">
                    {activeTab === 'upgrade' && (
                        <div className="flex flex-col items-center space-y-12 py-6">
                            {buildingRows.map((row, rowIndex) => (
                                <div key={rowIndex} className="flex justify-center items-start gap-6 relative">
                                    {row.length > 1 && rowIndex > 0 && <div className="absolute -top-9 left-0 right-0 h-0.5 bg-gray-500/50 z-0 w-3/4 mx-auto"></div>}
                                    {row.map(id => {
                                        if (id === 'special_building_plot') {
                                            return <SpecialBuildingCard key={id} cityGameState={cityGameState} onOpenSpecialBuildingMenu={onOpenSpecialBuildingMenu} />;
                                        }
                                        const config = buildingConfig[id];
                                        if (config.constructible === false && id !== 'senate') return null;
                                        const currentLevel = buildings[id]?.level || 0;
                                        const finalQueuedLevel = getFinalLevelInQueue(id);
                                        const nextLevelToBuild = finalQueuedLevel + 1;
                                        const isMaxLevel = finalQueuedLevel >= (config.maxLevel || 99);
                                        const cost = getUpgradeCost(id, nextLevelToBuild);
                                        let canAfford = resources.wood >= cost.wood && resources.stone >= cost.stone && resources.silver >= cost.silver;
                                        if (id !== 'farm' && id !== 'warehouse') {
                                            canAfford = canAfford && (maxPopulation - usedPopulation >= cost.population);
                                        }
                                        const isQueueFull = (buildQueue || []).length >= 5;
                                        return (
                                            <BuildingCard
                                                key={id}
                                                id={id}
                                                config={config}
                                                level={currentLevel}
                                                finalQueuedLevel={finalQueuedLevel}
                                                cost={cost}
                                                canAfford={canAfford}
                                                onUpgrade={onUpgrade}
                                                isQueueFull={isQueueFull}
                                                isMaxLevel={isMaxLevel}
                                            />
                                        );
                                    })}
                                </div>
                            ))}
                        </div>
                    )}
                    {activeTab === 'demolish' && (
                         <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            {Object.entries(buildings)
                                .filter(([id, data]) => data.level > 0 && buildingConfig[id].constructible !== false && id !== 'senate')
                                .map(([id, data]) => {
                                    const config = buildingConfig[id];
                                    const finalLevel = getFinalLevelInQueue(id);
                                    const canDemolish = finalLevel > 0;
                                    const isQueueFull = (buildQueue || []).length >= 5;
                                    let buttonText = 'Demolish';
                                    if (finalLevel > 1) {
                                        buttonText = `Demolish to Lvl ${finalLevel - 1}`;
                                    }
                                    return (
                                        <div key={id} className="bg-gray-700 p-4 rounded-lg flex justify-between items-center">
                                            <div>
                                                <h4 className="text-xl font-semibold text-yellow-400">{config.name}</h4>
                                                <p className="text-sm text-gray-300">Level {data.level}</p>
                                            </div>
                                            <button
                                                onClick={() => onDemolish(id)}
                                                disabled={!canDemolish || isQueueFull}
                                                className={`py-2 px-4 rounded font-bold ${!canDemolish || isQueueFull ? 'btn-disabled' : 'btn-danger'}`}
                                            >
                                                {isQueueFull ? 'Queue Full' : !canDemolish ? 'At Lvl 0' : buttonText}
                                            </button>
                                        </div>
                                    );
                                })
                            }
                            {cityGameState.specialBuilding && (
                                <div className="bg-gray-700 p-4 rounded-lg flex justify-between items-center">
                                    <div>
                                        <h4 className="text-xl font-semibold text-yellow-400">{specialBuildingsConfig[cityGameState.specialBuilding].name}</h4>
                                        <p className="text-sm text-gray-300">Wonder</p>
                                    </div>
                                    <button
                                        onClick={onDemolishSpecialBuilding}
                                        className="py-2 px-4 rounded font-bold btn-danger"
                                    >
                                        Demolish
                                    </button>
                                </div>
                            )}
                        </div>
                    )}
                     {activeTab === 'management' && (
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 p-4">
                            <WorkerManager
                                buildings={buildings}
                                onAddWorker={onAddWorker}
                                onRemoveWorker={onRemoveWorker}
                                getMaxWorkerSlots={getMaxWorkerSlots}
                                availablePopulation={availablePopulation}
                            />
                            <PresetManager
                                presets={presets}
                                selectedPresetId={selectedPresetId}
                                setSelectedPresetId={setSelectedPresetId}
                                handleApplyPreset={handleApplyPreset}
                                setIsSavingPreset={setIsSavingPreset}
                                handleDeletePreset={handleDeletePreset}
                            />
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default SenateView;
</file>

<file path="src/components/city/ShipyardMenu.js">
// src/components/city/ShipyardMenu.js
import React, { useState, useEffect, useMemo, useRef, useCallback } from 'react';
import unitConfig from '../../gameData/units.json';
import UnitQueue from './UnitQueue';
import Modal from '../shared/Modal';
import { getTrainableNavalUnits } from '../../utils/nationality';

// Dynamically import all unit images
const unitImages = {};
const imageContext = require.context('../../images/troops', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    unitImages[key] = imageContext(item);
});

const UnitStats = ({ unit }) => (
    <div className="w-1/2 bg-gray-900 p-4 rounded-lg space-y-2">
        <h5 className="font-bold text-lg text-yellow-300 mb-3">Unit Information</h5>
        <div className="flex items-center justify-between text-sm"><span>⚔️ Attack</span><span className="font-bold">{unit.attack}</span></div>
        <div className="flex items-center justify-between text-sm"><span>🛡️ Defense</span><span className="font-bold">{unit.defense}</span></div>
        <div className="flex items-center justify-between text-sm"><span>⛵ Speed</span><span className="font-bold">{unit.speed}</span></div>
        {unit.capacity > 0 && <div className="flex items-center justify-between text-sm"><span>📦 Capacity</span><span className="font-bold">{unit.capacity}</span></div>}
    </div>
);

const ShipyardMenu = ({ resources, availablePopulation, onTrain, onClose, cityGameState, unitQueue, onCancelTrain }) => {
    const navalUnits = useMemo(() => getTrainableNavalUnits(cityGameState.playerInfo.nation), [cityGameState.playerInfo.nation]);
    const [selectedUnitId, setSelectedUnitId] = useState(navalUnits[0] || null);
    const [trainAmount, setTrainAmount] = useState('');

    const shipyardRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 1000) / 2,
        y: (window.innerHeight - 700) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('shipyard-header') || e.target.parentElement.classList.contains('shipyard-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);
    
    useEffect(() => {
        setTrainAmount('');
    }, [selectedUnitId]);

    if (!selectedUnitId) {
        return <Modal message="No naval units available to build." onClose={onClose} />;
    }

    const selectedUnit = unitConfig[selectedUnitId];
    const cityUnits = cityGameState?.units || {};
    const navalUnitQueue = (unitQueue || []).filter(item => unitConfig[item.unitId]?.type === 'naval');

    const numericTrainAmount = parseInt(trainAmount, 10) || 0;
    const totalCost = {
        wood: selectedUnit.cost.wood * numericTrainAmount,
        stone: selectedUnit.cost.stone * numericTrainAmount,
        silver: selectedUnit.cost.silver * numericTrainAmount,
        population: selectedUnit.cost.population * numericTrainAmount,
    };

    const canAfford = resources.wood >= totalCost.wood &&
                    resources.stone >= totalCost.stone &&
                    resources.silver >= totalCost.silver &&
                    availablePopulation >= totalCost.population;

    const handleTrain = () => {
        const amount = parseInt(trainAmount, 10) || 0;
        if(amount > 0) onTrain(selectedUnitId, amount);
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div
                ref={shipyardRef}
                className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-4xl border-2 border-gray-600 flex flex-col max-h-[90vh] shipyard-container"
                onClick={e => e.stopPropagation()}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="flex justify-between items-center mb-4 shipyard-header" onMouseDown={handleMouseDown}>
                    <h3 className="font-title text-3xl text-white">Shipyard</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>

                <div className="flex-grow flex gap-4 overflow-y-auto">
                    <div className="w-1/3 flex flex-col gap-2">
                        {navalUnits.map(unitId => {
                            const unit = unitConfig[unitId];
                            const isSelected = selectedUnitId === unitId;
                            return (
                                <button
                                    key={unitId}
                                    onClick={() => setSelectedUnitId(unitId)}
                                    className={`flex items-center p-2 rounded border-2 transition-colors w-full ${isSelected ? 'bg-gray-600 border-yellow-500' : 'bg-gray-700 border-gray-600 hover:border-yellow-400'}`}
                                >
                                    <img src={unitImages[unit.image]} alt={unit.name} className="w-12 h-12 mr-3 object-contain" />
                                    <div>
                                        <p className="font-bold text-left text-white">{unit.name}</p>
                                        <p className="text-sm text-left text-gray-400">In City: {cityUnits[unitId] || 0}</p>
                                    </div>
                                </button>
                            );
                        })}
                    </div>

                    <div className="w-2/3 flex flex-col gap-4">
                        <div className="bg-gray-700 p-4 rounded-lg">
                            <h4 className="font-title text-2xl text-yellow-400">{selectedUnit.name}</h4>
                            <p className="text-gray-400 italic mt-1">{selectedUnit.description}</p>
                        </div>
                        <div className="flex gap-4">
                            <div className="w-1/2 bg-gray-900 p-4 rounded-lg space-y-1">
                                <h5 className="font-bold text-lg text-yellow-300 mb-2">Cost (Total)</h5>
                                <p className="text-sm text-gray-300">Wood: {selectedUnit.cost.wood} ({totalCost.wood})</p>
                                <p className="text-sm text-gray-300">Stone: {selectedUnit.cost.stone} ({totalCost.stone})</p>
                                <p className="text-sm text-gray-300">Silver: {selectedUnit.cost.silver} ({totalCost.silver})</p>
                                <p className="text-sm text-gray-300">Population: {selectedUnit.cost.population} ({totalCost.population})</p>
                                <p className="text-sm text-gray-300">Time per unit: {selectedUnit.cost.time}s</p>
                            </div>
                            <UnitStats unit={selectedUnit} />
                        </div>
                        <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                            <input
                                type="number"
                                value={trainAmount}
                                onChange={(e) => {
                                    const val = e.target.value;
                                    if (val === '' || (parseInt(val) >= 0 && !val.includes('.'))) {
                                        setTrainAmount(val);
                                    }
                                }}
                                className="bg-gray-800 text-white rounded p-2 w-24"
                                placeholder="0"
                            />
                            <button
                                onClick={handleTrain}
                                disabled={!canAfford || numericTrainAmount === 0 || (navalUnitQueue || []).length >= 5}
                                className={`py-2 px-6 text-lg rounded-lg btn ${(canAfford && numericTrainAmount > 0 && (navalUnitQueue || []).length < 5) ? 'btn-confirm' : 'btn-disabled'}`}
                            >
                                {(navalUnitQueue || []).length >= 5 ? 'Queue Full' : 'Build'}
                            </button>
                        </div>
                    </div>
                </div>

                <UnitQueue unitQueue={navalUnitQueue} onCancel={(item) => onCancelTrain(item, 'shipyard')} title="Naval Unit Queue" />
            </div>
        </div>
    );
};

export default ShipyardMenu;
</file>

<file path="src/components/city/SpecialBuildingMenu.css">
/* src/components/city/SpecialBuildingMenu.css */
.special-building-menu-container {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a;
    width: 90%;
    max-width: 800px;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    position: fixed;
    z-index: 50;
}

.special-building-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1.5rem;
    background-color: #1e3a8a;
    color: #f0e68c;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.5rem;
    border-bottom: 2px solid #cd853f;
    cursor: move;
}

.special-building-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    padding: 1rem;
    overflow-y: auto;
    flex-grow: 1;
}

.special-building-card {
    background-color: rgba(139, 69, 19, 0.1);
    border: 1px solid #d2b48c;
    border-radius: 4px;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.special-building-card img {
    width: 80px;
    height: 80px;
    object-fit: contain;
    margin-bottom: 0.5rem;
}

.special-building-card h4 {
    font-weight: bold;
    color: #8B4513;
}

.special-building-card p {
    font-size: 0.8rem;
    flex-grow: 1;
    margin: 0.5rem 0;
}

.special-build-btn {
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #4a2c2a;
    font-weight: bold;
    border: 2px solid #8B4513;
    border-radius: 4px;
    padding: 0.5rem 1rem;
    transition: all 0.2s;
    cursor: pointer;
    width: 100%;
}
.special-build-btn:hover:not(:disabled) {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}
.special-build-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background: #d2b48c;
}
</file>

<file path="src/components/city/SpecialBuildingMenu.js">
// src/components/city/SpecialBuildingMenu.js
import React, { useState, useEffect, useRef, useCallback } from 'react';
import specialBuildings from '../../gameData/specialBuildings.json';
import './SpecialBuildingMenu.css';

const buildingImages = {};
// #comment Update the image context to look in the special_buildings folder
const imageContext = require.context('../../images/special_buildings', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    buildingImages[key] = imageContext(item);
});

const SpecialBuildingMenu = ({ onBuild, onClose, cityGameState, availablePopulation }) => {
    const cost = { wood: 15000, stone: 15000, silver: 15000, population: 60 };
    const canAfford = cityGameState.resources.wood >= cost.wood &&
                      cityGameState.resources.stone >= cost.stone &&
                      cityGameState.resources.silver >= cost.silver &&
                      availablePopulation >= cost.population;

    const specialBuildingRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 800) / 2,
        y: (window.innerHeight - 700) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('special-building-header') || e.target.parentElement.classList.contains('special-building-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);
    
    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div
                ref={specialBuildingRef}
                className="special-building-menu-container"
                onClick={e => e.stopPropagation()}
                onMouseDown={handleMouseDown}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="special-building-header">
                    <h3>Construct a Wonder</h3>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="p-2 text-center bg-amber-200 border-b-2 border-amber-400">
                    <p className="font-bold">Cost: {cost.wood} Wood, {cost.stone} Stone, {cost.silver} Silver, {cost.population} Population</p>
                    <p className="text-sm italic">You may only construct one special building per city.</p>
                </div>
                <div className="special-building-grid">
                    {Object.entries(specialBuildings).map(([id, building]) => (
                        <div key={id} className="special-building-card">
                            <img src={buildingImages[building.image]} alt={building.name} />
                            <h4>{building.name}</h4>
                            <p>{building.description}</p>
                            <button
                                onClick={() => onBuild(id, cost)}
                                disabled={!canAfford}
                                className="special-build-btn"
                            >
                                Build
                            </button>
                        </div>
                    ))}
                </div>
            </div>
        </div>
    );
};

export default SpecialBuildingMenu;
</file>

<file path="src/components/city/SpecialBuildingPanel.js">
// src/components/city/SpecialBuildingPanel.js
import React from 'react';
import specialBuildingsConfig from '../../gameData/specialBuildings.json';
import './SpecialBuildingMenu.css'; // Reusing styles

const buildingImages = {};
const imageContext = require.context('../../images/special_buildings', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    buildingImages[key] = imageContext(item);
});

const SpecialBuildingPanel = ({ buildingId, onClose, onDemolish }) => {
    const building = specialBuildingsConfig[buildingId];

    if (!building) {
        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
                <div className="special-building-menu-container text-center p-8" onClick={e => e.stopPropagation()}>
                    <p>Wonder information not found.</p>
                    <button onClick={onClose} className="btn btn-primary mt-4">Close</button>
                </div>
            </div>
        );
    }

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="special-building-menu-container" onClick={e => e.stopPropagation()}>
                <div className="special-building-header">
                    <h3>{building.name}</h3>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="p-4 flex flex-col items-center text-center">
                    <img src={buildingImages[building.image]} alt={building.name} className="w-32 h-32 object-contain mb-4" />
                    <p className="italic mb-4">{building.description}</p>
                    <div className="bg-amber-200 p-3 rounded w-full">
                        <h4 className="font-bold text-lg">Bonus</h4>
                        <p>{building.bonus.description}</p>
                    </div>
                    <button onClick={onDemolish} className="btn btn-danger mt-6">
                        Demolish
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SpecialBuildingPanel;
</file>

<file path="src/components/city/specialBuildingPlotpls.js">
import React from 'react';

const SpecialBuildingPlot = ({ building, onClick, image, name, isConstructed }) => {
    const { position } = building;
    const spotStyle = {
        top: `${position.y}px`,
        left: `${position.x}px`,
        width: '200px',
        height: '150px',
        backgroundImage: isConstructed && image ? `url(${image})` : 'none',
        backgroundSize: 'contain',
        backgroundRepeat: 'no-repeat',
        backgroundPosition: 'center',
    };

    if (!isConstructed) {
        return (
             <div
                className="building-spot absolute flex items-center justify-center p-2 rounded-lg cursor-pointer hover:bg-black/20"
                style={spotStyle}
                onClick={onClick}
                title={`Build ${name}`}
            >
                <span className="text-gray-400 text-sm">
                    Empty Plot
                </span>
            </div>
        );
    }

    return (
        <div
            className="building-spot absolute flex flex-col items-center justify-end p-2 rounded-lg transition-colors duration-200 cursor-pointer"
            style={{
                ...spotStyle,
                backgroundColor: image ? 'transparent' : 'rgba(139, 69, 19, 0.7)',
            }}
            onClick={onClick}
            title={name}
        >
            {/* #comment Added a label for the constructed building */}
            <span className="text-white text-sm font-bold bg-black/50 px-2 py-1 rounded">{name}</span>
        </div>
    );
};

export default SpecialBuildingPlot;
</file>

<file path="src/components/city/TempleMenu.js">
import React, { useState } from 'react';
import godsConfig from '../../gameData/gods.json';

// Dynamically import all images from the images/gods folder
const images = require.context('../../images/gods', false, /\.(png|jpe?g|svg)$/);
const imageMap = images.keys().reduce((acc, item) => {
    const key = item.replace('./', '');
    acc[key] = images(item);
    return acc;
}, {});

const TempleMenu = ({ city, onWorship, onClose, favorData }) => {
    const playerReligion = city.playerInfo.religion;
    const currentGod = city.god;
    
    const availableGods = (playerReligion && godsConfig[playerReligion.toLowerCase()]) || {};
    const firstGodName = Object.keys(availableGods)[0] || null;
    const [selectedGodName, setSelectedGodName] = useState(currentGod || firstGodName);

    const selectedGodDetails = selectedGodName ? availableGods[selectedGodName] : null;

    // --- NEW FAVOR DISPLAY LOGIC ---
    const favor = selectedGodName ? (favorData[selectedGodName] || 0) : 0;
    const templeLevel = city.buildings.temple?.level || 0;
    const maxFavor = templeLevel > 0 ? 100 + (templeLevel * 20) : 0;
    const favorPercentage = maxFavor > 0 ? (favor / maxFavor) * 100 : 0;
    // --- END ---

    const buttonDisabled = !selectedGodName || selectedGodName === currentGod;
    let buttonText;
    if (currentGod && selectedGodName === currentGod) {
        buttonText = `Currently Worshipping ${currentGod}`;
    } else if (selectedGodName) {
        buttonText = `Worship ${selectedGodName}`;
    } else {
        buttonText = "Select a God";
    }

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-4xl border-2 border-yellow-600 text-white" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="font-title text-3xl">Temple in {city.name}</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>

                <div className="flex gap-6">
                    {/* Left Sidebar for God Selection */}
                    <div className="flex flex-col gap-2 p-2 bg-gray-900 border border-gray-700 rounded-lg">
                        {Object.values(availableGods).map(god => (
                            <button
                                key={god.name}
                                onClick={() => setSelectedGodName(god.name)}
                                className={`w-20 h-20 flex items-center justify-center rounded-lg overflow-hidden transition-all border-2 ${selectedGodName === god.name ? 'bg-gray-700 border-yellow-400' : 'bg-gray-800 border-gray-600 hover:bg-gray-700'}`}
                                title={god.name}
                            >
                                <img src={imageMap[god.image]} alt={god.name} className="w-full h-full object-cover" />
                            </button>
                        ))}
                    </div>

                    {/* Main Content Area for God Details */}
                    <div className="flex-1 bg-gray-900 border border-gray-700 rounded-lg p-4">
                        {selectedGodDetails ? (
                            <>
                                <div className="flex items-center gap-4 mb-4">
                                    <div className="w-32 h-32 p-1 bg-gray-800 rounded-full border-4 border-stone-500 flex-shrink-0 overflow-hidden">
                                        <img src={imageMap[selectedGodDetails.image]} alt={selectedGodDetails.name} className="w-full h-full object-cover rounded-full" />
                                    </div>
                                    <div>
                                        <h4 className="font-title text-4xl text-yellow-400">{selectedGodDetails.name}</h4>
                                        <p className="text-gray-400">{selectedGodDetails.description}</p>
                                    </div>
                                </div>

                                {/* Favor Bar */}
                                <div className="mt-4">
                                    <h5 className="text-lg font-bold mb-2">Favor for {selectedGodName}</h5>
                                    <div className="bg-gray-700 rounded-full h-6 border border-gray-600">
                                        <div
                                            className="bg-blue-500 h-full rounded-full text-center text-white text-sm flex items-center justify-center transition-all duration-500"
                                            style={{ width: `${favorPercentage}%` }}
                                        >
                                            <span>{Math.floor(favor)} / {maxFavor}</span>
                                        </div>
                                    </div>
                                    <p className="text-xs text-gray-500 text-center mt-1">Favor increases over time based on this city's Temple level.</p>
                                </div>

                                <div className="grid grid-cols-2 gap-4 mt-6">
                                    <div>
                                        <h5 className="text-lg font-bold mb-2 text-yellow-500">Divine Powers</h5>
                                        <ul className="list-disc list-inside text-gray-300">
                                            {selectedGodDetails.powers.map(power => <li key={power.name}>{power.name}</li>)}
                                        </ul>
                                    </div>
                                    <div>
                                        <h5 className="text-lg font-bold mb-2 text-yellow-500">Mythical Units</h5>
                                        <ul className="list-disc list-inside text-gray-300">
                                            {selectedGodDetails.mythical_units.map(unit => <li key={unit}>{unit}</li>)}
                                        </ul>
                                    </div>
                                </div>
                            </>
                        ) : (
                            <p className="text-center p-10">Select a god to view their details.</p>
                        )}
                    </div>
                </div>

                <div className="mt-6">
                    <button
                        onClick={() => onWorship(selectedGodName)}
                        disabled={buttonDisabled}
                        className={`w-full py-3 btn text-lg ${buttonDisabled ? 'btn-disabled' : 'btn-confirm'}`}
                    >
                        {buttonText}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default TempleMenu;
</file>

<file path="src/components/city/UnitQueue.css">
/* src/components/city/UnitQueue.css */
.unit-queue-tooltip {
    /* Position is now handled by inline styles */
    width: 280px;
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 4px solid #8B4513; /* saddlebrown */
    box-shadow: 0 0 15px rgba(0,0,0,0.5);
    color: #4a2c2a;
    padding: 12px;
    border-radius: 6px;
    z-index: 110; /* Ensure it's on top */
    pointer-events: none; /* So it doesn't interfere with mouse events on the item */
    text-align: left;
    transition: opacity 0.2s;
}

.unit-tooltip-title {
    font-family: 'IM Fell English SC', serif;
    font-size: 1.25rem;
    text-align: center;
    margin-bottom: 12px;
    border-bottom: 1px solid #d2b48c;
    padding-bottom: 8px;
}

.unit-tooltip-info {
    display: grid;
    grid-template-columns: auto 1fr; /* Adjust columns for better alignment */
    gap: 8px;
    align-items: center;
    margin-bottom: 12px;
}

.unit-tooltip-info dt {
    font-weight: bold;
}

.unit-tooltip-info dd {
    font-family: monospace;
    background-color: rgba(0,0,0,0.7);
    color: #f0e68c;
    padding: 4px 8px;
    border-radius: 4px;
    text-align: center;
}
</file>

<file path="src/components/city/UnitQueue.js">
// src/components/city/UnitQueue.js
import React, { useState, useEffect, useRef } from 'react';
import unitConfig from '../../gameData/units.json';
import './UnitQueue.css'; // Import the new CSS

// Dynamically import all unit images
const unitImages = {};
const imageContext = require.context('../../images/troops', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    unitImages[key] = imageContext(item);
});

const formatTime = (seconds) => {
    if (seconds < 0) seconds = 0;
    const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
    const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
    const s = Math.floor(seconds % 60).toString().padStart(2, '0');
    return `${h}:${m}:${s}`;
};

const UnitQueueItem = ({ item, onCancel, isFirst, isLast, onHover, onLeave }) => {
    const [timeLeft, setTimeLeft] = useState(0);
    const itemRef = useRef(null);

    useEffect(() => {
        if (!isFirst) return;

        let interval; // #comment define interval inside useEffect
        const calculateTimeLeft = () => {
            const endTime = (item.endTime instanceof Date) ? item.endTime : new Date(item.endTime);
            if (isNaN(endTime.getTime())) {
                setTimeLeft(0);
                return;
            }
            const remaining = Math.max(0, (endTime.getTime() - Date.now()) / 1000);
            setTimeLeft(remaining);
            
            if (remaining <= 0) {
                clearInterval(interval);
            }
        };

        calculateTimeLeft();
        interval = setInterval(calculateTimeLeft, 1000); // #comment assign interval here
        return () => clearInterval(interval);
    }, [item.endTime, isFirst]);

    const unit = unitConfig[item.unitId];
    if (!unit) return null;
    const imageSrc = unitImages[unit.image];

    return (
        <div 
            ref={itemRef}
            className="relative w-16 h-16 bg-gray-700 border-2 border-gray-600 rounded-md flex-shrink-0" 
            title={`${item.amount}x ${unit.name}`}
            onMouseEnter={() => onHover(item, itemRef.current)}
            onMouseLeave={onLeave}
        >
            <img src={imageSrc} alt={unit.name} className="w-full h-full object-contain p-1" />
            <span className="absolute bottom-0 right-1 text-white bg-black bg-opacity-75 px-1.5 py-0.5 text-xs font-bold rounded-tl-md rounded-br-md">
                {item.amount}
            </span>
            {isFirst && (
                <div className="absolute bottom-0 left-0 right-0 bg-black bg-opacity-75 text-white text-xs text-center py-0.5 font-mono">
                    {formatTime(timeLeft)}
                </div>
            )}
            {isLast && (
                <button
                    onClick={() => onCancel(item)} // Pass the entire item object
                    className="absolute -top-2 -right-2 w-5 h-5 flex items-center justify-center bg-red-600 text-white rounded-full font-bold text-xs hover:bg-red-500 transition-colors z-10"
                    title="Cancel"
                >
                    &times;
                </button>
            )}
        </div>
    );
};

const UnitQueue = ({ unitQueue, onCancel, title = "In Training" }) => {
    const [hoveredItem, setHoveredItem] = useState(null);
    const [tooltipStyle, setTooltipStyle] = useState({ display: 'none' });
    const tooltipTimeoutRef = useRef(null);
    const queueContainerRef = useRef(null);

    // #comment handle mouse enter to show tooltip and calculate its position
    const handleMouseEnter = (item, element) => {
        clearTimeout(tooltipTimeoutRef.current);
        if (element && queueContainerRef.current) {
            const queueRect = queueContainerRef.current.getBoundingClientRect();
            const itemRect = element.getBoundingClientRect();

            setTooltipStyle({
                position: 'absolute',
                bottom: `${queueRect.height}px`, // Position above the queue container
                left: `${itemRect.left - queueRect.left + (itemRect.width / 2)}px`,
                transform: 'translateX(-50%)',
                marginBottom: '8px',
            });
            setHoveredItem(item);
        }
    };

    // #comment handle mouse leave to hide tooltip
    const handleMouseLeave = () => {
        tooltipTimeoutRef.current = setTimeout(() => {
            setHoveredItem(null);
        }, 200);
    };
    
    // #comment Get the completion time of the last item in the queue
    const totalCompletionTime = unitQueue && unitQueue.length > 0 
        ? unitQueue[unitQueue.length - 1].endTime 
        : null;

    const renderTooltip = () => {
        if (!hoveredItem) return null;
        const unit = unitConfig[hoveredItem.unitId];
        const totalCompletionTimeString = totalCompletionTime ? new Date(totalCompletionTime).toLocaleTimeString() : 'Queued';

        return (
            <div className="unit-queue-tooltip" style={tooltipStyle}>
                <h3 className="unit-tooltip-title">{hoveredItem.amount}x {unit.name}</h3>
                <dl className="unit-tooltip-info">
                    <dt>Time per unit:</dt>
                    <dd>{formatTime(unit.cost.time)}</dd>
                    <dt>Queue Completion:</dt>
                    <dd>{totalCompletionTimeString}</dd>
                </dl>

            </div>
        );
    };

    if (!unitQueue || unitQueue.length === 0) {
        return (
            <div className="mt-auto pt-4">
                <h4 className="text-lg font-semibold text-yellow-400 mb-2">{title} (0/5)</h4>
                <div className="flex space-x-3 bg-gray-900 p-2 rounded-lg h-24 items-center justify-center">
                    <p className="text-gray-500">Queue is empty.</p>
                </div>
            </div>
        );
    }
    return (
        <div className="mt-auto pt-4 relative" ref={queueContainerRef}>
            <h4 className="text-lg font-semibold text-yellow-400 mb-2">{title} ({unitQueue.length}/5)</h4>
            <div className="flex space-x-3 bg-gray-900 p-2 rounded-lg overflow-x-auto h-24 items-center">
                {unitQueue.map((item, index) => (
                    <UnitQueueItem 
                        key={item.id || `${item.unitId}-${index}`}
                        item={item} 
                        onCancel={onCancel} 
                        isFirst={index === 0}
                        isLast={index === unitQueue.length - 1}
                        onHover={handleMouseEnter}
                        onLeave={handleMouseLeave}
                    />
                ))}
            </div>
            {renderTooltip()}
        </div>
    );
};

export default UnitQueue;
</file>

<file path="src/components/city/WithdrawModal.js">
// src/components/city/WithdrawModal.js
import React, { useState } from 'react';
import unitConfig from '../../gameData/units.json';
import { useAuth } from '../../contexts/AuthContext';

const images = {};
const imageContext = require.context('../../images/troops', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    images[key] = imageContext(item);
});

const WithdrawModal = ({ city, onClose, onWithdrawTroops }) => {
    const { currentUser } = useAuth();
    const [withdrawAmounts, setWithdrawAmounts] = useState({});

    // #comment handle changes in the withdrawal amount input fields
    const handleAmountChange = (originCityId, unitId, value) => {
        const max = city.reinforcements?.[originCityId]?.units?.[unitId] || 0;
        const amount = Math.max(0, Math.min(max, parseInt(value, 10) || 0));
        setWithdrawAmounts(prev => ({
            ...prev,
            [originCityId]: {
                ...prev[originCityId],
                [unitId]: amount
            }
        }));
    };

    // #comment initiate the withdrawal process for the selected troops
    const handleWithdraw = () => {
        const hasSelection = Object.values(withdrawAmounts).some(units => 
            Object.values(units).some(amount => amount > 0)
        );
        if (hasSelection) {
            onWithdrawTroops(city, withdrawAmounts);
            onClose();
        }
    };
    
    // #comment handle withdrawing all troops
    const handleWithdrawAll = () => {
        const allReinforcements = city.reinforcements || {};
        const allWithdrawalData = {};

        for (const originCityId in allReinforcements) {
            if (allReinforcements[originCityId].ownerId === currentUser.uid) {
                allWithdrawalData[originCityId] = { ...allReinforcements[originCityId].units };
            }
        }

        if (Object.keys(allWithdrawalData).length > 0) {
            onWithdrawTroops(city, allWithdrawalData);
            onClose();
        }
    };

    // #comment Filter reinforcements to only show those owned by the current user
    const myReinforcements = Object.entries(city.reinforcements || {})
        .filter(([, reinfData]) => reinfData.ownerId === currentUser.uid);

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-2xl border-2 border-gray-600 flex flex-col max-h-[90vh]" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="font-title text-3xl text-white">Withdraw Your Troops from {city.cityName}</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>

                <div className="flex-grow overflow-y-auto pr-2 space-y-4">
                    {myReinforcements.length > 0 ? myReinforcements.map(([originCityId, reinfData]) => (
                        <div key={originCityId} className="bg-gray-700 p-3 rounded-lg">
                            <h4 className="font-bold text-yellow-400 mb-2">From: {reinfData.originCityName}</h4>
                            <div className="space-y-2">
                                {Object.entries(reinfData.units || {}).map(([unitId, count]) => {
                                    const unit = unitConfig[unitId];
                                    return (
                                        <div key={unitId} className="flex items-center justify-between">
                                            <div className="flex items-center gap-3">
                                                <img src={images[unit.image]} alt={unit.name} className="w-10 h-10 object-contain" />
                                                <div>
                                                    <p className="font-bold text-white">{unit.name}</p>
                                                    <p className="text-sm text-gray-400">Count: {count}</p>
                                                </div>
                                            </div>
                                            <input
                                                type="number"
                                                value={withdrawAmounts[originCityId]?.[unitId] || ''}
                                                onChange={(e) => handleAmountChange(originCityId, unitId, e.target.value)}
                                                className="bg-gray-800 text-white rounded p-2 w-24 text-center"
                                                placeholder="Amount"
                                                max={count}
                                                min="0"
                                            />
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )) : (
                        <p className="text-center text-gray-400">You have no troops to withdraw from this city.</p>
                    )}
                </div>

                <div className="mt-4 pt-4 border-t border-gray-600 flex justify-end gap-4">
                    <button onClick={handleWithdrawAll} className="btn btn-primary py-2 px-6">
                        Withdraw All
                    </button>
                    <button onClick={handleWithdraw} className="btn btn-confirm py-2 px-6">
                        Withdraw Selected Troops
                    </button>
                </div>
            </div>
        </div>
    );
};

export default WithdrawModal;
</file>

<file path="src/components/city/WorkerPresetPanel.js">
// src/components/city/WorkerPresetPanel.js
import React from 'react';
import { useGame } from '../../contexts/GameContext';

const WorkerPresetPanel = ({ cityGameState, onClose, onApplyPresets, getMaxWorkerSlots }) => {
    const { gameSettings } = useGame();
    const presets = gameSettings.workerPresets || {};
    const buildings = ['timber_camp', 'quarry', 'silver_mine'];

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg border-2 border-gray-600 text-white" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="font-title text-2xl">Worker Management</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                <p className="text-sm text-gray-400 mb-6">
                    Automatically assign workers based on your presets. You can configure presets in the main settings menu.
                </p>
                <table className="w-full text-left mb-6">
                    <thead>
                        <tr className="border-b border-gray-600">
                            <th className="p-2">Building</th>
                            <th className="p-2 text-center">Current</th>
                            <th className="p-2 text-center">Max</th>
                            <th className="p-2 text-center">Preset</th>
                        </tr>
                    </thead>
                    <tbody>
                        {buildings.map(id => {
                            const building = cityGameState.buildings[id];
                            if (!building || building.level === 0) return null;
                            return (
                                <tr key={id} className="border-b border-gray-700">
                                    <td className="p-2 capitalize font-semibold">{id.replace('_', ' ')}</td>
                                    <td className="p-2 text-center">{building.workers || 0}</td>
                                    <td className="p-2 text-center">{getMaxWorkerSlots(building.level)}</td>
                                    <td className="p-2 text-center">{presets[id] || 0}</td>
                                </tr>
                            );
                        })}
                    </tbody>
                </table>
                <button onClick={onApplyPresets} className="btn btn-confirm w-full py-2">
                    Apply Presets
                </button>
            </div>
        </div>
    );
};

export default WorkerPresetPanel;
</file>

<file path="src/components/city/WorshipDisplay.js">
// src/components/city/WorshipDisplay.js
import React from 'react';
import godsConfig from '../../gameData/gods.json';
import spellsIcon from '../../images/spells.png';

// Dynamically import all images from the images/gods folder
const images = require.context('../../images/gods', false, /\.(png|jpe?g|svg)$/);
const imageMap = images.keys().reduce((acc, item) => {
    const key = item.replace('./', '');
    acc[key] = images(item);
    return acc;
}, {});


const WorshipDisplay = ({ godName, playerReligion, worship, buildings, onOpenPowers }) => {

    const getGodDetails = (name, religion) => {
        if (!name || !religion) return null;
        const religionKey = religion.toLowerCase();
        const pantheon = godsConfig[religionKey];
        if (!pantheon) return null;
        return Object.values(pantheon).find(g => g.name === name);
    };

    const godDetails = getGodDetails(godName, playerReligion);

    const favor = godName && worship ? (worship[godName] || 0) : 0;
    const templeLevel = buildings?.temple?.level || 0;
    const maxFavor = templeLevel > 0 ? 100 + (templeLevel * 20) : 0;

    return (
        <div className="worship-display-container">
            {godName && godDetails ? (
                <div className="text-center">
                    <img src={imageMap[godDetails.image]} alt={godDetails.name} className="w-24 h-24 mx-auto rounded-full border-4 border-yellow-500" />
                    <p className="text-lg font-bold mt-2">{godName}</p>
                    <p className="text-sm text-blue-600 mt-2">Favor: {Math.floor(favor)} / {maxFavor}</p>
                    <button onClick={onOpenPowers} className="spells-button">
                        <img src={spellsIcon} alt="View Spells" className="w-10 h-10 object-contain"/>
                    </button>
                </div>
            ) : (
                <p className="text-gray-500 text-center text-sm">Build a Temple to worship a god.</p>
            )}
        </div>
    );
};

export default WorshipDisplay;
</file>

<file path="src/components/CityFounding.js">
// src/components/CityFounding.js
import React, { useState, useEffect, useCallback } from 'react';
import { doc, getDoc, writeBatch, collection, query, where, limit, getDocs, serverTimestamp} from 'firebase/firestore';
import { db } from '../firebase/config';
import { useAuth } from '../contexts/AuthContext';
import { useGame } from '../contexts/GameContext';
import buildingConfig from '../gameData/buildings.json';

// #comment Add nations data for selection
const nationsByReligion = {
    'Greek': ['Athenian', 'Spartan', 'Corinthian'],
    'Roman': ['Julian', 'Cornelian', 'Fabian'],
    'Egyptian': ['Ptolemaic', 'Nubian', 'Bedouin']
};

const CityFounding = ({ onCityFounded }) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId, worldState, setActiveCityId, playerCities } = useGame();
    const [selectedSlot, setSelectedSlot] = useState(null);
    const [cityName, setCityName] = useState('');
    const [message, setMessage] = useState('');
    const [isLoading, setIsLoading] = useState(false);

    // #comment Add state for religion and nation selection
    const [selectedReligion, setSelectedReligion] = useState(null);
    const [selectedNation, setSelectedNation] = useState(null);
    const [step, setStep] = useState(1); // 1 for selection, 2 for naming

    useEffect(() => {
        if (userProfile?.username) {
            setCityName(`${userProfile.username}'s Capital`);
        }
    }, [userProfile]);

    const findEmptySlot = useCallback(async () => {
        if (!worldState?.islands || !worldId) return null;
        const citySlotsRef = collection(db, 'worlds', worldId, 'citySlots');
        const q = query(citySlotsRef, where('ownerId', '==', null), limit(10));
        try {
            const querySnapshot = await getDocs(q);
            if (!querySnapshot.empty) {
                const randomDoc = querySnapshot.docs[Math.floor(Math.random() * querySnapshot.docs.length)];
                return { id: randomDoc.id, ...randomDoc.data() };
            }
        } catch (error) {
            console.error("Error finding an empty slot:", error);
        }
        return null;
    }, [worldId, worldState]);

    const handleProceedToNaming = useCallback(async () => {
        if (!selectedReligion || !selectedNation) {
            setMessage("Please select a religion and nation to continue.");
            return;
        }
        setIsLoading(true);
        setMessage('Finding a suitable location...');
        const slot = await findEmptySlot();
        if (slot) {
            setSelectedSlot(slot);
            setMessage(`Location found at (${slot.x}, ${slot.y}). Give your new city a name.`);
            setStep(2); // Move to the city naming step
        } else {
            setMessage('Could not find an available city slot. This world might be full.');
        }
        setIsLoading(false);
    }, [findEmptySlot, selectedReligion, selectedNation]);

    const handleFoundCity = async (e) => {
        e.preventDefault();
        if (!cityName.trim() || !selectedSlot || !userProfile || !selectedReligion || !selectedNation) {
            setMessage("Cannot found city: missing required information.");
            return;
        }
        setIsLoading(true);
        setMessage('Founding your city...');

        const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', selectedSlot.id);
        const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);
        const newCityDocRef = doc(collection(gameDocRef, 'cities'));

        try {
            const slotSnap = await getDoc(citySlotRef);
            if (!slotSnap.exists() || slotSnap.data().ownerId !== null) {
                throw new Error("This location was taken. Please try again.");
            }

            const batch = writeBatch(db);

            // #comment Check for existing city names to avoid duplicates
            let baseName = cityName.trim();
            const existingCityNames = Object.values(playerCities).map(c => c.cityName);
            
            let finalCityName = baseName;
            if (existingCityNames.includes(finalCityName)) {
                let count = 2;
                let newName;
                const colonyBaseName = baseName.replace(/ Colony \d+$/, "").trim();
                do {
                    newName = `${colonyBaseName} Colony ${count}`;
                    count++;
                } while (existingCityNames.includes(newName));
                finalCityName = newName;
            }

            batch.update(citySlotRef, {
                ownerId: currentUser.uid,
                ownerUsername: userProfile.username,
                cityName: finalCityName
            });

            // #comment Set the top-level game document with initial data, including battle points
            batch.set(gameDocRef, {
                worldName: worldState.name,
                joinedAt: serverTimestamp(),
                citySlotIds: [selectedSlot.id],
                battlePoints: 0
            });

            const initialBuildings = {};
            Object.keys(buildingConfig).forEach(id => {
                initialBuildings[id] = { level: 0 };
            });
            ['senate', 'farm', 'warehouse', 'timber_camp', 'quarry', 'silver_mine', 'cave'].forEach(id => {
                initialBuildings[id].level = 1;
            });

            const newCityData = {
                id: newCityDocRef.id,
                slotId: selectedSlot.id,
                x: selectedSlot.x,
                y: selectedSlot.y,
                islandId: selectedSlot.islandId,
                cityName: finalCityName,
                playerInfo: { religion: selectedReligion, nation: selectedNation },
                resources: { wood: 1000, stone: 1000, silver: 500 },
                buildings: initialBuildings,
                units: {},
                wounded: {},
                research: {},
                worship: {},
                cave: { silver: 0 },
                buildQueue: [],
                unitQueue: [],
                researchQueue: [],
                healQueue: [],
                lastUpdated: Date.now(),
            };
            
            batch.set(newCityDocRef, newCityData);

            await batch.commit();
            setActiveCityId(newCityDocRef.id);
            if (onCityFounded && typeof onCityFounded === 'function') {
                onCityFounded();
            }

        } catch (error) {
            console.error("Error founding city: ", error);
            setMessage(`Failed to found city: ${error.message}`);
            setSelectedSlot(null);
            setStep(1); // Go back to selection
            setIsLoading(false);
        }
    };

    if (step === 1) {
        return (
            <div className="w-full min-h-screen flex items-center justify-center p-4 bg-gray-900 text-white">
                <div className="w-full max-w-2xl">
                    <div className="bg-gray-800 p-8 rounded-lg shadow-2xl">
                        <h1 className="font-title text-4xl text-center text-gray-300 mb-6">Choose Your Path</h1>
                        <p className="text-center text-gray-400 mb-8">Your choice of Religion and Nation will define your journey in this world.</p>
                        {message && <p className="text-center text-red-400 mb-4">{message}</p>}
                        <div className="mb-8">
                            <h2 className="font-title text-2xl text-gray-300 mb-4">Select Religion</h2>
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                {Object.keys(nationsByReligion).map(religion => (
                                    <div key={religion} onClick={() => { setSelectedReligion(religion); setSelectedNation(null); }} className={`selection-card p-4 rounded-lg text-center ${selectedReligion === religion ? 'selected' : ''}`}>
                                        <h3 className="text-xl font-bold">{religion}</h3>
                                    </div>
                                ))}
                            </div>
                        </div>
                        {selectedReligion && (
                            <div className="mb-8">
                                <h2 className="font-title text-2xl text-gray-300 mb-4">Select Nation</h2>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    {nationsByReligion[selectedReligion].map(nation => (
                                        <div key={nation} onClick={() => setSelectedNation(nation)} className={`selection-card p-4 rounded-lg text-center ${selectedNation === nation ? 'selected' : ''}`}>
                                            <h3 className="text-xl font-bold">{nation}</h3>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                        <button onClick={handleProceedToNaming} disabled={!selectedReligion || !selectedNation || isLoading} className="w-full btn btn-confirm font-bold py-3 rounded-lg disabled:btn-disabled">
                             {isLoading ? 'Searching for land...' : 'Continue'}
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div className="w-full h-screen flex items-center justify-center bg-gray-900 text-white">
            <div className="w-full max-w-md text-center p-8 bg-gray-800 rounded-lg shadow-2xl">
                <h2 className="font-title text-4xl mb-4">Found Your First City</h2>
                <p className="text-gray-400 mb-6">{message}</p>
                {selectedSlot && (
                    <form onSubmit={handleFoundCity} className="flex flex-col gap-4">
                        <input
                            type="text"
                            value={cityName}
                            onChange={(e) => setCityName(e.target.value)}
                            className="bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 w-full text-center text-lg"
                            required
                        />
                        <button type="submit" disabled={isLoading} className="btn btn-confirm px-8 py-3 text-lg">
                            {isLoading ? 'Claiming Land...' : 'Found City'}
                        </button>
                    </form>
                )}
            </div>
        </div>
    );
};

export default CityFounding;
</file>

<file path="src/components/CityView.js">
import React, { useState, useMemo } from 'react';
import { useAuth } from '../contexts/AuthContext';
import Modal from './shared/Modal';
import CityModals from './city/CityModals';
import CityViewContent from './city/CityViewContent';
import DivinePowers from './city/DivinePowers';
import { useCityState } from '../hooks/useCityState';
import { useGame } from '../contexts/GameContext';
import { useCityActions } from '../hooks/useCityActions';
import { useHeroActions } from '../hooks/actions/useHeroActions';
import { useAgentActions } from '../hooks/actions/useAgentActions';
import SidebarNav from './map/SidebarNav';
import TopBar from './map/TopBar';
import QuestsButton from './QuestsButton';
import { useAlliance } from '../contexts/AllianceContext';

const CityView = ({
    showMap,
    worldId,
    openModal,
    unreadReportsCount,
    unreadMessagesCount,
    isUnderAttack,
    incomingAttackCount,
    handleOpenAlliance,
    handleOpenProfile,
    movements,
    onCancelTrain,
    onCancelMovement,
    combinedSlots,
    onRenameCity,
    quests,
    handleOpenEvents,
    onSwitchCity,
    battlePoints,
    cityModalState,
    openCityModal,
    closeCityModal,
    setCityModalState,
    onOpenManagementPanel,
}) => {
    const { currentUser, userProfile } = useAuth();
    const { gameSettings, worldState } = useGame();
    const { playerAlliance } = useAlliance();
    const {isInstantBuild, setIsInstantBuild} = useGame();
    const {isInstantResearch, setIsInstantResearch} = useGame();
    const {isInstantUnits, setIsInstantUnits} = useGame();
    const [message, setMessage] = useState('');
    const {
        cityGameState, setCityGameState, getUpgradeCost, getFarmCapacity,
        calculateUsedPopulation, getProductionRates, getWarehouseCapacity,
        getHospitalCapacity, saveGameState, getResearchCost, calculateHappiness,
        getMaxWorkerSlots, getMarketCapacity,
    } = useCityState(worldId, isInstantBuild, isInstantResearch, isInstantUnits);
    const actions = useCityActions({
        cityGameState, setCityGameState, saveGameState, worldId, userProfile, currentUser,
        getUpgradeCost, getResearchCost, getFarmCapacity, calculateUsedPopulation, isInstantUnits,
        setMessage, openModal: openCityModal, closeModal: closeCityModal, setModalState: setCityModalState,
        setIsInstantBuild, setIsInstantResearch, setIsInstantUnits, getMaxWorkerSlots
    });
    const { onRecruitHero, onActivateSkill, onAssignHero, onUnassignHero, onReleaseHero } = useHeroActions(cityGameState, saveGameState, setMessage);
    const { onRecruitAgent, onAssignAgent } = useAgentActions(cityGameState, saveGameState, setMessage);

    const { availablePopulation, happiness } = useMemo(() => {
        if (!cityGameState) return { availablePopulation: 0, happiness: 0 };
        const maxPopulation = getFarmCapacity(cityGameState.buildings?.farm?.level);
        const usedPopulation = calculateUsedPopulation(cityGameState);
        const availablePopulation = maxPopulation - usedPopulation;
        const happinessValue = calculateHappiness(cityGameState.buildings);
        return { availablePopulation, happiness: happinessValue };
    }, [cityGameState, getFarmCapacity, calculateUsedPopulation, calculateHappiness]);

    const productionRates = useMemo(() => {
        if (!cityGameState) return { wood: 0, stone: 0, silver: 0 };
        return getProductionRates(cityGameState.buildings);
    }, [cityGameState, getProductionRates]);

    if (!cityGameState) {
        return <div className="text-white text-center p-10">Loading City...</div>;
    }

    return (
        <div className="w-full h-screen bg-gray-900 city-view-wrapper relative">
            <Modal message={message} onClose={() => setMessage('')} />
            <QuestsButton
                onOpenQuests={() => openModal('quests')}
                quests={quests}
            />
            <SidebarNav
                onToggleView={showMap}
                view="city"
                onOpenReports={() => openModal('reports')}
                onOpenAlliance={handleOpenAlliance}
                onOpenForum={() => openModal('allianceForum')}
                onOpenMessages={() => openModal('messages')}
                onOpenSettings={() => openModal('settings')}
                onOpenProfile={() => handleOpenProfile()}
                onOpenLeaderboard={() => openModal('leaderboard')}
                onOpenQuests={() => openModal('quests')}
                unreadReportsCount={unreadReportsCount}
                unreadMessagesCount={unreadMessagesCount}
                isAdmin={userProfile?.is_admin}
                onToggleDummyCityPlacement={() => {}}
                onOpenCheats={() => openCityModal('isCheatMenuOpen')}
                isAllianceMember={!!playerAlliance}
                handleOpenEvents={handleOpenEvents}
                onOpenHeroesAltar={() => openCityModal('isHeroesAltarOpen')}
                onOpenManagementPanel={onOpenManagementPanel}
            />
            <div className="h-full w-full flex flex-col">
                <TopBar
                    view="city"
                    gameState={cityGameState}
                    availablePopulation={availablePopulation}
                    happiness={happiness}
                    worldState={worldState}
                    productionRates={productionRates}
                    movements={movements}
                    onCancelTrain={onCancelTrain}
                    onCancelMovement={onCancelMovement}
                    combinedSlots={combinedSlots}
                    onOpenMovements={() => openModal('movements')}
                    isUnderAttack={isUnderAttack}
                    incomingAttackCount={incomingAttackCount}
                    onRenameCity={onRenameCity}
                    getWarehouseCapacity={getWarehouseCapacity}
                    onSwitchCity={onSwitchCity}
                    battlePoints={battlePoints}
                />
                <CityViewContent
                    cityGameState={cityGameState}
                    handlePlotClick={actions.handlePlotClick}
                    onOpenPowers={() => openCityModal('isDivinePowersOpen')}
                    gameSettings={gameSettings}
                    onOpenSpecialBuildingMenu={() => openCityModal('isSpecialBuildingMenuOpen')}
                    movements={movements}
                />
            </div>
            <CityModals
                cityGameState={cityGameState}
                worldId={worldId}
                currentUser={currentUser}
                userProfile={userProfile}
                isInstantBuild={isInstantBuild}
                getUpgradeCost={getUpgradeCost}
                getFarmCapacity={getFarmCapacity}
                getWarehouseCapacity={getWarehouseCapacity}
                getHospitalCapacity={getHospitalCapacity}
                getProductionRates={getProductionRates}
                calculateUsedPopulation={calculateUsedPopulation}
                saveGameState={saveGameState}
                handleUpgrade={actions.handleUpgrade}
                handleCancelBuild={actions.handleCancelBuild}
                handleTrainTroops={actions.handleTrainTroops}
                handleCancelTrain={actions.handleCancelTrain}
                handleFireTroops={actions.handleFireTroops}
                handleStartResearch={actions.handleStartResearch}
                handleCancelResearch={actions.handleCancelResearch}
                handleWorshipGod={actions.handleWorshipGod}
                handleCheat={actions.handleCheat}
                handleHealTroops={actions.handleHealTroops}
                handleCancelHeal={actions.handleCancelHeal}
                availablePopulation={availablePopulation}
                modalState={cityModalState}
                openModal={openCityModal}
                closeModal={closeCityModal}
                setMessage={setMessage}
                onAddWorker={actions.handleAddWorker}
                onRemoveWorker={actions.handleRemoveWorker}
                getMaxWorkerSlots={getMaxWorkerSlots}
                getMarketCapacity={getMarketCapacity}
                handleBuildSpecialBuilding={actions.handleBuildSpecialBuilding}
                handleDemolish={actions.handleDemolish}
                handleDemolishSpecialBuilding={actions.handleDemolishSpecialBuilding}
                handleSpawnGodTown={actions.handleSpawnGodTown}
                onRecruitHero={onRecruitHero}
                onActivateSkill={onActivateSkill}
                onAssignHero={onAssignHero}
                onUnassignHero={onUnassignHero}
                onApplyWorkerPreset={actions.applySenateWorkerPreset}
                onReleaseHero={onReleaseHero}
                onRecruitAgent={onRecruitAgent}
                onAssignAgent={onAssignAgent}
                movements={movements}
            />
            {cityModalState.isDivinePowersOpen && (
                <DivinePowers
                    godName={cityGameState.god}
                    playerReligion={cityGameState.playerInfo.religion}
                    favor={cityGameState.worship[cityGameState.god] || 0}
                    onCastSpell={actions.handleCastSpell}
                    onClose={() => closeCityModal('isDivinePowersOpen')}
                />
            )}
        </div>
    );
};

export default CityView;
</file>

<file path="src/components/Game.js">
import React, { useState, useCallback, useEffect, useMemo, useRef } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { useGame } from '../contexts/GameContext';
import { useAlliance } from '../contexts/AllianceContext';
import { signOut } from "firebase/auth";
import { auth, db } from '../firebase/config';
import CityView from './CityView';
import MapView from './MapView';
import LoadingScreen from './shared/LoadingScreen';
import Chat from './chat/Chat';
import { useMovementProcessor } from '../hooks/useMovementProcessor';
import { useModalState } from '../hooks/useModalState';
import { useMapState } from '../hooks/useMapState';
import { useMapEvents } from '../hooks/useMapEvents';
import { useQuestTracker } from '../hooks/useQuestTracker';
import { useMapActions } from '../hooks/useMapActions';
import { useKeyboardControls } from '../hooks/useKeyboardControls';
import { useCityModalManager } from '../hooks/useCityModalManager';
import ReportsView from './ReportsView';
import MessagesView from './messaging/MessagesView';
import AllianceModal from './map/AllianceModal';
import AllianceCreation from './alliance/AllianceCreation';
import AllianceForum from './alliance/AllianceForum';
import SettingsModal from './shared/SettingsModal';
import ProfileView from './profile/ProfileView';
import Leaderboard from './leaderboard/Leaderboard';
import AllianceProfile from './profile/AllianceProfile';
import QuestsModal from './quests/QuestsModal';
import MovementsPanel from './map/MovementsPanel';
import SharedReportView from './SharedReportView';
import EventTrigger from './admin/EventTrigger';
import GodTownModal from './map/GodTownModal';
import ManagementPanel from './management/managementPanelpls'; // #comment Import ManagementPanel
import { collection, onSnapshot, query, where, doc, updateDoc, runTransaction, serverTimestamp, getDocs} from 'firebase/firestore';
import unitConfig from '../gameData/units.json';
import logoutIcon from '../images/logout.png';
import worldIcon from '../images/world_selection.png';

let worldDataCache = {
    villages: null,
    ruins: null,
    lastFetchTimestamp: 0,
};

export const clearWorldDataCache = () => {
    worldDataCache = {
        villages: null,
        ruins: null,
        lastFetchTimestamp: 0,
    };
};

const getWarehouseCapacity = (level) => {
    if (!level) return 0;
    return Math.floor(1500 * Math.pow(1.4, level - 1));
};

const Game = ({ onBackToWorlds }) => {
    const { activeCityId, setActiveCityId, worldId, loading, gameState, playerCities, conqueredVillages, renameCity, playerCity, playerGameData } = useGame();
    const { currentUser, userProfile } = useAuth();
    const { acceptAllianceInvitation, declineAllianceInvitation, sendAllianceInvitation } = useAlliance();
    const [view, setView] = useState('city');
    const [isChatOpen, setIsChatOpen] = useState(false);
    const [panToCoords, setPanToCoords] = useState(null);
    const [viewingReportId, setViewingReportId] = useState(null);
    const [selectedGodTownId, setSelectedGodTownId] = useState(null);
    const [initialMapAction, setInitialMapAction] = useState(null);
    const [movements, setMovements] = useState([]);
    const [villages, setVillages] = useState({});
    const [ruins, setRuins] = useState({});
    const [godTowns, setGodTowns] = useState({});
    const prevActiveCityIdRef = useRef();
    const prevViewRef = useRef();
    const [isManagementPanelOpen, setIsManagementPanelOpen] = useState(false); // #comment State for ManagementPanel

    useMovementProcessor(worldId);
    const { modalState, openModal, closeModal } = useModalState();
    const { modalState: cityModalState, openModal: openCityModal, closeModal: closeCityModal, setModalState: setCityModalState } = useCityModalManager();
    const { unreadReportsCount, setUnreadReportsCount, unreadMessagesCount, setUnreadMessagesCount } = useMapState();

    const showMap = () => setView('map');
    const showCity = useCallback((cityId) => {
        if (cityId) setActiveCityId(cityId);
        setView('city');
    }, [setActiveCityId]);

    const { handleCancelMovement, handleActionClick } = useMapActions(openModal, closeModal, showCity, () => {});

    const toggleView = () => {
        setView(prevView => prevView === 'city' ? 'map' : 'city');
    };

    const centerOnCity = useCallback(() => {
        if (view === 'map' && playerCity) {
            setPanToCoords({ x: playerCity.x, y: playerCity.y });
        }
    }, [view, playerCity]);

    const switchCity = useCallback((cityId) => {
        setActiveCityId(cityId);
    }, [setActiveCityId]);

    // #comment This effect pans the map to the active city only when the city ID or view actually changes.
    useEffect(() => {
        if (view === 'map') {
            const hasCityChanged = activeCityId !== prevActiveCityIdRef.current;
            const hasViewChanged = view !== prevViewRef.current;

            if (hasCityChanged || hasViewChanged) {
                const nextCity = playerCities[activeCityId];
                if (nextCity) {
                    setPanToCoords({ x: nextCity.x, y: nextCity.y });
                }
            }
        }
        // #comment Update refs for the next render
        prevActiveCityIdRef.current = activeCityId;
        prevViewRef.current = view;
    }, [activeCityId, view, playerCities]);


    useEffect(() => {
        if (!currentUser || !worldId) return;

        const userDocRef = doc(db, "users", currentUser.uid);
        const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);

        const updatePresence = async () => {
            const timestamp = serverTimestamp();
            try {
                await updateDoc(userDocRef, { lastSeen: timestamp });
                await updateDoc(gameDocRef, { lastSeen: timestamp });
            } catch (error) {
                if (error.code !== 'not-found') {
                    console.error("Failed to update presence:", error);
                }
            }
        };

        updatePresence();
        const presenceInterval = setInterval(updatePresence, 3 * 60 * 1000);

        const handleBeforeUnload = () => {
             if (currentUser) {
                updateDoc(userDocRef, { lastSeen: null });
                updateDoc(gameDocRef, { lastSeen: null });
            }
        };

        window.addEventListener('beforeunload', handleBeforeUnload);

        return () => {
            clearInterval(presenceInterval);
            window.removeEventListener('beforeunload', handleBeforeUnload);
        }
    }, [currentUser, worldId]);

    const handleLogout = async () => {
        if (currentUser) {
            const userDocRef = doc(db, "users", currentUser.uid);
            const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);
            await updateDoc(userDocRef, { lastSeen: null });
            await updateDoc(gameDocRef, { lastSeen: null });
        }
        signOut(auth);
    };

    const cycleCity = useCallback((direction) => {
        const sortedCities = Object.values(playerCities).sort((a, b) => a.cityName.localeCompare(b.cityName));
        const cityIds = sortedCities.map(c => c.id);
        if (cityIds.length <= 1) return;

        const currentIndex = cityIds.indexOf(activeCityId);
        let nextIndex;
        if (direction === 'right') {
            nextIndex = (currentIndex + 1) % cityIds.length;
        } else {
            nextIndex = (currentIndex - 1 + cityIds.length) % cityIds.length;
        }
        const nextCityId = cityIds[nextIndex];
        switchCity(nextCityId);
    }, [playerCities, activeCityId, switchCity]);

    useKeyboardControls({
        view,
        toggleView,
        openAlliance: () => openModal('alliance'),
        openQuests: () => openModal('quests'),
        centerOnCity,
        openForum: () => openModal('allianceForum'),
        openMessages: () => openModal('messages'),
        openLeaderboard: () => openModal('leaderboard'),
        openProfile: () => openModal('profile'),
        openSettings: () => openModal('settings'),
        cycleCityLeft: () => cycleCity('left'),
        cycleCityRight: () => cycleCity('right'),
        openSenate: () => openCityModal('isSenateViewOpen'),
        openBarracks: () => openCityModal('isBarracksMenuOpen'),
        openShipyard: () => openCityModal('isShipyardMenuOpen'),
        openAcademy: () => openCityModal('isAcademyMenuOpen'),
        openMarket: () => openCityModal('isMarketMenuOpen'),
        openTemple: () => openCityModal('isTempleMenuOpen'),
    });

    useEffect(() => {
        if (!worldId || !currentUser) return;

        const movementsRef = collection(db, 'worlds', worldId, 'movements');
        const q = query(movementsRef, where('involvedParties', 'array-contains', currentUser.uid));
        const unsubscribeMovements = onSnapshot(q, (snapshot) => {
            const allMovements = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setMovements(allMovements.sort((a, b) => a.arrivalTime.toMillis() - b.arrivalTime.toMillis()));
        });

        const fetchWorldData = async () => {
            const now = Date.now();
            const CACHE_DURATION = 15 * 60 * 1000;
            if (now - worldDataCache.lastFetchTimestamp < CACHE_DURATION && worldDataCache.villages && worldDataCache.ruins) {
                setVillages(worldDataCache.villages);
                setRuins(worldDataCache.ruins);
                return;
            }

            const villagesColRef = collection(db, 'worlds', worldId, 'villages');
            const villagesSnapshot = await getDocs(villagesColRef);
            const villagesData = {};
            villagesSnapshot.forEach(doc => {
                villagesData[doc.id] = { id: doc.id, ...doc.data() };
            });
            setVillages(villagesData);
            worldDataCache.villages = villagesData;

            const ruinsColRef = collection(db, 'worlds', worldId, 'ruins');
            const ruinsSnapshot = await getDocs(ruinsColRef);
            const ruinsData = {};
            ruinsSnapshot.forEach(doc => {
                ruinsData[doc.id] = { id: doc.id, ...doc.data() };
            });
            setRuins(ruinsData);
            worldDataCache.ruins = ruinsData;

            worldDataCache.lastFetchTimestamp = now;
        };

        fetchWorldData();

        const godTownsColRef = collection(db, 'worlds', worldId, 'godTowns');
        const unsubscribeGodTowns = onSnapshot(godTownsColRef, (snapshot) => {
            const townsData = {};
            snapshot.docs.forEach(doc => {
                townsData[doc.id] = { id: doc.id, ...doc.data() };
            });
            setGodTowns(townsData);
        });

        return () => {
            unsubscribeMovements();
            unsubscribeGodTowns();
        };
    }, [worldId, currentUser]);

    const handleCancelTrain = useCallback(async (item, queueType) => {
        const cityId = item.cityId;
        const cityState = playerCities[cityId];
        const queueName = queueType === 'heal' ? 'healQueue' : `${queueType}Queue`;
        const costField = queueType === 'heal' ? 'heal_cost' : 'cost';
        const refundField = queueType === 'heal' ? 'wounded' : 'units';

        if (!cityState || !cityState[queueName]) {
            return;
        }

        const cityDocRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'cities', cityId);

        try {
            await runTransaction(db, async (transaction) => {
                const cityDoc = await transaction.get(cityDocRef);
                if (!cityDoc.exists()) throw new Error("City data not found.");
                const currentState = cityDoc.data();
                const itemIndex = currentState[queueName].findIndex(i => i.id === item.id);
                if (itemIndex === -1) throw new Error("Item not found in queue.");

                const newQueue = [...currentState[queueName]];
                const canceledTask = newQueue.splice(itemIndex, 1)[0];
                const unit = unitConfig[canceledTask.unitId];

                const capacity = getWarehouseCapacity(currentState.buildings.warehouse?.level);
                const newResources = { ...currentState.resources };
                newResources.wood = Math.min(capacity, newResources.wood + (unit[costField].wood || 0) * canceledTask.amount);
                newResources.stone = Math.min(capacity, newResources.stone + (unit[costField].stone || 0) * canceledTask.amount);
                newResources.silver = Math.min(capacity, newResources.silver + (unit[costField].silver || 0) * canceledTask.amount);

                const newRefundUnits = { ...currentState[refundField] };
                if (queueType === 'heal') {
                    newRefundUnits[canceledTask.unitId] = (newRefundUnits[canceledTask.unitId] || 0) + canceledTask.amount;
                }

                for (let i = itemIndex; i < newQueue.length; i++) {
                    const prevEndTime = (i === 0) ? Date.now() : (newQueue[i - 1].endTime.toDate ? newQueue[i - 1].endTime.toDate().getTime() : new Date(newQueue[i - 1].endTime).getTime());
                    const task = newQueue[i];
                    const taskUnit = unitConfig[task.unitId];
                    const taskTime = (queueType === 'heal' ? taskUnit.heal_time : taskUnit.cost.time) * task.amount;
                    newQueue[i].endTime = new Date(prevEndTime + taskTime * 1000);
                }

                const updates = {
                    resources: newResources,
                    [queueName]: newQueue,
                };

                if (queueType === 'heal') {
                    updates.wounded = newRefundUnits;
                }

                transaction.update(cityDocRef, updates);
            });
        } catch (error) {
            console.error("Error cancelling training:", error);
        }
    }, [worldId, currentUser, playerCities]);

    const handleRushMovement = useCallback(async (movementId) => {
        if (userProfile?.is_admin) {
            await updateDoc(doc(db, 'worlds', worldId, 'movements', movementId), { arrivalTime: new Date() });
        }
    }, [userProfile, worldId]);

    useMapEvents(currentUser, worldId, setUnreadReportsCount, setUnreadMessagesCount);
    const { quests, claimReward: claimQuestReward, isClaiming } = useQuestTracker(gameState);

    const { incomingAttackCount, isUnderAttack } = useMemo(() => {
        if (!movements || !playerCities) return { incomingAttackCount: 0, isUnderAttack: false };
        const cityIds = Object.keys(playerCities);
        const count = movements.filter(m =>
            (m.type === 'attack' && cityIds.includes(m.targetCityId) && m.status === 'moving') ||
            (m.type === 'attack_village' && m.targetVillageId && conqueredVillages[m.targetVillageId] && m.status === 'moving')
        ).length;
        return { incomingAttackCount: count, isUnderAttack: count > 0 };
    }, [movements, playerCities, conqueredVillages]);

    const combinedSlots = useMemo(() => ({ ...playerCities, ...villages, ...ruins }), [playerCities, villages, ruins]);

    const handleOpenProfile = (userId) => openModal('profile', { userId });
    const handleOpenAllianceProfile = (allianceId) => openModal('allianceProfile', { allianceId });

    const handleGoToCityFromProfile = useCallback((x, y) => {
        setView('map');
        setPanToCoords({x, y});
        closeModal('profile');
    }, [closeModal]);

    const handleGodTownClick = (townId) => {
        setSelectedGodTownId(townId);
    };

    const handleAttackGodTown = (townData) => {
        const targetData = {
            id: townData.id,
            name: townData.name,
            cityName: townData.name,
            x: townData.x,
            y: townData.y,
            isGodTownTarget: true,
            ...townData
        };
        handleActionClick('attack', targetData);
        setSelectedGodTownId(null);
    };

    const handleOpenEvents = () => {
        openModal('eventTrigger');
    };

    const handleAction = (type, data) => {
        closeModal('reports');
        if (viewingReportId) setViewingReportId(null);
        closeModal('allianceForum');
        closeModal('messages');

        switch (type) {
            case 'city_link':
                if (data.ownerId === currentUser.uid) {
                    const city = playerCities[data.cityId];
                    if (city) {
                        closeModal('reports');
                        if (data.cityId === activeCityId) {
                            openModal('ownActiveCity', city);
                        } else {
                            openModal('ownInactiveCity', city);
                        }
                    }
                } else {
                    setInitialMapAction({ type: 'open_city_modal', coords: data.coords });
                    setView('map');
                    closeModal('reports');
                }
                break;
            case 'profile':
                handleOpenProfile(data);
                break;
            case 'alliance_profile':
                handleOpenAllianceProfile(data);
                break;
            case 'go_to_city':
                setView('map');
                setPanToCoords({ x: parseFloat(data.x), y: parseFloat(data.y) });
                break;
            case 'go_to_city_and_open_modal':
                closeModal('reports');
                setInitialMapAction({ type: 'open_city_modal', coords: data });
                setView('map');
                break;
            case 'accept_invite':
                acceptAllianceInvitation(data).catch(err => alert(err.message));
                break;
            case 'decline_invite':
                declineAllianceInvitation(data).catch(err => alert(err.message));
                break;
            case 'view_report':
                setViewingReportId(data);
                break;
            case 'viewReinforcements':
                openModal('reinforcements', data);
                break;
            default:
                console.warn(`Unhandled action type: ${type}`);
        }
    };

    if (loading) {
        return <LoadingScreen message="Loading Game..." />;
    }

    return (
        <div className="w-full h-screen bg-gray-900 text-white relative">
            {view === 'city' && (
                <CityView
                    showMap={showMap}
                    worldId={worldId}
                    openModal={openModal}
                    unreadReportsCount={unreadReportsCount}
                    unreadMessagesCount={unreadMessagesCount}
                    isUnderAttack={isUnderAttack}
                    incomingAttackCount={incomingAttackCount}
                    handleOpenAlliance={() => openModal('alliance')}
                    handleOpenProfile={handleOpenProfile}
                    movements={movements}
                    onCancelTrain={handleCancelTrain}
                    onCancelMovement={handleCancelMovement}
                    combinedSlots={combinedSlots}
                    onRenameCity={renameCity}
                    quests={quests}
                    handleOpenEvents={handleOpenEvents}
                    onSwitchCity={switchCity}
                    battlePoints={playerGameData?.battlePoints || 0}
                    cityModalState={cityModalState}
                    openCityModal={openCityModal}
                    closeCityModal={closeCityModal}
                    setCityModalState={setCityModalState}
                    onOpenManagementPanel={() => setIsManagementPanelOpen(true)}
                />
            )}
            {view === 'map' && (
                <MapView
                    showCity={showCity}
                    openModal={openModal}
                    closeModal={closeModal}
                    modalState={modalState}
                    unreadReportsCount={unreadReportsCount}
                    unreadMessagesCount={unreadMessagesCount}
                    quests={quests}
                    claimReward={claimQuestReward}
                    handleMessageAction={handleAction}
                    panToCoords={panToCoords}
                    setPanToCoords={setPanToCoords}
                    handleGoToCityFromProfile={handleGoToCityFromProfile}
                    movements={movements}
                    villages={villages}
                    ruins={ruins}
                    godTowns={godTowns}
                    onCancelTrain={handleCancelTrain}
                    onCancelMovement={handleCancelMovement}
                    isUnderAttack={isUnderAttack}
                    incomingAttackCount={incomingAttackCount}
                    onRenameCity={renameCity}
                    centerOnCity={centerOnCity}
                    onGodTownClick={handleGodTownClick}
                    handleOpenEvents={handleOpenEvents}
                    onSwitchCity={switchCity}
                    battlePoints={playerGameData?.battlePoints || 0}
                    initialMapAction={initialMapAction}
                    setInitialMapAction={setInitialMapAction}
                    onOpenManagementPanel={() => setIsManagementPanelOpen(true)}
                />
            )}
            {/* Global Modals */}
            {modalState.isReportsPanelOpen && <ReportsView onClose={() => closeModal('reports')} onActionClick={handleAction} />}
            {modalState.isMessagesPanelOpen && <MessagesView onClose={() => closeModal('messages')} onActionClick={handleAction} initialRecipientId={modalState.actionDetails?.city?.ownerId} initialRecipientUsername={modalState.actionDetails?.city?.ownerUsername} />}
            {modalState.isAllianceModalOpen && <AllianceModal onClose={() => closeModal('alliance')} onOpenAllianceProfile={handleOpenAllianceProfile} openModal={openModal} />}
            {modalState.isAllianceCreationOpen && <AllianceCreation onClose={() => closeModal('allianceCreation')} />}
            {modalState.isAllianceForumOpen && <AllianceForum onClose={() => closeModal('allianceForum')} onActionClick={handleAction} />}
            {modalState.isQuestsModalOpen && <QuestsModal quests={quests} claimReward={claimQuestReward} isClaiming={isClaiming} onClose={() => closeModal('quests')} cityState={gameState} />}
            {modalState.isProfileModalOpen && <ProfileView
                onClose={() => closeModal('profile')}
                viewUserId={modalState.viewingProfileId}
                onGoToCity={handleGoToCityFromProfile}
                onInviteToAlliance={(targetUserId) => sendAllianceInvitation(targetUserId).catch(err => alert(err.message))}
                onOpenAllianceProfile={handleOpenAllianceProfile} />}
            {modalState.isLeaderboardOpen && <Leaderboard onClose={() => closeModal('leaderboard')} onOpenProfile={handleOpenProfile} onOpenAllianceProfile={handleOpenAllianceProfile} />}
            {modalState.isAllianceProfileOpen && <AllianceProfile allianceId={modalState.viewingAllianceId} onClose={() => closeModal('allianceProfile')} onOpenProfile={handleOpenProfile} />}
            {modalState.isSettingsModalOpen && <SettingsModal onClose={() => closeModal('settings')} />}
            {modalState.isEventTriggerOpen && userProfile?.is_admin && <EventTrigger onClose={() => closeModal('eventTrigger')} />}
            {viewingReportId && <SharedReportView reportId={viewingReportId} onClose={() => setViewingReportId(null)} onActionClick={handleAction} />}
            {selectedGodTownId && (
                <GodTownModal
                    townId={selectedGodTownId}
                    onClose={() => setSelectedGodTownId(null)}
                    onAttack={handleAttackGodTown}
                />
            )}
            {modalState.isMovementsPanelOpen && <MovementsPanel
                movements={movements}
                onClose={() => closeModal('movements')}
                combinedSlots={combinedSlots}
                villages={villages}
                onCancel={handleCancelMovement}
                onRush={handleRushMovement}
                isAdmin={userProfile?.is_admin}
            />}
            {isManagementPanelOpen && <ManagementPanel onClose={() => setIsManagementPanelOpen(false)} />}
            <div className="chat-container">
                <button onClick={() => setIsChatOpen(prev => !prev)} className="chat-toggle-button">
                    💬
                </button>
                <Chat isVisible={isChatOpen} onClose={() => setIsChatOpen(false)} />
            </div>
            <div className="absolute bottom-4 left-4 z-30 flex flex-col space-y-2">
                {view === 'map' && (
                    <button onClick={onBackToWorlds} className="p-2 rounded-full shadow-lg hover:bg-blue-500 transition-colors" title="Back to Worlds">
                        <img src={worldIcon} alt="Back to Worlds" className="w-8 h-8" />
                    </button>
                )}
                <button onClick={handleLogout} className="p-2 rounded-full shadow-lg hover:bg-blue-500 transition-colors" title="Logout">
                    <img src={logoutIcon} alt="Logout" className="w-8 h-8" />
                </button>
            </div>
        </div>
    );
};
export default Game;
</file>

<file path="src/components/icons/EyeIcon.js">
import React from 'react';

const EyeIcon = (props) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" />
    <circle cx="12" cy="12" r="3" />
  </svg>
);

export default EyeIcon;
</file>

<file path="src/components/icons/EyeOffIcon.js">
import React from 'react';

const EyeOffIcon = (props) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <path d="M9.88 9.88a3 3 0 1 0 4.24 4.24" />
    <path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68" />
    <path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61" />
    <line x1="2" x2="22" y1="2" y2="22" />
  </svg>
);

export default EyeOffIcon;
</file>

<file path="src/components/leaderboard/Leaderboard.css">
.leaderboard-container {
    background-image: url('../../images/bg/leaderboard_bg.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    background-position: center;
    color: #4a2c2a;
    width: 1000px;
    height: 650px;
    display: flex;
    flex-direction: column;
    background-color: transparent;
    border: none;
    padding: 20px 35px 50px 35px; /* Added padding to fit content inside the background's border */
    position: fixed;
    z-index: 50;
}
.leaderboard-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 0 10px 0;
    background-color: transparent;
    color: #4a2c2a;
    border-bottom: none;
    height: 50px; /* Adjust height */
    cursor: move;
}

.leaderboard-header h2 {
    color: #f0e68c;
    font-family: 'IM Fell English SC', serif;
    text-shadow: 1px 1px 4px rgba(0,0,0,0.6);
}

.leaderboard-header .close-btn {
    background: none;
    border: none;
    color: #f0e68c;
    font-size: 2.5rem;
    cursor: pointer;
    line-height: 1;
}

.leaderboard-tabs {
    display: flex;
    border-bottom: 2px solid #a17c48;
    flex-wrap: wrap;
    padding-left: 2rem; /* Add padding to move tabs to the right */
}
.leaderboard-tab-btn {
    padding: 8px 16px;
    background: #d2b48c;
    color: #4a2c2a;
    border: 2px solid #8B4513;
    border-bottom: none;
    margin-right: 4px;
    margin-bottom: 0;
    cursor: pointer;
    font-weight: bold;
}
.leaderboard-tab-btn.active {
    background: transparent;
    border-bottom: 2px solid transparent;
    margin-bottom: -2px;
    margin-left: 0.5rem;
}
.leaderboard-table {
    width: 93%;
    border-collapse: collapse;
    margin-top: 1rem;
    margin-left: 2.5rem;;
}
.leaderboard-table thead {
    background-color: rgba(161, 124, 72, 0.2);
}
.leaderboard-table th {
    padding: 0.75rem;
    border-bottom: 2px solid #a17c48;
    text-align: left;
}
.leaderboard-table td {
    padding: 0.75rem;
    border-bottom: 1px solid #a17c48;
}
.player-name-btn {
    background: none;
    border: none;
    color: #4a2c2a;
    font-weight: bold;
    cursor: pointer;
    text-align: left;
    padding: 0;
}
.player-name-btn:hover {
    text-decoration: underline;
}
</file>

<file path="src/components/leaderboard/Leaderboard.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { db } from '../../firebase/config';
import { collection, getDocs, collectionGroup, query, where } from 'firebase/firestore';
import { useGame } from '../../contexts/GameContext';
import allianceResearch from '../../gameData/allianceResearch.json';
import battlePointsImage from '../../images/battle_points.png';
import './Leaderboard.css';

let leaderboardCache = {
    playerLeaderboard: null,
    allianceLeaderboard: null,
    fightersLeaderboard: null,
    lastFetchTimestamp: 0,
};

export const clearLeaderboardCache = () => {
    leaderboardCache = {
        playerLeaderboard: null,
        allianceLeaderboard: null,
        fightersLeaderboard: null,
        lastFetchTimestamp: 0,
    };
};

const Leaderboard = ({ onClose, onOpenProfile, onOpenAllianceProfile }) => {
    const { worldId, worldState } = useGame();
    const [playerLeaderboard, setPlayerLeaderboard] = useState([]);
    const [allianceLeaderboard, setAllianceLeaderboard] = useState([]);
    const [fightersLeaderboard, setFightersLeaderboard] = useState([]);
    const [loading, setLoading] = useState(true);
    const [activeTab, setActiveTab] = useState('players');

    const leaderboardRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 1000) / 2,
        y: (window.innerHeight - 650) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('leaderboard-header') || e.target.parentElement.classList.contains('leaderboard-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);

    const fetchAllPlayerData = useCallback(async () => {
        if (!worldId || !worldState) return new Map();

        const gamesGroupRef = collectionGroup(db, 'games');
        const q = query(gamesGroupRef, where('worldName', '==', worldState.name));
        const gamesSnapshot = await getDocs(q);

        const userIds = [];
        const gameDataMap = new Map();
        gamesSnapshot.forEach(gameDoc => {
            const userId = gameDoc.ref.parent.parent.id;
            userIds.push(userId);
            gameDataMap.set(userId, gameDoc.data());
        });

        if (userIds.length === 0) return new Map();

        const usersMap = new Map();
        const userDocsPromises = [];
        for (let i = 0; i < userIds.length; i += 30) {
            const chunk = userIds.slice(i, i + 30);
            const usersQuery = query(collection(db, 'users'), where('__name__', 'in', chunk));
            userDocsPromises.push(getDocs(usersQuery));
        }
        
        const userDocsSnapshots = await Promise.all(userDocsPromises);
        userDocsSnapshots.forEach(snapshot => {
            snapshot.forEach(userDoc => {
                usersMap.set(userDoc.id, userDoc.data());
            });
        });

        const playersData = new Map();
        for (const [userId, gameData] of gameDataMap.entries()) {
            const userData = usersMap.get(userId);
            if (userData) {
                playersData.set(userId, {
                    id: userId,
                    username: userData.username,
                    alliance: gameData.alliance || 'No Alliance',
                    points: gameData.totalPoints || 0,
                    battlePoints: gameData.battlePoints || 0,
                    cities: gameData.cityCount || 0,
                });
            }
        }
        return playersData;
    }, [worldId, worldState]);

    useEffect(() => {
        const fetchLeaderboards = async () => {
            setLoading(true);
            const allPlayerData = await fetchAllPlayerData();

            const playersList = Array.from(allPlayerData.values());
            playersList.sort((a, b) => b.points - a.points);
            
            const fightersList = Array.from(allPlayerData.values());
            fightersList.sort((a, b) => b.battlePoints - a.battlePoints);

            const alliancesData = [];
            if (worldId) {
                const alliancesRef = collection(db, 'worlds', worldId, 'alliances');
                const alliancesSnapshot = await getDocs(alliancesRef);
                for (const allianceDoc of alliancesSnapshot.docs) {
                    const alliance = allianceDoc.data();
                    let totalPoints = 0;
                    let totalCities = 0;
                    alliance.members.forEach(member => {
                        if (allPlayerData.has(member.uid)) {
                            const memberData = allPlayerData.get(member.uid);
                            totalPoints += memberData.points;
                            totalCities += memberData.cities;
                        }
                    });
                    
                    const baseMax = 20;
                    const researchLevel = alliance.research?.expanded_charter?.level || 0;
                    const researchBonus = allianceResearch.expanded_charter.effect.value * researchLevel;
                    const maxMembers = baseMax + researchBonus;

                    alliancesData.push({
                        id: allianceDoc.id,
                        name: alliance.name,
                        tag: alliance.tag,
                        points: totalPoints,
                        cities: totalCities,
                        memberCount: alliance.members.length,
                        maxMembers: maxMembers,
                    });
                }
                alliancesData.sort((a, b) => b.points - a.points);
            }

            setPlayerLeaderboard(playersList);
            setFightersLeaderboard(fightersList);
            setAllianceLeaderboard(alliancesData);

            leaderboardCache = {
                playerLeaderboard: playersList,
                allianceLeaderboard: alliancesData,
                fightersLeaderboard: fightersList,
                lastFetchTimestamp: Date.now(),
            };
            setLoading(false);
        };

        const now = Date.now();
        const twentyMinutes = 20 * 60 * 1000;

        if (now - leaderboardCache.lastFetchTimestamp > twentyMinutes || !leaderboardCache.playerLeaderboard) {
            fetchLeaderboards();
        } else {
            setPlayerLeaderboard(leaderboardCache.playerLeaderboard);
            setAllianceLeaderboard(leaderboardCache.allianceLeaderboard);
            setFightersLeaderboard(leaderboardCache.fightersLeaderboard);
            setLoading(false);
        }
    }, [worldId, fetchAllPlayerData]);

    // #comment Render player table
    const renderPlayerTable = () => (
        <table className="leaderboard-table">
            <thead>
                <tr>
                    <th className="text-center">Rank</th>
                    <th className="text-left">Player</th>
                    <th className="text-left">Alliance</th>
                    <th className="text-right">Cities</th>
                    <th className="text-right">Points</th>
                </tr>
            </thead>
            <tbody>
                {playerLeaderboard.map((player, index) => (
                    <tr key={player.id}>
                        <td className="text-center">{index + 1}</td>
                        <td className="text-left">
                            <button onClick={() => onOpenProfile(player.id)} className="player-name-btn">
                                {player.username}
                            </button>
                        </td>
                        <td className="text-left">{player.alliance}</td>
                        <td className="text-right">{player.cities}</td>
                        <td className="text-right">{player.points.toLocaleString()}</td>
                    </tr>
                ))}
            </tbody>
        </table>
    );

    // #comment Render fighters table
    const renderFightersTable = () => (
        <table className="leaderboard-table">
            <thead>
                <tr>
                    <th className="text-center">Rank</th>
                    <th className="text-left">Player</th>
                    <th className="text-left">Alliance</th>
                    <th className="text-right">Points</th>
                </tr>
            </thead>
            <tbody>
                {fightersLeaderboard.map((player, index) => (
                    <tr key={player.id}>
                        <td className="text-center">{index + 1}</td>
                        <td className="text-left">
                            <button onClick={() => onOpenProfile(player.id)} className="player-name-btn">
                                {player.username}
                            </button>
                        </td>
                        <td className="text-left">{player.alliance}</td>
                        <td className="text-right flex items-center justify-end">
                            {player.battlePoints.toLocaleString()}
                            <img src={battlePointsImage} alt="Battle Points" className="w-5 h-5 ml-1 inline-block"/>
                        </td>
                    </tr>
                ))}
            </tbody>
        </table>
    );

    // #comment Render alliance table
    const renderAllianceTable = () => (
        <table className="leaderboard-table">
            <thead>
                <tr>
                    <th className="text-center">Rank</th>
                    <th className="text-left">Alliance</th>
                    <th className="text-left">Tag</th>
                    <th className="text-center">Members</th>
                    <th className="text-center">Total Cities</th>
                    <th className="text-right">Points</th>
                </tr>
            </thead>
            <tbody>
                {allianceLeaderboard.map((alliance, index) => (
                    <tr key={alliance.id}>
                        <td className="text-center">{index + 1}</td>
                        <td className="text-left">
                            <button onClick={() => onOpenAllianceProfile(alliance.id)} className="player-name-btn">
                                {alliance.name}
                            </button>
                        </td>
                        <td className="text-left">{alliance.tag}</td>
                        <td className="text-center">{alliance.memberCount}/{alliance.maxMembers}</td>
                        <td className="text-center">{alliance.cities}</td>
                        <td className="text-right">{alliance.points.toLocaleString()}</td>
                    </tr>
                ))}
            </tbody>
        </table>
    );

    // #comment Render content
    const renderContent = () => {
        if (loading) {
            return <p>Loading leaderboard...</p>;
        }
        switch (activeTab) {
            case 'players':
                return renderPlayerTable();
            case 'alliances':
                return renderAllianceTable();
            case 'fighters':
                return renderFightersTable();
            default:
                return renderPlayerTable();
        }
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div
                ref={leaderboardRef}
                className="leaderboard-container"
                onClick={e => e.stopPropagation()}
                onMouseDown={handleMouseDown}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="leaderboard-header">
                    <h2 className="font-title text-3xl">Leaderboard</h2>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="leaderboard-tabs">
                    <button onClick={() => setActiveTab('players')} className={`leaderboard-tab-btn ${activeTab === 'players' ? 'active' : ''}`}>Players</button>
                    <button onClick={() => setActiveTab('alliances')} className={`leaderboard-tab-btn ${activeTab === 'alliances' ? 'active' : ''}`}>Alliances</button>
                    <button onClick={() => setActiveTab('fighters')} className={`leaderboard-tab-btn ${activeTab === 'fighters' ? 'active' : ''}`}>Fighters</button>
                </div>
                <div className="overflow-y-auto flex-grow pr-4">
                    {renderContent()}
                </div>
            </div>
        </div>
    );
};

export default Leaderboard;
</file>

<file path="src/components/management/GameDataManager.js">
import React, { useState, useEffect, useCallback } from 'react';
import { db } from '../../firebase/config';
import { doc, getDoc, setDoc } from 'firebase/firestore';
import { useGame } from '../../contexts/GameContext';
import baseUnits from '../../gameData/units.json';
import baseBuildings from '../../gameData/buildings.json';
import baseResearch from '../../gameData/research.json';
import baseQuests from '../../gameData/quests.json';
import baseGods from '../../gameData/gods.json';

const useGameData = (dataType, baseData) => {
    const { worldId } = useGame();
    const [data, setData] = useState(baseData);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchData = async () => {
            if (!worldId) return;
            setLoading(true);
            const docRef = doc(db, 'worlds', worldId, 'gameData', dataType);
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                setData(prevData => ({ ...prevData, ...docSnap.data() }));
            }
            setLoading(false);
        };
        fetchData();
    }, [worldId, dataType]);

    const saveData = async (newData) => {
        if (!worldId) return;
        const docRef = doc(db, 'worlds', worldId, 'gameData', dataType);
        await setDoc(docRef, newData, { merge: true });
        setData(prev => ({...prev, ...newData}));
    };

    return { data, loading, saveData };
};

export const TroopDataManager = () => {
    const { data: troops, loading, saveData } = useGameData('units', baseUnits);
    const [selectedUnitId, setSelectedUnitId] = useState(Object.keys(baseUnits)[0]);
    const [editedUnit, setEditedUnit] = useState(null);
    
    // #comment Define all available nations for the dropdown
    const allNations = ['Athenian', 'Spartan', 'Corinthian', 'Julian', 'Cornelian', 'Fabian', 'Ptolemaic', 'Nubian', 'Bedouin'];

    useEffect(() => {
        if (troops && selectedUnitId) {
            setEditedUnit(JSON.parse(JSON.stringify(troops[selectedUnitId])));
        }
    }, [troops, selectedUnitId]);

    const handleInputChange = (e, field, subfield = null) => {
        const { value, type } = e.target;
        const parsedValue = type === 'number' ? parseFloat(value) : value;
        setEditedUnit(prev => {
            const newUnit = { ...prev };
            if (subfield) {
                newUnit[field] = { ...newUnit[field], [subfield]: parsedValue };
            } else {
                // #comment Handle the 'None' option for nation to make a unit generic
                if (field === 'nation' && parsedValue === 'None') {
                    delete newUnit.nation;
                } else {
                    newUnit[field] = parsedValue;
                }
            }
            return newUnit;
        });
    };

    const handleSave = async () => {
        await saveData({ [selectedUnitId]: editedUnit });
        alert('Troop data saved!');
    };

    if (loading) return <div>Loading troop data...</div>;
    if (!editedUnit) return <div>Select a unit to edit.</div>;

    return (
        <div className="space-y-4">
            <select value={selectedUnitId} onChange={e => setSelectedUnitId(e.target.value)} className="w-full p-2 rounded bg-amber-200">
                {Object.keys(troops).sort((a,b) => troops[a].name.localeCompare(troops[b].name)).map(id => <option key={id} value={id}>{troops[id].name}</option>)}
            </select>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div><label>ID</label><input className="w-full p-1 bg-amber-100/50" value={selectedUnitId} readOnly /></div>
                <div><label>Name</label><input className="w-full p-1" value={editedUnit.name} onChange={e => handleInputChange(e, 'name')} /></div>
                <div className="md:col-span-2"><label>Description</label><textarea className="w-full p-1" value={editedUnit.description} onChange={e => handleInputChange(e, 'description')} /></div>
                <div>
                    <label>Nation</label>
                    <select
                        className="w-full p-1"
                        value={editedUnit.nation || 'None'}
                        onChange={e => handleInputChange(e, 'nation')}
                    >
                        <option value="None">None (Generic)</option>
                        {allNations.map(nation => (
                            <option key={nation} value={nation}>{nation}</option>
                        ))}
                    </select>
                </div>

                <h4 className="md:col-span-2 font-bold text-lg mt-2">Cost</h4>
                {Object.keys(editedUnit.cost || {}).map(res => (
                     <div key={res}><label className="capitalize">{res}</label><input type="number" className="w-full p-1" value={editedUnit.cost[res]} onChange={e => handleInputChange(e, 'cost', res)} /></div>
                ))}
                <h4 className="md:col-span-2 font-bold text-lg mt-2">Stats</h4>
                <div><label>Attack</label><input type="number" className="w-full p-1" value={editedUnit.attack} onChange={e => handleInputChange(e, 'attack')} /></div>
                <div><label>Defense</label><input type="number" className="w-full p-1" value={editedUnit.defense} onChange={e => handleInputChange(e, 'defense')} /></div>
                <div><label>Speed</label><input type="number" className="w-full p-1" value={editedUnit.speed} onChange={e => handleInputChange(e, 'speed')} /></div>
            </div>
            <button onClick={handleSave} className="papyrus-btn mt-4">Save {editedUnit.name}</button>
        </div>
    );
};

export const BuildingDataManager = () => {
    const { data: buildings, loading } = useGameData('buildings', baseBuildings);
    if (loading) return <div>Loading...</div>;
    return <div>Building Data Manager - Coming Soon!</div>;
};

export const ResearchDataManager = () => {
    const { data: research, loading } = useGameData('research', baseResearch);
    if (loading) return <div>Loading...</div>;
    return <div>Research Data Manager - Coming Soon!</div>;
};

export const QuestDataManager = () => {
    const { data: quests, loading } = useGameData('quests', baseQuests);
    if (loading) return <div>Loading...</div>;
    return <div>Quest Data Manager - Coming Soon!</div>;
};

export const GodDataManager = () => {
    const { data: gods, loading } = useGameData('gods', baseGods);
    if (loading) return <div>Loading...</div>;
    return <div>God Data Manager - Coming Soon!</div>;
};
</file>

<file path="src/components/management/managementPanel.css">
/* src/components/management/ManagementPanel.css */
.management-panel-container {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3;
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a;
    width: 90%;
    max-width: 800px;
    height: 80vh;
    display: flex;
    flex-direction: column;
}

.management-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1.5rem;
    background-color: #1e3a8a;
    color: #f0e68c;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.5rem;
    border-bottom: 2px solid #cd853f;
    flex-shrink: 0;
}

.management-tabs {
    display: flex;
    background-color: #1e3a8a;
    padding: 8px 4px;
    border-bottom: 4px solid #8B4513;
    overflow-x: auto; /* Allow horizontal scrolling */
    white-space: nowrap; /* Prevent wrapping */
    flex-shrink: 0;
}

.management-tabs button {
    flex-shrink: 0; /* Prevent buttons from shrinking */
    padding: 8px 16px;
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #4a2c2a;
    border: 2px solid #8B4513;
    border-bottom: none;
    margin-right: 4px;
    cursor: pointer;
    font-weight: bold;
}

.management-tabs button.active {
    background: #F5DEB3;
}

.management-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 1rem;
}

.management-header {
    font-family: 'IM Fell English SC', serif;
    font-size: 1.25rem;
    color: #8B4513;
    border-bottom: 2px solid #cd853f;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
}

.management-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 1rem;
}

.management-item {
    background-color: rgba(139, 69, 19, 0.1);
    border: 1px solid #d2b48c;
    border-radius: 4px;
    padding: 0.75rem;
    text-align: center;
}

.management-item.completed {
    background-color: rgba(34, 197, 94, 0.2);
    border-color: #16a34a;
}

.item-name {
    font-weight: bold;
}

.item-count, .item-status {
    font-size: 0.9rem;
    color: #6b4a2b;
}

/* Custom scrollbar for webkit browsers */
.management-content::-webkit-scrollbar,
.w-1\/3.overflow-y-auto::-webkit-scrollbar,
.w-2\/3.overflow-y-auto::-webkit-scrollbar {
    width: 8px;
}

.management-content::-webkit-scrollbar-track,
.w-1\/3.overflow-y-auto::-webkit-scrollbar-track,
.w-2\/3.overflow-y-auto::-webkit-scrollbar-track {
    background: #e6cba8;
    border-radius: 10px;
}

.management-content::-webkit-scrollbar-thumb,
.w-1\/3.overflow-y-auto::-webkit-scrollbar-thumb,
.w-2\/3.overflow-y-auto::-webkit-scrollbar-thumb {
    background: #8B4513;
    border-radius: 10px;
}

.management-content::-webkit-scrollbar-thumb:hover,
.w-1\/3.overflow-y-auto::-webkit-scrollbar-thumb:hover,
.w-2\/3.overflow-y-auto::-webkit-scrollbar-thumb:hover {
    background: #A0522D;
}
</file>

<file path="src/components/management/managementPanelpls.js">
import React, { useState, useEffect } from 'react';
import unitConfigData from '../../gameData/units.json';
import researchConfigData from '../../gameData/research.json';
import buildingConfigData from '../../gameData/buildings.json';
import godsConfigData from '../../gameData/gods.json';
import questsConfigData from '../../gameData/quests.json';
import puzzlesConfigData from '../../gameData/puzzles.json';
import allianceWondersData from '../../gameData/alliance_wonders.json';
import allianceResearchData from '../../gameData/allianceResearch.json';
import heroesData from '../../gameData/heroes.json';
import ruinsResearchData from '../../gameData/ruinsResearch.json';
import specialBuildingsData from '../../gameData/specialBuildings.json';
import './managementPanel.css';

const EditableField = ({ label, value, onChange, type = 'text', options }) => (
    <div className="flex flex-col mb-2">
        <label className="text-sm font-semibold mb-1">{label}</label>
        {type === 'textarea' ? (
            <textarea value={value} onChange={onChange} className="p-1 rounded bg-white/20 border border-amber-700" rows="3" />
        ) : type === 'select' ? (
            <select value={value} onChange={onChange} className="p-1 rounded bg-white/20 border border-amber-700">
                {options.map(opt => <option key={opt} value={opt}>{opt}</option>)}
            </select>
        ) : type === 'checkbox' ? (
            <input type="checkbox" checked={!!value} onChange={onChange} className="w-6 h-6" />
        ) : (
            <input type={type} value={value} onChange={onChange} className="p-1 rounded bg-white/20 border border-amber-700" />
        )}
    </div>
);

const ObjectEditor = ({ data, onChange, title, typeOptions = {} }) => {
    if (!data) {
        return null;
    }
    const handleValueChange = (key, value) => {
        const newData = { ...data };
        newData[key] = isNaN(parseFloat(value)) ? value : parseFloat(value);
        onChange(newData);
    };

    return (
        <div className="p-2 border border-amber-700 rounded mt-2">
            <h4 className="font-bold text-center">{title}</h4>
            {Object.entries(data).map(([key, value]) => {
                if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                    return (
                        <div key={key} className="mt-2">
                            <h5 className="font-semibold capitalize text-center">{key}</h5>
                            {Object.entries(value).map(([subKey, subValue]) => (
                                <div key={subKey} className="flex items-center justify-between my-1">
                                    <label className="text-sm capitalize">{subKey.replace(/([A-Z])/g, ' $1')}</label>
                                    <input
                                        type="number"
                                        value={subValue}
                                        onChange={(e) => {
                                            const newSubObject = { ...value, [subKey]: isNaN(parseFloat(e.target.value)) ? e.target.value : parseFloat(e.target.value) };
                                            onChange({ ...data, [key]: newSubObject });
                                        }}
                                        className="w-24 p-1 rounded bg-white/20 border border-amber-700 text-right"
                                    />
                                </div>
                            ))}
                        </div>
                    );
                }
                if (key === 'type' && typeOptions[title]) {
                    return (
                        <div key={key} className="flex items-center justify-between my-1">
                            <label className="text-sm capitalize">Type</label>
                            <select value={value} onChange={(e) => handleValueChange(key, e.target.value)} className="p-1 rounded bg-white/20 border border-amber-700">
                                {typeOptions[title].map(opt => <option key={opt} value={opt}>{opt}</option>)}
                            </select>
                        </div>
                    );
                }
                return (
                    <div key={key} className="flex items-center justify-between my-1">
                        <label className="text-sm capitalize">{key.replace(/([A-Z])/g, ' $1')}</label>
                        <input
                            type={typeof value === 'number' ? 'number' : 'text'}
                            value={value}
                            onChange={(e) => handleValueChange(key, e.target.value)}
                            className="w-24 p-1 rounded bg-white/20 border border-amber-700 text-right"
                        />
                    </div>
                );
            })}
        </div>
    );
};

const ArrayEditor = ({ data, onChange, title, options }) => {
    const handleAddItem = () => {
        if (options && options.length > 0) {
            onChange([...(data || []), options[0]]);
        }
    };

    const handleItemChange = (index, newValue) => {
        const newData = [...data];
        newData[index] = newValue;
        onChange(newData);
    };

    const handleRemoveItem = (index) => {
        const newData = [...data];
        newData.splice(index, 1);
        onChange(newData);
    };

    return (
        <div className="p-2 border border-amber-700 rounded mt-2">
            <h4 className="font-bold text-center">{title}</h4>
            {(data || []).map((item, index) => (
                <div key={index} className="flex items-center gap-2 my-1">
                    <select value={item} onChange={(e) => handleItemChange(index, e.target.value)} className="flex-grow p-1 rounded bg-white/20 border border-amber-700">
                        {options.map(opt => <option key={opt} value={opt}>{opt}</option>)}
                    </select>
                    <button onClick={() => handleRemoveItem(index)} className="btn-danger text-xs px-2 py-1 rounded">-</button>
                </div>
            ))}
            <button onClick={handleAddItem} className="btn-confirm w-full text-xs mt-2 py-1">Add</button>
        </div>
    );
};

const ComplexArrayEditor = ({ data, onChange, title, type, typeOptions }) => {
    const handleItemChange = (index, field, value) => {
        const newItems = [...data];
        newItems[index] = { ...newItems[index], [field]: value };
        onChange(newItems);
    };

    const handleNestedChange = (index, topField, value) => {
        const newItems = [...data];
        try {
            newItems[index][topField] = JSON.parse(value);
            onChange(newItems);
        } catch (e) {
            console.error(`Invalid JSON for ${topField}:`, e);
        }
    };

    const handleEffectChange = (index, newEffect) => {
        const newItems = [...data];
        newItems[index] = { ...newItems[index], effect: newEffect };
        onChange(newItems);
    };

    const handleAddItem = () => {
        const newItem = type === 'powers'
            ? { name: "New Power", description: "", favorCost: 0, effect: {} }
            : { name: "New Skill", type: "battle", description: "", cost: { favor: { base: 10, perLevel: 1 } }, cooldown: 3600, icon: "", effect: {} };
        onChange([...(data || []), newItem]);
    };

    const handleRemoveItem = (index) => {
        const newItems = [...data];
        newItems.splice(index, 1);
        onChange(newItems);
    };

    return (
        <div className="p-2 border border-amber-700 rounded mt-2">
            <h4 className="font-bold text-center">{title}</h4>
            {(data || []).map((item, index) => (
                <div key={index} className="p-2 my-2 border-b border-amber-600 relative">
                    <button onClick={() => handleRemoveItem(index)} className="absolute top-0 right-0 btn-danger text-xs px-2 py-1 rounded">-</button>
                    <EditableField label="Name" value={item.name} onChange={(e) => handleItemChange(index, 'name', e.target.value)} />
                    <EditableField label="Description" value={item.description} onChange={(e) => handleItemChange(index, 'description', e.target.value)} type="textarea" />
                    {type === 'powers' && <EditableField label="Favor Cost" value={item.favorCost} onChange={(e) => handleItemChange(index, 'favorCost', parseInt(e.target.value) || 0)} type="number" />}
                    {type === 'skills' && <EditableField label="Type" value={item.type} onChange={(e) => handleItemChange(index, 'type', e.target.value)} type="select" options={['battle', 'city']} />}
                    {type === 'skills' && <EditableField label="Cost (JSON)" value={JSON.stringify(item.cost, null, 2)} onChange={(e) => handleNestedChange(index, 'cost', e.target.value)} type="textarea" />}
                    {}
                    {type === 'skills' ?
                        <ObjectEditor data={item.effect} onChange={(val) => handleEffectChange(index, val)} title="Effect/Bonus" typeOptions={typeOptions} />
                        :
                        <EditableField label="Effect (JSON)" value={JSON.stringify(item.effect, null, 2)} onChange={(e) => handleNestedChange(index, 'effect', e.target.value)} type="textarea" />
                    }
                </div>
            ))}
            <button onClick={handleAddItem} className="btn-confirm w-full text-xs mt-2 py-1">Add {type === 'powers' ? 'Power' : 'Skill'}</button>
        </div>
    );
};

const NewItemModal = ({ onConfirm, onCancel, dataType }) => {
    const [newItemId, setNewItemId] = useState('');
    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black bg-opacity-70">
            <div className="bg-gray-800 p-6 rounded-lg text-white w-full max-w-sm">
                <h3 className="text-lg font-bold mb-4">Add New {dataType}</h3>
                <input
                    type="text"
                    value={newItemId}
                    onChange={(e) => setNewItemId(e.target.value)}
                    placeholder="Enter a unique ID (e.g., new_unit)"
                    className="w-full bg-gray-700 p-2 rounded mb-4 text-white"
                />
                <div className="flex justify-end gap-2">
                    <button onClick={onCancel} className="btn btn-secondary">Cancel</button>
                    <button onClick={() => onConfirm(newItemId)} className="btn btn-confirm">Create</button>
                </div>
            </div>
        </div>
    );
};

// #comment The main component for editing all game data
const GameDataEditor = ({ dataType }) => {
    const allNations = ['Athenian', 'Spartan', 'Corinthian', 'Julian', 'Cornelian', 'Fabian', 'Ptolemaic', 'Nubian', 'Bedouin'];
    const [data, setData] = useState(() => {
        // #comment Pre-process troop data to ensure heal_cost and heal_time exist for all units
        const troopsWithDefaults = { ...unitConfigData };
        for (const unitId in troopsWithDefaults) {
            if (typeof troopsWithDefaults[unitId].heal_cost !== 'object' || troopsWithDefaults[unitId].heal_cost === null) {
                troopsWithDefaults[unitId].heal_cost = { wood: 0, stone: 0, silver: 0 };
            }
            if (typeof troopsWithDefaults[unitId].heal_time === 'undefined') {
                troopsWithDefaults[unitId].heal_time = 0;
            }
        }
        return {
            troops: troopsWithDefaults,
            buildings: buildingConfigData,
            research: researchConfigData,
            gods: godsConfigData,
            quests: questsConfigData,
            puzzles: puzzlesConfigData,
            alliance_wonders: allianceWondersData,
            alliance_research: allianceResearchData,
            heroes: heroesData,
            ruinsResearch: ruinsResearchData,
            specialBuildings: specialBuildingsData,
        };
    });
    const [selectedItemId, setSelectedItemId] = useState(null);
    const [selectedGodReligion, setSelectedGodReligion] = useState(null);
    const [isAddingNew, setIsAddingNew] = useState(false);

    useEffect(() => {
        setSelectedItemId(null);
        setSelectedGodReligion(null);
    }, [dataType]);

    const activeData = data[dataType];
    const selectedItem = selectedItemId ? (dataType === 'gods' ? activeData[selectedGodReligion]?.[selectedItemId] : activeData[selectedItemId]) : null;

    const handleSave = () => {
        console.log("Updated Game Data:", JSON.stringify(data, null, 2));
        alert("Game data saved to console! Refresh the page to see changes in other parts of the UI.");
    };
    
    const handleSelect = (id) => {
        setSelectedItemId(id);
    };

    const handleFieldChange = (field, value) => {
        if (dataType === 'gods') {
            const newData = { ...data };
            newData.gods[selectedGodReligion][selectedItemId][field] = value;
            setData(newData);
        } else {
            const newActiveData = { ...activeData };
            if (dataType === 'troops' && field === 'nation' && value === 'None') {
                delete newActiveData[selectedItemId][field];
            } else {
                newActiveData[selectedItemId][field] = value;
            }
            setData(prev => ({ ...prev, [dataType]: newActiveData }));
        }
    };

    const handleAddNewItem = (newItemId) => {
        if (!newItemId.trim()) {
            alert("ID cannot be empty.");
            return;
        }
        if (activeData[newItemId]) {
            alert("An item with this ID already exists.");
            return;
        }
        let newItem = {};
        switch (dataType) {
            case 'troops':
                newItem = { name: "New Unit", description: "", cost: { wood: 10, stone: 10, silver: 10, population: 1, time: 10 }, heal_cost: { wood: 3, stone: 3, silver: 3 }, heal_time: 5, attack: 5, defense: 5, speed: 5, type: "land", counters: [] };
                break;
            case 'buildings':
                newItem = { name: "New Building", description: "", baseCost: { wood: 50, stone: 50, silver: 50, population: 5, time: 60 }, maxLevel: 10, points: 5 };
                break;
            case 'research':
                newItem = { name: "New Research", description: "", cost: { wood: 100, stone: 100, silver: 100, time: 300, points: 10 }, requirements: { academy: 1 } };
                break;
            case 'quests':
                newItem = { title: "New Quest", description: "", type: "building", targetId: "senate", targetLevel: 2, rewards: { resources: { wood: 50 } } };
                break;
            case 'puzzles':
                newItem = { question: "New Question?", answer: "Answer" };
                break;
            case 'gods':
                if (!selectedGodReligion) {
                    alert("Please select a religion first.");
                    return;
                }
                newItem = { name: "New God", description: "", powers: [], mythical_units: [], image: "" };
                const newData = { ...data };
                newData.gods[selectedGodReligion][newItemId] = newItem;
                setData(newData);
                setIsAddingNew(false);
                setSelectedItemId(newItemId);
                return;
            case 'heroes':
                newItem = { name: "New Hero", description: "", image: "", cost: { silver: 1000, favor: 50 }, maxLevel: 10, xpPerLevel: [100], levelUpCost: { silver: 100, favor: 10 }, passive: { name: "Passive", description: "", effect: {} }, skills: [] };
                break;
            case 'alliance_wonders':
                newItem = { name: "New Wonder", description: "", bonus: { type: "", value: 0 }, image: "" };
                break;
            case 'alliance_research':
                newItem = { name: "New Research", description: "", maxLevel: 5, baseCost: { wood: 1000, stone: 1000, silver: 1000 }, costMultiplier: 1.5, effect: { type: "", value: 0 } };
                break;
            case 'ruinsResearch':
                newItem = { name: "New Ruin Research", description: "", effect: { type: "", value: 0 } };
                break;
            case 'specialBuildings':
                newItem = { name: "New Special Building", description: "", bonus: { type: "", value: 0 }, image: "" };
                break;
            default:
                break;
        }
        setData(prev => ({ ...prev, [dataType]: { ...prev[dataType], [newItemId]: newItem } }));
        setIsAddingNew(false);
        setSelectedItemId(newItemId);
    };

    const typeOptions = {
        'Effect': ['unit_speed_land', 'build_time', 'unit_attack_ranged', 'unit_speed_naval', 'unit_defense_hoplite', 'speed_boost_all', 'transport_capacity_boost', 'scout_power_boost'],
        'Effect/Bonus': [
            'attack_boost', 'defense_boost', 'speed_boost', 'max_members',
            'bank_capacity', 'naval_boost', 'land_boost', 'mythic_boost',
            'population_boost', 'trade_boost', 'research_boost', 'fortification_boost',
            'morale_boost', 'trade_efficiency', 'production_boost_wood', 'production_boost_stone',
            'production_boost_silver', 'donation_cooldown_reduction', 'donation_limit_increase',
            'village_demand_boost', 'cave_capacity_boost', 'warehouse_capacity_boost',
            'favor_production_boost', 'unit_training_speed_boost', 'city_buff', 'troop_buff'
        ],
    };

    const renderEditor = () => {
        if (!selectedItem) return <div className="text-center p-8">Select an item to edit.</div>;
        switch (dataType) {
            case 'troops':
                // #comment Get the base unit type by splitting the ID string.
                const genericType = selectedItemId.split('_')[0];
                return (
                    <div className="p-2">
                        <div className="flex flex-col mb-2">
                            <label className="text-sm font-semibold mb-1">ID</label>
                            <input value={selectedItemId} readOnly className="p-1 rounded bg-amber-100/50 border border-amber-700" />
                        </div>
                        <div className="flex flex-col mb-2">
                            <label className="text-sm font-semibold mb-1">Base Type</label>
                            <input value={genericType} readOnly className="p-1 rounded bg-amber-100/50 border border-amber-700" />
                        </div>
                        <EditableField label="Name" value={selectedItem.name} onChange={(e) => handleFieldChange('name', e.target.value)} />
                        <EditableField label="Nation" value={selectedItem.nation || 'None'} onChange={(e) => handleFieldChange('nation', e.target.value)} type="select" options={['None', ...allNations]} />
                        <EditableField label="Description" value={selectedItem.description} onChange={(e) => handleFieldChange('description', e.target.value)} type="textarea" />
                        <EditableField label="Type" value={selectedItem.type} onChange={(e) => handleFieldChange('type', e.target.value)} type="select" options={['land', 'naval']} />
                        <EditableField label="Flying" value={selectedItem.flying} onChange={(e) => handleFieldChange('flying', e.target.checked)} type="checkbox" />
                        <EditableField label="Attack" value={selectedItem.attack} onChange={(e) => handleFieldChange('attack', parseInt(e.target.value) || 0)} type="number" />
                        <EditableField label="Defense" value={selectedItem.defense} onChange={(e) => handleFieldChange('defense', parseInt(e.target.value) || 0)} type="number" />
                        <EditableField label="Speed" value={selectedItem.speed} onChange={(e) => handleFieldChange('speed', parseInt(e.target.value) || 0)} type="number" />
                        <ObjectEditor data={selectedItem.cost} onChange={(val) => handleFieldChange('cost', val)} title="Cost" />
                        <ObjectEditor data={selectedItem.heal_cost} onChange={(val) => handleFieldChange('heal_cost', val)} title="Heal Cost" />
                        <EditableField label="Heal Time" value={selectedItem.heal_time} onChange={(e) => handleFieldChange('heal_time', parseInt(e.target.value) || 0)} type="number" />
                        <ArrayEditor data={selectedItem.counters || []} onChange={(val) => handleFieldChange('counters', val)} title="Counters" options={Object.keys(data.troops)} />
                    </div>
                );
            case 'buildings':
                 return (
                    <div className="p-2">
                        <EditableField label="Name" value={selectedItem.name} onChange={(e) => handleFieldChange('name', e.target.value)} />
                        <EditableField label="Description" value={selectedItem.description} onChange={(e) => handleFieldChange('description', e.target.value)} type="textarea" />
                        <ObjectEditor data={selectedItem.baseCost} onChange={(val) => handleFieldChange('baseCost', val)} title="Base Cost" />
                        {selectedItem.requirements && <ObjectEditor data={selectedItem.requirements} onChange={(val) => handleFieldChange('requirements', val)} title="Requirements" />}
                    </div>
                );
            case 'research':
                return (
                    <div className="p-2">
                        <EditableField label="Name" value={selectedItem.name} onChange={(e) => handleFieldChange('name', e.target.value)} />
                        <EditableField label="Description" value={selectedItem.description} onChange={(e) => handleFieldChange('description', e.target.value)} type="textarea" />
                        <ObjectEditor data={selectedItem.cost} onChange={(val) => handleFieldChange('cost', val)} title="Cost" />
                        <ObjectEditor data={selectedItem.effect} onChange={(val) => handleFieldChange('effect', val)} title="Effect" typeOptions={typeOptions} />
                        {selectedItem.requirements && <ObjectEditor data={selectedItem.requirements} onChange={(val) => handleFieldChange('requirements', val)} title="Requirements" />}
                    </div>
                );
            case 'gods':
                return (
                    <div className="p-2">
                        <EditableField label="Name" value={selectedItem.name} onChange={(e) => handleFieldChange('name', e.target.value)} />
                        <EditableField label="Description" value={selectedItem.description} onChange={(e) => handleFieldChange('description', e.target.value)} type="textarea" />
                        <ComplexArrayEditor data={selectedItem.powers || []} onChange={(val) => handleFieldChange('powers', val)} title="Powers" type="powers" />
                        <ArrayEditor data={selectedItem.mythical_units || []} onChange={(val) => handleFieldChange('mythical_units', val)} title="Mythical Units" options={Object.keys(data.troops)} />
                    </div>
                );
            case 'quests':
                return (
                     <div className="p-2">
                        <EditableField label="Title" value={selectedItem.title} onChange={(e) => handleFieldChange('title', e.target.value)} />
                        <EditableField label="Description" value={selectedItem.description} onChange={(e) => handleFieldChange('description', e.target.value)} type="textarea" />
                        <EditableField label="Type" value={selectedItem.type} onChange={(e) => handleFieldChange('type', e.target.value)} type="select" options={['building', 'units']} />
                        <EditableField label="Target ID" value={selectedItem.targetId} onChange={(e) => handleFieldChange('targetId', e.target.value)} />
                        <EditableField label="Target Level/Count" value={selectedItem.targetLevel || selectedItem.targetCount} onChange={(e) => handleFieldChange(selectedItem.targetLevel ? 'targetLevel' : 'targetCount', parseInt(e.target.value))} type="number" />
                        <ObjectEditor data={selectedItem.rewards} onChange={(val) => handleFieldChange('rewards', val)} title="Rewards" />
                    </div>
                );
            case 'puzzles':
                 return (
                    <div className="p-2">
                        <EditableField label="Question" value={selectedItem.question} onChange={(e) => handleFieldChange('question', e.target.value)} type="textarea" />
                        <EditableField label="Answer" value={selectedItem.answer} onChange={(e) => handleFieldChange('answer', e.target.value)} />
                    </div>
                );
             case 'heroes':
                const handlePassiveChange = (field, value) => {
                    const newPassive = { ...selectedItem.passive, [field]: value };
                    handleFieldChange('passive', newPassive);
                };
                return (
                    <div className="p-2">
                        <EditableField label="Name" value={selectedItem.name} onChange={(e) => handleFieldChange('name', e.target.value)} />
                        <EditableField label="Description" value={selectedItem.description} onChange={(e) => handleFieldChange('description', e.target.value)} type="textarea" />
                        <ObjectEditor data={selectedItem.cost} onChange={(val) => handleFieldChange('cost', val)} title="Recruit Cost" />
                        <ObjectEditor data={selectedItem.levelUpCost} onChange={(val) => handleFieldChange('levelUpCost', val)} title="Level Up Cost" />
                        <div className="p-2 border border-amber-700 rounded mt-2">
                            <h4 className="font-bold text-center">Passive Skill</h4>
                            <EditableField label="Passive Name" value={selectedItem.passive.name} onChange={(e) => handlePassiveChange('name', e.target.value)} />
                            <EditableField label="Passive Description" value={selectedItem.passive.description} onChange={(e) => handlePassiveChange('description', e.target.value)} type="textarea" />
                            <ObjectEditor data={selectedItem.passive.effect} onChange={(val) => handlePassiveChange('effect', val)} title="Effect/Bonus" typeOptions={typeOptions} />
                        </div>
                        <ComplexArrayEditor data={selectedItem.skills || []} onChange={(val) => handleFieldChange('skills', val)} title="Active Skills" type="skills" typeOptions={typeOptions}/>
                    </div>
                );
            case 'alliance_wonders':
            case 'specialBuildings':
            case 'ruinsResearch':
            case 'alliance_research':
                return (
                    <div className="p-2">
                        <EditableField label="Name" value={selectedItem.name} onChange={(e) => handleFieldChange('name', e.target.value)} />
                        <EditableField label="Description" value={selectedItem.description} onChange={(e) => handleFieldChange('description', e.target.value)} type="textarea" />
                        <ObjectEditor data={selectedItem.effect || selectedItem.bonus} onChange={(val) => handleFieldChange(selectedItem.effect ? 'effect' : 'bonus', val)} title="Effect/Bonus" typeOptions={typeOptions} />
                        {selectedItem.baseCost && <ObjectEditor data={selectedItem.baseCost} onChange={(val) => handleFieldChange('baseCost', val)} title="Base Cost" />}
                    </div>
                );
            default:
                return <p>Editor not implemented for this type.</p>;
        }
    };

    const renderList = () => {
        if (dataType === 'gods') {
            if (!selectedGodReligion) {
                return Object.keys(activeData).map(religion => (
                    <div key={religion} onClick={() => setSelectedGodReligion(religion)} className="p-2 cursor-pointer hover:bg-amber-200/50 capitalize">
                        {religion}
                    </div>
                ));
            }
            return (
                <>
                    <button onClick={() => setSelectedGodReligion(null)} className="p-2 font-bold hover:bg-amber-200/50 w-full text-left">← Back to Religions</button>
                    <button onClick={() => setIsAddingNew(true)} className="p-2 font-bold text-green-600 hover:bg-green-200/50 w-full text-left">New God...</button>
                    {Object.entries(activeData[selectedGodReligion]).map(([godId, godData]) => (
                         <div key={godId} onClick={() => handleSelect(godId)} className={`p-2 cursor-pointer hover:bg-amber-200/50 ${selectedItemId === godId ? 'bg-amber-300/50' : ''}`}>
                            {godData.name}
                        </div>
                    ))}
                </>
            );
        }
        return (
            <>
                <button onClick={() => setIsAddingNew(true)} className="p-2 font-bold text-green-600 hover:bg-green-200/50 w-full text-left">New...</button>
                {Object.entries(activeData).map(([id, item]) => (
                    <div key={id} onClick={() => handleSelect(id)} className={`p-2 cursor-pointer hover:bg-amber-200/50 ${selectedItemId === id ? 'bg-amber-300/50' : ''}`}>
                        {item.name || item.title || id}
                    </div>
                ))}
            </>
        );
    };

    return (
        <div className="h-full flex flex-col">
            {isAddingNew && <NewItemModal onConfirm={handleAddNewItem} onCancel={() => setIsAddingNew(false)} dataType={dataType} />}
            <div className="flex-grow flex overflow-hidden">
                <div className="w-1/3 border-r-2 border-[#8B4513] overflow-y-auto">
                    {renderList()}
                </div>
                <div className="w-2/3 overflow-y-auto">
                    {renderEditor()}
                </div>
            </div>
            <button onClick={handleSave} className="w-full py-2 mt-2 btn-confirm">Save All Game Data</button>
        </div>
    );
};

const ManagementPanel = ({ onClose }) => {
    const [activeTab, setActiveTab] = useState('troops');
    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="management-panel-container" onClick={e => e.stopPropagation()}>
                <div className="management-panel-header">
                    <h2>Imperial Manager</h2>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="management-tabs">
                    <button onClick={() => setActiveTab('troops')} className={activeTab === 'troops' ? 'active' : ''}>Troops</button>
                    <button onClick={() => setActiveTab('buildings')} className={activeTab === 'buildings' ? 'active' : ''}>Buildings</button>
                    <button onClick={() => setActiveTab('research')} className={activeTab === 'research' ? 'active' : ''}>Research</button>
                    <button onClick={() => setActiveTab('gods')} className={activeTab === 'gods' ? 'active' : ''}>Gods</button>
                    <button onClick={() => setActiveTab('quests')} className={activeTab === 'quests' ? 'active' : ''}>Quests</button>
                    <button onClick={() => setActiveTab('puzzles')} className={activeTab === 'puzzles' ? 'active' : ''}>Puzzles</button>
                    <button onClick={() => setActiveTab('heroes')} className={activeTab === 'heroes' ? 'active' : ''}>Heroes</button>
                    <button onClick={() => setActiveTab('alliance_wonders')} className={activeTab === 'alliance_wonders' ? 'active' : ''}>Alliance Wonders</button>
                    <button onClick={() => setActiveTab('alliance_research')} className={activeTab === 'alliance_research' ? 'active' : ''}>Alliance Research</button>
                    <button onClick={() => setActiveTab('ruinsResearch')} className={activeTab === 'ruinsResearch' ? 'active' : ''}>Ruins Research</button>
                    <button onClick={() => setActiveTab('specialBuildings')} className={activeTab === 'specialBuildings' ? 'active' : ''}>Special Buildings</button>
                </div>
                <div className="management-content">
                    <GameDataEditor dataType={activeTab} />
                </div>
            </div>
        </div>
    );
};

export default ManagementPanel;
</file>

<file path="src/components/map/AllianceModal.css">
/* src/components/map/AllianceModal.css */
.alliance-modal {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #000;
    border-radius: 0;
    width: 1000px;
    height: 700px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.alliance-modal-header {
    background-color: #1e3a8a;
    padding: 1rem 1.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 2px solid #cd853f;
    color: #f0e68c;
    cursor: move;
}

.alliance-modal-header h2 {
    font-family: 'IM Fell English SC', serif;
}

.alliance-modal-tabs {
    display: flex;
    background: #1e3a8a;
    border-bottom: 4px solid #8B4513;
    flex-wrap: wrap; /* Allow tabs to wrap */
    padding: 4px;
}

.alliance-modal-tabs button {
    padding: 0.8rem 1.5rem;
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    border: 2px solid #8B4513;
    border-bottom: none;
    color: #000;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    white-space: nowrap;
    margin-right: 4px;
    margin-bottom: 4px; /* Add margin for wrapped tabs */
}

.alliance-modal-tabs button:hover {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}

.alliance-modal-tabs button.active {
    color: #000;
    background: #F5DEB3;
}

.alliance-modal-content {
    padding: 1.5rem;
    flex-grow: 1;
    overflow-y: auto;
    background-color: #F5DEB3; /* Added solid background color */
}

.close-button {
    background: none;
    border: none;
    color: #f0e68c;
    font-size: 1.8rem;
    cursor: pointer;
    transition: color 0.2s;
}

.close-button:hover {
    color: white;
}

/* Settings specific styles */
.settings-section {
    background: rgba(139, 69, 19, 0.1);
    border-radius: 8px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    border: 1px solid #d2b48c;
}

.settings-section h3 {
    color: #8B4513;
    margin-bottom: 1rem;
    font-size: 1.2rem;
    font-family: 'IM Fell English SC', serif;
}

.settings-input {
    width: 100%;
    padding: 0.8rem;
    background: rgba(255, 255, 255, 0.5);
    border: 1px solid #d2b48c;
    border-radius: 4px;
    color: #000;
    margin-bottom: 1rem;
}

.settings-input:focus {
    outline: none;
    border-color: #8B4513;
}

.settings-textarea {
    min-height: 120px;
    resize: vertical;
}

.save-button {
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #000;
    border: 2px solid #8B4513;
    padding: 0.8rem 1.5rem;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.2s;
}

.save-button:hover {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}

/* Status badge */
.status-badge {
    display: inline-block;
    padding: 0.3rem 0.6rem;
    border-radius: 20px;
    font-size: 0.8rem;
    font-weight: 600;
    margin-left: 0.5rem;
}

.status-open {
    background: rgba(46, 204, 113, 0.2);
    color: #2ecc71;
}

.status-invite_only {
    background: rgba(241, 196, 15, 0.2);
    color: #f1c40f;
}

.status-closed {
    background: rgba(231, 76, 60, 0.2);
    color: #e74c3c;
}
</file>

<file path="src/components/map/AllianceModal.js">
// src/components/map/AllianceModal.js
import React, { useState, useRef, useCallback, useEffect } from 'react';
import { useAlliance } from '../../contexts/AllianceContext';
import { useAuth } from '../../contexts/AuthContext';
import AllianceOverview from '../alliance/AllianceOverview';
import AllianceMembers from '../alliance/AllianceMembers';
import AllianceResearch from '../alliance/AllianceResearch';
import AllianceDiplomacy from '../alliance/AllianceDiplomacy';
import AllianceSettings from '../alliance/AllianceSettings';
import AllianceInvitations from '../alliance/AllianceInvitations';
import AllianceRanks from '../alliance/AllianceRanks';
import AllianceProperties from '../alliance/AllianceProperties';
import AllianceBank from '../alliance/AllianceBank';
import AllianceSuggestions from '../alliance/AllianceSuggestions';
import AllianceCreation from '../alliance/AllianceCreation';
import './AllianceModal.css';

const AllianceModal = ({ onClose, onOpenAllianceProfile, openModal }) => {
    const { playerAlliance } = useAlliance();
    const { currentUser } = useAuth();
    const [activeTab, setActiveTab] = useState(playerAlliance ? 'overview' : 'suggestions');
    const [isCreating, setIsCreating] = useState(false);

    // #comment Draggable state and handlers
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 1000) / 2, // Center horizontally
        y: (window.innerHeight * 0.1) / 2  // Position near the top
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
    const modalRef = useRef(null);

    const handleMouseDown = (e) => {
        // Draggable only by the header or its direct children
        if (e.target.classList.contains('alliance-modal-header') || e.target.parentElement.classList.contains('alliance-modal-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);

    const handleOpenCreate = () => {
        setIsCreating(true);
    };

    const handleCloseCreate = () => {
        setIsCreating(false);
        onClose(); // Close the main alliance modal too after creation
    };

    if (isCreating) {
        return <AllianceCreation onClose={handleCloseCreate} />;
    }

    if (!playerAlliance) {
        return (
            <div className="fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4" onClick={onClose}>
                <div className="alliance-modal" onClick={e => e.stopPropagation()}>
                    <div className="alliance-modal-header">
                        <h2 className="text-2xl font-bold text-white">Join an Alliance</h2>
                        <button onClick={onClose} className="close-button">&times;</button>
                    </div>
                    <div className="alliance-modal-content">
                        <AllianceSuggestions onAllianceClick={onOpenAllianceProfile} onOpenCreate={handleOpenCreate} />
                    </div>
                </div>
            </div>
        );
    }

    const isLeader = currentUser.uid === playerAlliance.leader.uid;

    const renderTabContent = () => {
        switch (activeTab) {
            case 'overview': return <AllianceOverview />;
            case 'members': return <AllianceMembers />;
            case 'research': return <AllianceResearch />;
            case 'diplomacy': return <AllianceDiplomacy />;
            case 'bank': return <AllianceBank />;
            case 'properties': return <AllianceProperties onClose={onClose} />;
            case 'settings': return <AllianceSettings alliance={playerAlliance} isLeader={isLeader} />;
            case 'invitations': return <AllianceInvitations alliance={playerAlliance} isLeader={isLeader} />;
            case 'ranks': return <AllianceRanks alliance={playerAlliance} isLeader={isLeader} />;
            default: return <AllianceOverview />;
        }
    };

    return (
        <div 
            className="alliance-modal" 
            ref={modalRef}
            style={{ 
                position: 'fixed', 
                top: `${position.y}px`, 
                left: `${position.x}px`,
                zIndex: 50 
            }}
            onClick={e => e.stopPropagation()}
        >
            <div className="alliance-modal-header" onMouseDown={handleMouseDown}>
                <div>
                    <h2 className="text-2xl font-bold text-white">{playerAlliance.name}</h2>
                    <p className="text-gray-300">[{playerAlliance.tag}]</p>
                </div>
                <button onClick={onClose} className="close-button">&times;</button>
            </div>
            
            <div className="alliance-modal-tabs">
                <button onClick={() => setActiveTab('overview')} className={activeTab === 'overview' ? 'active' : ''}>Overview</button>
                <button onClick={() => setActiveTab('members')} className={activeTab === 'members' ? 'active' : ''}>Members</button>
                <button onClick={() => setActiveTab('research')} className={activeTab === 'research' ? 'active' : ''}>Research</button>
                <button onClick={() => setActiveTab('diplomacy')} className={activeTab === 'diplomacy' ? 'active' : ''}>Diplomacy</button>
                <button onClick={() => setActiveTab('bank')} className={activeTab === 'bank' ? 'active' : ''}>Bank</button>
                <button onClick={() => setActiveTab('properties')} className={activeTab === 'properties' ? 'active' : ''}>Properties</button>
                {isLeader && (
                    <>
                        <button onClick={() => setActiveTab('settings')} className={activeTab === 'settings' ? 'active' : ''}>Settings</button>
                        <button onClick={() => setActiveTab('invitations')} className={activeTab === 'invitations' ? 'active' : ''}>Invitations</button>
                        <button onClick={() => setActiveTab('ranks')} className={activeTab === 'ranks' ? 'active' : ''}>Ranks</button>
                    </>
                )}
            </div>
            
            <div className="alliance-modal-content">
                {renderTabContent()}
            </div>
        </div>
    );
};

export default AllianceModal;
</file>

<file path="src/components/map/Countdown.js">
// src/components/map/Countdown.js
import React, { useState, useEffect } from 'react';

// #comment Displays a live countdown to a specific time.
const Countdown = ({ arrivalTime }) => {
    const [timeLeft, setTimeLeft] = useState('');

    useEffect(() => {
        // #comment Safely converts various timestamp formats into a JS Date object.
        const getSafeDate = (timestamp) => {
            if (!timestamp) return null;
            // Handles live Firestore Timestamp objects
            if (typeof timestamp.toDate === 'function') {
                return timestamp.toDate();
            }
            // Handles serialized Firestore Timestamps (plain objects)
            if (timestamp.seconds && typeof timestamp.seconds === 'number') {
                return new Date(timestamp.seconds * 1000);
            }
            // Handles JS Dates or millisecond numbers
            return new Date(timestamp);
        };

        const arrival = getSafeDate(arrivalTime);

        // #comment If the date is invalid or in the past, show 'Completed'.
        if (!arrival || isNaN(arrival.getTime())) {
            setTimeLeft('Completed');
            return;
        }

        const calculateTimeLeft = () => {
            const now = new Date();
            const difference = arrival - now;

            if (difference > 0) {
                const totalSeconds = Math.ceil(difference / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                setTimeLeft(`${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`);
            } else {
                setTimeLeft('Completed');
            }
        };

        calculateTimeLeft();
        const interval = setInterval(calculateTimeLeft, 1000);

        return () => clearInterval(interval);
    }, [arrivalTime]);

    return <span>{timeLeft}</span>;
};

export default Countdown;
</file>

<file path="src/components/map/EmptyCityModal.js">
import React, { useState, useMemo} from 'react';
import agentsConfig from '../../gameData/agents.json';
import unitConfig from '../../gameData/units.json';
import { useGame } from '../../contexts/GameContext';
import { calculateDistance, calculateTravelTime } from '../../utils/travel';

const images = {};
const imageContexts = [
    require.context('../../images/troops', false, /\.(png|jpe?g|svg)$/),
];
imageContexts.forEach(context => {
    context.keys().forEach((item) => {
        const key = item.replace('./', '');
        images[key] = context(item);
    });
});

const EmptyCityModal = ({ plot, onClose, onFoundCity, cityGameState, playerCity }) => {
    const { worldState } = useGame();
    const [selectedAgent, setSelectedAgent] = useState('architect');
    const [selectedUnits, setSelectedUnits] = useState({ villager: 1 });

    const availableArchitects = cityGameState.agents?.architect || 0;

    const landUnits = useMemo(() => {
        return Object.keys(cityGameState.units || {})
            .filter(unitId => unitConfig[unitId]?.type === 'land' && cityGameState.units[unitId] > 0);
    }, [cityGameState.units]);

    const handleUnitChange = (unitId, value) => {
        const max = cityGameState.units[unitId] || 0;
        const amount = Math.max(0, Math.min(max, parseInt(value, 10) || 0));
        setSelectedUnits(prev => ({ ...prev, [unitId]: amount }));
    };

    const handleFoundCity = () => {
        if (availableArchitects < 1) {
            return;
        }
        if (!selectedUnits.villager || selectedUnits.villager < 1) {
            return;
        }
        onFoundCity(plot, selectedAgent, selectedUnits);
        onClose();
    };

    const totalSelectedUnits = Object.values(selectedUnits).reduce((sum, count) => sum + count, 0);
    const hasVillager = (selectedUnits.villager || 0) > 0;

    const timeInfo = useMemo(() => {
        const slowestSpeed = Object.entries(selectedUnits)
            .filter(([, count]) => count > 0)
            .map(([unitId]) => unitConfig[unitId].speed)
            .reduce((min, speed) => Math.min(min, speed), Infinity);
        
        // #comment Use cityGameState for distance calculation to ensure correct coordinates.
        const distance = calculateDistance(cityGameState, plot);
        const travelTimeSeconds = slowestSpeed === Infinity ? 0 : calculateTravelTime(distance, slowestSpeed, 'found_city', worldState, ['land']);
        
        const baseFoundingTime = 86400;
        const reductionPerVillager = 3600;
        const villagers = selectedUnits.villager || 0;
        const foundingTimeSeconds = Math.max(3600, baseFoundingTime - (villagers * reductionPerVillager));
        return { travelTimeSeconds, foundingTimeSeconds, totalTimeSeconds: travelTimeSeconds + foundingTimeSeconds };
    }, [selectedUnits, cityGameState, plot, worldState]);

    const formatDuration = (seconds) => {
        const totalSeconds = Math.round(seconds);
        const h = Math.floor(totalSeconds / 3600);
        const m = Math.floor((totalSeconds % 3600) / 60);
        const s = totalSeconds % 60;
        return `${h}h ${m}m ${s}s`;
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg border-2 border-gray-600 text-white" onClick={e => e.stopPropagation()}>
                <h3 className="font-title text-2xl text-white mb-4">Found New City</h3>
                <p>Select an agent and troops to send to found a new city on this empty plot.</p>
                <div className="my-4">
                    <label htmlFor="agent" className="block text-sm font-medium text-gray-300">Agent:</label>
                    <select
                        id="agent"
                        name="agent"
                        value={selectedAgent}
                        onChange={(e) => setSelectedAgent(e.target.value)}
                        className="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                        disabled={availableArchitects < 1}
                    >
                        {Object.keys(agentsConfig).map(agentId => (
                            <option key={agentId} value={agentId}>{agentsConfig[agentId].name} (Available: {cityGameState.agents?.[agentId] || 0})</option>
                        ))}
                    </select>
                </div>
                <div className="my-4">
                    <h4 className="text-lg font-medium text-gray-300 mb-2">Select Troops</h4>
                    <div className="max-h-60 overflow-y-auto p-2 bg-gray-900 rounded-md">
                        {landUnits.length > 0 ? (
                            landUnits.map(unitId => {
                                const unit = unitConfig[unitId];
                                const availableCount = cityGameState.units[unitId];
                                return (
                                    <div key={unitId} className="flex items-center justify-between p-2">
                                        <div className="flex items-center">
                                            <img src={images[unit.image]} alt={unit.name} className="w-10 h-10 mr-3" />
                                            <div>
                                                <p>{unit.name}</p>
                                                <p className="text-xs text-gray-400">Available: {availableCount}</p>
                                            </div>
                                        </div>
                                        <input
                                            type="number"
                                            min="0"
                                            max={availableCount}
                                            value={selectedUnits[unitId] || ''}
                                            onChange={(e) => handleUnitChange(unitId, e.target.value)}
                                            className="w-20 bg-gray-700 border border-gray-600 rounded-md p-1 text-white text-center"
                                        />
                                    </div>
                                );
                            })
                        ) : (
                            <p className="text-gray-500 text-center">No land units available in this city.</p>
                        )}
                    </div>
                     <p className="text-xs text-gray-400 mt-1">More villagers will reduce the founding time. You must send at least one villager.</p>
                </div>
                <div className="text-center my-4 p-2 bg-gray-700 rounded">
                    <p>Travel Time: <span className="font-bold text-yellow-400">{formatDuration(timeInfo.travelTimeSeconds)}</span></p>
                    <p>Founding Time: <span className="font-bold text-yellow-400">{formatDuration(timeInfo.foundingTimeSeconds)}</span></p>
                    <p className="border-t border-gray-600 mt-1 pt-1">Total Time: <span className="font-bold text-yellow-400">{formatDuration(timeInfo.totalTimeSeconds)}</span></p>
                </div>
                <div className="flex justify-end space-x-4 mt-6">
                    <button onClick={onClose} className="btn btn-secondary">Cancel</button>
                    <button
                        onClick={handleFoundCity}
                        className="btn btn-primary"
                        disabled={availableArchitects < 1 || totalSelectedUnits === 0 || !hasVillager}
                    >
                        Found City
                    </button>
                </div>
            </div>
        </div>
    );
};
export default EmptyCityModal;
</file>

<file path="src/components/map/FarmingVillageModal.js">
// src/components/map/FarmingVillageModal.js
import React, { useState, useEffect, useMemo } from 'react';
import Countdown from './Countdown';
import { db } from '../../firebase/config';
import { doc, runTransaction, serverTimestamp, onSnapshot, collection } from 'firebase/firestore';
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { useAlliance } from '../../contexts/AllianceContext';
import { resolveVillageRetaliation } from '../../utils/combat';
import resourceImage from '../../images/resources/resources.png';
import woodImage from '../../images/resources/wood.png';
import stoneImage from '../../images/resources/stone.png';
import silverImage from '../../images/resources/silver.png';

const demandOptions = [
    { name: '5 minutes', duration: 300, multiplier: 0.125, happinessCost: 0 },
    { name: '40 minutes', duration: 2400, multiplier: 1, happinessCost: 2 },
    { name: '2 hours', duration: 7200, multiplier: 3, happinessCost: 5 },
    { name: '4 hours', duration: 14400, multiplier: 4, happinessCost: 10 },
];

const FarmingVillageModal = ({ village: initialVillage, onClose, worldId, marketCapacity }) => {
    const { currentUser, userProfile } = useAuth();
    const { gameState, setGameState, countCitiesOnIsland, activeCityId } = useGame();
    const { playerAlliance } = useAlliance();
    const [village, setVillage] = useState(initialVillage);
    const [baseVillageData, setBaseVillageData] = useState(initialVillage);
    const [isProcessing, setIsProcessing] = useState(false);
    const [message, setMessage] = useState('');
    const [timeSinceCollection, setTimeSinceCollection] = useState(Infinity);
    const [activeTab, setActiveTab] = useState('demand');
    const [tradeAmount, setTradeAmount] = useState(0);
    const [plunderTimeLeft, setPlunderTimeLeft] = useState(0); // State for plunder cooldown

    const resourceImages = {
        wood: woodImage,
        stone: stoneImage,
        silver: silverImage,
    };

    useEffect(() => {
        if (!worldId || !village?.id || !currentUser) return;

        const playerVillageRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'conqueredVillages', village.id);
        const unsubscribePlayerVillage = onSnapshot(playerVillageRef, (docSnap) => {
            if (docSnap.exists()) {
                setVillage(prev => ({ ...prev, ...docSnap.data() }));
            } else {
                onClose();
            }
        });

        const baseVillageRef = doc(db, 'worlds', worldId, 'villages', village.id);
        const unsubscribeBaseVillage = onSnapshot(baseVillageRef, (docSnap) => {
            if (docSnap.exists()) {
                setBaseVillageData(docSnap.data());
            }
        });

        return () => {
            unsubscribePlayerVillage();
            unsubscribeBaseVillage();
        };
    }, [worldId, village.id, currentUser, onClose]);

    useEffect(() => {
        if (!worldId || !village?.id || !baseVillageData) return;

        const interval = setInterval(async () => {
            const villageRef = doc(db, 'worlds', worldId, 'villages', village.id);
            try {
                await runTransaction(db, async (transaction) => {
                    const villageDoc = await transaction.get(villageRef);
                    if (!villageDoc.exists()) return;
                    const villageData = villageDoc.data();
                    
                    const lastUpdated = villageData.lastUpdated?.toDate() || new Date();
                    const now = new Date();
                    const elapsedHours = (now.getTime() - lastUpdated.getTime()) / (1000 * 60 * 60);

                    if (elapsedHours > 0) {
                        const newResources = { ...(villageData.resources || {}) };
                        const productionRate = getVillageProductionRate(villageData.level);
                        const maxResources = getVillageMaxCapacity(villageData.level);
                        
                        Object.keys(productionRate).forEach(resource => {
                             newResources[resource] = Math.min(maxResources[resource], (newResources[resource] || 0) + productionRate[resource] * elapsedHours);
                        });

                        transaction.update(villageRef, { resources: newResources, lastUpdated: serverTimestamp() });
                    }
                });
            } catch (error) {
                console.error("Error updating village resources:", error);
            }
        }, 60000 * 5);
        
        return () => clearInterval(interval);
    }, [worldId, village.id, baseVillageData]);

    // This useEffect now handles happiness regeneration periodically.
    useEffect(() => {
        const happinessRegenInterval = setInterval(async () => {
            if (!worldId || !village?.id || !currentUser) return;
    
            const playerVillageRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'conqueredVillages', village.id);
    
            try {
                await runTransaction(db, async (transaction) => {
                    const villageDoc = await transaction.get(playerVillageRef);
                    if (!villageDoc.exists()) return;
    
                    const villageData = villageDoc.data();
                    if (villageData.happiness >= 100) return;
    
                    const lastUpdated = villageData.happinessLastUpdated?.toDate() || new Date();
                    const now = new Date();
                    const elapsedMinutes = (now.getTime() - lastUpdated.getTime()) / (1000 * 60);
                    
                    const happinessToRegen = elapsedMinutes * (2 / 60); // 2 happiness per hour
    
                    if (happinessToRegen > 0) {
                        const newHappiness = Math.min(100, (villageData.happiness || 0) + happinessToRegen);
                        if (newHappiness > villageData.happiness) {
                            transaction.update(playerVillageRef, {
                                happiness: newHappiness,
                                happinessLastUpdated: serverTimestamp()
                            });
                        }
                    }
                });
            } catch (error) {
                console.error("Error regenerating village happiness:", error);
            }
        }, 60000); // Run every minute
    
        return () => clearInterval(happinessRegenInterval);
    }, [worldId, village?.id, currentUser]);

    const getVillageProductionRate = (level) => ({ wood: level * 100, stone: level * 100, silver: Math.floor(level * 50) });
    const getVillageMaxCapacity = (level) => ({ wood: 1000 + (level - 1) * 500, stone: 1000 + (level - 1) * 500, silver: 1000 + (level - 1) * 500 });

    useEffect(() => {
        if (village && village.lastCollected) {
            const updateTimer = () => {
                const lastCollectedTime = village.lastCollected.toDate().getTime();
                setTimeSinceCollection(Math.floor((Date.now() - lastCollectedTime) / 1000));
            };
            updateTimer();
            const interval = setInterval(updateTimer, 1000);
            return () => clearInterval(interval);
        }
    }, [village]);

    // #comment New useEffect for plunder cooldown
    useEffect(() => {
        if (village && village.lastPlundered) {
            const updateTimer = () => {
                const lastPlunderedTime = village.lastPlundered.toDate().getTime();
                const cooldownEndTime = lastPlunderedTime + 20 * 60 * 1000; // 20 minutes
                const remaining = Math.max(0, cooldownEndTime - Date.now());
                setPlunderTimeLeft(remaining / 1000);
            };
            updateTimer();
            const interval = setInterval(updateTimer, 1000);
            return () => clearInterval(interval);
        } else {
            setPlunderTimeLeft(0);
        }
    }, [village]);

    const getUpgradeCost = (level) => ({
        wood: Math.floor(200 * Math.pow(1.6, level - 1)),
        stone: Math.floor(200 * Math.pow(1.6, level - 1)),
        silver: Math.floor(100 * Math.pow(1.8, level - 1)),
    });

    // #comment Calculate the demand yields with a memoized hook to ensure the UI updates when the bonus changes.
    const demandYields = useMemo(() => {
        const citiesOnIsland = countCitiesOnIsland(village.islandId);
        const bonusMultiplier = citiesOnIsland > 1 ? 1.20 : 1.0;
        
        let demandBoost = 1.0;
        if (playerAlliance?.research) {
            const demandBoostLevel = playerAlliance.research.diplomatic_leverage?.level || 0;
            demandBoost += demandBoostLevel * 0.03;
        }

        return demandOptions.map(option => ({
            ...option,
            yield: {
                wood: baseVillageData ? Math.floor((baseVillageData.demandYield?.wood || 0) * option.multiplier * village.level * bonusMultiplier * demandBoost) : 0,
                stone: baseVillageData ? Math.floor((baseVillageData.demandYield?.stone || 0) * option.multiplier * village.level * bonusMultiplier * demandBoost) : 0,
                silver: baseVillageData ? Math.floor((baseVillageData.demandYield?.silver || 0) * option.multiplier * village.level * bonusMultiplier * demandBoost) : 0,
            }
        }));
    }, [village.level, village.islandId, baseVillageData, countCitiesOnIsland, playerAlliance]);

    const handleDemand = async (option) => {
        if (isProcessing || !baseVillageData) return;
        setIsProcessing(true);
        setMessage('');
    
        const playerVillageRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'conqueredVillages', village.id);
        const cityDocRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'cities', activeCityId);
        
        const citiesOnIsland = countCitiesOnIsland(village.islandId);
        const hasBonus = citiesOnIsland > 1;
        const bonusMultiplier = hasBonus ? 1.20 : 1.0;
    
        try {
            const updatedCityState = await runTransaction(db, async (transaction) => {
                const playerVillageDoc = await transaction.get(playerVillageRef);
                const cityDoc = await transaction.get(cityDocRef);
                if (!playerVillageDoc.exists() || !cityDoc.exists()) throw new Error("Your village or active city state not found.");
    
                const villageData = playerVillageDoc.data();
                const cityData = cityDoc.data();
                if (Date.now() < (villageData.lastCollected?.toDate().getTime() || 0) + option.duration * 1000) {
                    throw new Error('Not enough time has passed for this demand option.');
                }
    
                const newResources = { ...cityData.resources };
                const warehouseCapacity = Math.floor(1500 * Math.pow(1.4, cityData.buildings.warehouse.level - 1));
                
                const yieldAmount = {
                    wood: Math.floor((baseVillageData.demandYield.wood || 0) * option.multiplier * villageData.level * bonusMultiplier),
                    stone: Math.floor((baseVillageData.demandYield.stone || 0) * option.multiplier * villageData.level * bonusMultiplier),
                    silver: Math.floor((baseVillageData.demandYield.silver || 0) * option.multiplier * villageData.level * bonusMultiplier),
                };
    
                for (const [resource, amount] of Object.entries(yieldAmount)) {
                    newResources[resource] = Math.min(warehouseCapacity, (newResources[resource] || 0) + amount);
                }
    
                const happinessCost = option.happinessCost || 0;
                const newHappiness = Math.max(0, (villageData.happiness || 100) - happinessCost);
    
                transaction.update(cityDocRef, { resources: newResources });
                transaction.update(playerVillageRef, { 
                    lastCollected: serverTimestamp(),
                    happiness: newHappiness,
                    happinessLastUpdated: serverTimestamp()
                });
                return { ...cityData, resources: newResources };
            });
    
            setGameState(updatedCityState);
            
            let successMessage = "Successfully demanded resources! Village happiness decreased.";
            if (hasBonus) {
                successMessage += ` (+20% bonus for multiple cities on this island!)`;
            }
            setMessage(successMessage);
        } catch (error) {
            setMessage(`Failed to demand resources: ${error.message}`);
        } finally {
            setIsProcessing(false);
        }
    };

    const handlePlunder = async () => {
        if (isProcessing) return;
        if (plunderTimeLeft > 0) {
            setMessage(`You must wait before plundering again.`);
            return;
        }
        setIsProcessing(true);
        setMessage('');

        const playerVillageRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'conqueredVillages', village.id);
        const cityDocRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'cities', activeCityId);
        const baseVillageRef = doc(db, 'worlds', worldId, 'villages', village.id);
        const reportsRef = collection(db, 'users', currentUser.uid, 'worlds', worldId, 'reports');

        try {
            const newGameState = await runTransaction(db, async (transaction) => {
                const playerVillageDoc = await transaction.get(playerVillageRef);
                const cityDoc = await transaction.get(cityDocRef);
                const baseVillageDoc = await transaction.get(baseVillageRef);
                if (!playerVillageDoc.exists() || !cityDoc.exists() || !baseVillageDoc.exists()) throw new Error("Required data not found.");

                const villageData = playerVillageDoc.data();
                const cityData = cityDoc.data();
                const baseData = baseVillageDoc.data();
                const currentHappiness = villageData.happiness !== undefined ? villageData.happiness : 100;
                
                // Plunder always yields resources, regardless of revolt outcome
                const plunderAmount = { wood: Math.floor((baseData.resources.wood || 0) * 0.5), stone: Math.floor((baseData.resources.stone || 0) * 0.5), silver: Math.floor((baseData.resources.silver || 0) * 0.5) };
                const newPlayerResources = { ...cityData.resources };
                const newVillageResources = { ...baseData.resources };
                const warehouseCapacity = Math.floor(1500 * Math.pow(1.4, cityData.buildings.warehouse.level - 1));

                for(const res in plunderAmount) {
                    newPlayerResources[res] = Math.min(warehouseCapacity, newPlayerResources[res] + plunderAmount[res]);
                    newVillageResources[res] -= plunderAmount[res];
                }
                
                transaction.update(cityDocRef, { resources: newPlayerResources });
                transaction.update(baseVillageRef, { resources: newVillageResources });

                // Check for revolt: guaranteed if happiness is low
                if (currentHappiness <= 40) {
                    const retaliationLosses = resolveVillageRetaliation(cityData.units);
                    const newUnits = { ...cityData.units };
                    for(const unitId in retaliationLosses) newUnits[unitId] -= retaliationLosses[unitId];
                    
                    transaction.update(cityDocRef, { units: newUnits });
                    transaction.delete(playerVillageRef);

                    const report = { 
                        type: 'attack_village', 
                        title: `Revolt at ${baseData.name}!`, 
                        timestamp: serverTimestamp(), 
                        outcome: { attackerWon: false, message: `Your plunder attempt on a low-happiness village caused a revolt! You have lost control and suffered casualties, but secured the resources.`, plunder: plunderAmount }, 
                        attacker: { 
                            cityId: activeCityId,
                            cityName: cityData.cityName, 
                            ownerId: currentUser.uid,
                            username: userProfile.username,
                            x: cityData.x,
                            y: cityData.y,
                            units: {}, 
                            losses: retaliationLosses 
                        }, 
                        defender: { 
                            villageName: baseData.name,
                            x: baseData.x,
                            y: baseData.y
                        }, 
                        read: false 
                    };
                    transaction.set(doc(reportsRef), report);
                    return { ...cityData, units: newUnits, resources: newPlayerResources };
                } else {
                    // Successful plunder, no revolt
                    const newHappiness = Math.max(0, currentHappiness - 40);
                    transaction.update(playerVillageRef, { 
                        happiness: newHappiness, 
                        happinessLastUpdated: serverTimestamp(),
                        lastPlundered: serverTimestamp() // Set plunder cooldown
                    });
                    
                    const report = { 
                        type: 'attack_village', 
                        title: `Plunder of ${baseData.name} successful!`, 
                        timestamp: serverTimestamp(), 
                        outcome: { attackerWon: true, plunder: plunderAmount }, 
                        attacker: { 
                            cityId: activeCityId,
                            cityName: cityData.cityName,
                            ownerId: currentUser.uid,
                            username: userProfile.username,
                            x: cityData.x,
                            y: cityData.y
                        }, 
                        defender: { 
                            villageName: baseData.name,
                            x: baseData.x,
                            y: baseData.y
                        }, 
                        read: false 
                    };
                    transaction.set(doc(reportsRef), report);
                    return { ...cityData, resources: newPlayerResources };
                }
            });
            setGameState(newGameState);
            setMessage("Plunder successful! Resources have been seized.");
        } catch (error) {
            setMessage(`Plunder failed: ${error.message}`);
        } finally {
            setIsProcessing(false);
        }
    };
    
    const handleUpgrade = async () => {
        if (isProcessing) return;
        setIsProcessing(true);
        setMessage('');

        const playerVillageRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'conqueredVillages', village.id);
        const cityDocRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'cities', activeCityId);
        const nextLevel = village.level + 1;
        const cost = getUpgradeCost(nextLevel);

        try {
            const newGameState = await runTransaction(db, async (transaction) => {
                const playerVillageDoc = await transaction.get(playerVillageRef);
                const cityDoc = await transaction.get(cityDocRef);
                if (!playerVillageDoc.exists() || !cityDoc.exists()) throw new Error("Your village or city state could not be found.");

                const cityData = cityDoc.data();
                if (cityData.resources.wood < cost.wood || cityData.resources.stone < cost.stone || cityData.resources.silver < cost.silver) {
                    throw new Error("Not enough resources in your city to upgrade the village.");
                }

                const newResources = { wood: cityData.resources.wood - cost.wood, stone: cityData.resources.stone - cost.stone, silver: cityData.resources.silver - cost.silver };
                transaction.update(cityDocRef, { resources: newResources });
                transaction.update(playerVillageRef, { level: nextLevel });
                return { ...cityData, resources: newResources };
            });

            setGameState(newGameState);
            setMessage(`Successfully upgraded village to level ${nextLevel}!`);
        } catch (error) {
            console.error("Error upgrading village: ", error);
            setMessage(`Failed to upgrade village: ${error.message}`);
        } finally {
            setIsProcessing(false);
        }
    };

    const handleTrade = async () => {
        if (isProcessing || !baseVillageData || tradeAmount <= 0) return;
        if (tradeAmount > marketCapacity) {
            setMessage(`Trade amount cannot exceed your market capacity of ${marketCapacity}.`);
            return;
        }
        setIsProcessing(true);
        setMessage('');
    
        const cityDocRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'cities', activeCityId);
        const villageRef = doc(db, 'worlds', worldId, 'villages', village.id);
    
        try {
            const newGameState = await runTransaction(db, async (transaction) => {
                const cityDoc = await transaction.get(cityDocRef);
                const villageDoc = await transaction.get(villageRef);
                if (!cityDoc.exists() || !villageDoc.exists()) throw new Error("Game state or village data not found.");
    
                const cityData = cityDoc.data();
                const villageData = villageDoc.data();
                const resourceToGive = villageData.demands;
                const resourceToGet = villageData.supplies;
                const amountToGet = Math.floor(tradeAmount / villageData.tradeRatio);
    
                if (cityData.resources[resourceToGive] < tradeAmount) throw new Error(`Not enough ${resourceToGive} to trade.`);
                if (villageData.resources[resourceToGet] < amountToGet) throw new Error(`The village does not have enough ${resourceToGet} to trade.`);
    
                const newPlayerResources = { ...cityData.resources };
                newPlayerResources[resourceToGive] -= tradeAmount;
                newPlayerResources[resourceToGet] += amountToGet;
    
                const newVillageResources = { ...villageData.resources };
                newVillageResources[resourceToGive] += tradeAmount;
                newVillageResources[resourceToGet] -= amountToGet;
    
                transaction.update(cityDocRef, { resources: newPlayerResources });
                transaction.update(villageRef, { resources: newVillageResources });
                return { ...cityData, resources: newPlayerResources };
            });
            
            setGameState(newGameState);
            setMessage(`Successfully traded ${tradeAmount} ${baseVillageData.demands} for ${Math.floor(tradeAmount / baseVillageData.tradeRatio)} ${baseVillageData.supplies}.`);
            setTradeAmount(0);
        } catch (error) {
            setMessage(`Trade failed: ${error.message}`);
        } finally {
            setIsProcessing(false);
        }
    };

    const cost = getUpgradeCost(village.level + 1);
    const canAffordUpgrade = gameState && gameState.resources.wood >= cost.wood && gameState.resources.stone >= cost.stone && gameState.resources.silver >= cost.silver;
    const maxTradeAmount = baseVillageData && gameState ? Math.min(gameState.resources[baseVillageData.demands] || 0, Math.floor((baseVillageData.resources?.[baseVillageData.supplies] || 0) * (baseVillageData.tradeRatio || 1)), marketCapacity || 0) : 0;
    const plunderCooldownEndTime = village.lastPlundered ? new Date(village.lastPlundered.toDate().getTime() + 20 * 60 * 1000) : null;
    
    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center pointer-events-none" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-4xl text-center border border-gray-600 pointer-events-auto" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center">
                    <h2 className="text-2xl font-bold text-yellow-400">{`Farming Village: ${baseVillageData?.name || village.name} (Level ${village.level})`}</h2>
                    <h3 className="text-xl font-semibold text-white">Happiness: <span className="text-green-400">{Math.floor(village.happiness !== undefined ? village.happiness : 100)}%</span></h3>
                </div>
                <div className="flex border-b border-gray-600 my-4">
                    <button onClick={() => setActiveTab('demand')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'demand' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Demand</button>
                    <button onClick={() => setActiveTab('plunder')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'plunder' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Plunder</button>
                    <button onClick={() => setActiveTab('trade')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'trade' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Trade</button>
                    <button onClick={() => setActiveTab('upgrade')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'upgrade' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Upgrade</button>
                </div>
                <div className="p-4 text-white">
                    {activeTab === 'demand' && (
                        <div>
                            <h4 className="font-bold text-lg text-center mb-2">Demand Resources</h4>
                            <p className="text-center text-gray-400 text-sm mb-4">Choose an option to demand resources. Shorter times yield fewer resources.</p>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                {demandYields.map(option => {
                                    const isAvailable = timeSinceCollection >= option.duration;
                                    return (
                                        <div key={option.name} className="bg-gray-900 border border-gray-700 p-2 rounded-lg text-center flex flex-col justify-between shadow-md">
                                            <div className="relative h-16 mb-2 flex justify-center items-center">
                                                <img src={resourceImage} alt="resources" className="w-16 h-16"/>
                                            </div>
                                            <div className="text-xs space-y-1 mb-2 text-left">
                                                <p className="flex justify-between px-1"><span>Wood:</span> <span className="font-bold text-yellow-300">{option.yield.wood}</span></p>
                                                <p className="flex justify-between px-1"><span>Stone:</span> <span className="font-bold text-gray-300">{option.yield.stone}</span></p>
                                                <p className="flex justify-between px-1"><span>Silver:</span> <span className="font-bold text-blue-300">{option.yield.silver}</span></p>
                                            </div>
                                            <div className="mt-auto">
                                                {isAvailable ? (
                                                    <button onClick={() => handleDemand(option)} disabled={isProcessing} className="btn btn-confirm w-full text-sm py-1">Demand ({option.name})</button>
                                                ) : (
                                                    <div className="text-center text-sm py-1 px-2 bg-gray-800 rounded">
                                                        <div className="font-mono text-red-400">
                                                            <Countdown arrivalTime={{ toDate: () => new Date(village.lastCollected.toDate().getTime() + option.duration * 1000) }} />
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    )
                                })}
                            </div>
                        </div>
                    )}
                    {activeTab === 'plunder' && (
                        <div>
                            <h4 className="font-bold text-lg text-center mb-2 text-red-400">Plunder Village</h4>
                            <p className="text-center text-gray-400 text-sm mb-4">Forcefully take resources from the village. This action is much faster and yields more than demanding, but it will significantly lower happiness and risks a revolt.</p>
                            <div className="bg-gray-900 p-4 rounded-lg">
                                <p className="mb-2">Current Happiness: <span className="font-bold text-green-400">{Math.floor(village.happiness !== undefined ? village.happiness : 100)}%</span></p>
                                <p className="text-xs text-gray-500 mb-4">Plundering a village with 40% or less happiness will cause it to revolt, and you will lose control of it.</p>
                                <button onClick={handlePlunder} disabled={isProcessing || plunderTimeLeft > 0} className="btn btn-danger w-full text-lg py-2">
                                    {isProcessing ? 'Plundering...' : (plunderTimeLeft > 0 ? 
                                        <Countdown arrivalTime={plunderCooldownEndTime} /> 
                                        : 'Launch Plunder Raid (-40 Happiness)')}
                                </button>
                            </div>
                        </div>
                    )}
                    {activeTab === 'trade' && (
                         <div>
                            <h4 className="font-bold text-lg text-center mb-2">Trade with Village</h4>
                            {baseVillageData ? (
                                <>
                                    <div className="flex justify-center items-center space-x-4 my-4">
                                        <div className="flex flex-col items-center"><span className="text-sm text-gray-400 capitalize">You Give</span><img src={resourceImages[baseVillageData.demands]} alt={baseVillageData.demands} className="w-12 h-12" /></div>
                                        <span className="text-3xl text-gray-400 font-bold">&rarr;</span>
                                        <div className="flex flex-col items-center"><span className="text-sm text-gray-400 capitalize">You Receive</span><img src={resourceImages[baseVillageData.supplies]} alt={baseVillageData.supplies} className="w-12 h-12" /></div>
                                    </div>
                                    <p className="text-center text-gray-400 text-sm mb-4">Trade Ratio: {baseVillageData.tradeRatio}:1 | Your Market Capacity: {marketCapacity}<span className="block mt-2 text-xs text-red-400 italic">(Trade amount is also limited by the village's current supplies)</span></p>
                                    <div className="bg-gray-700 p-4 rounded-lg">
                                        <div className="flex justify-between items-center mb-2"><span className="capitalize">Your {baseVillageData.demands}: {Math.floor(gameState.resources[baseVillageData.demands] || 0)}</span><span className="capitalize">Village's {baseVillageData.supplies}: {Math.floor(baseVillageData.resources?.[baseVillageData.supplies] || 0)}</span></div>
                                        <input type="range" min="0" max={maxTradeAmount || 0} value={tradeAmount} onChange={(e) => setTradeAmount(Number(e.target.value))} className="w-full"/>
                                        <div className="flex justify-between items-center mt-2"><span className="capitalize">You give: <span className="font-bold text-red-400">{tradeAmount} {baseVillageData.demands}</span></span><span className="capitalize">You receive: <span className="font-bold text-green-400">{Math.floor(tradeAmount / (baseVillageData.tradeRatio || 1))} {baseVillageData.supplies}</span></span></div>
                                        <button onClick={handleTrade} disabled={isProcessing || tradeAmount <= 0 || maxTradeAmount <= 0} className="btn btn-confirm w-full mt-4 py-2">Trade</button>
                                    </div>
                                </>
                            ) : (<p className="text-center text-gray-400 p-8">Loading trade information...</p>)}
                        </div>
                    )}
                     {activeTab === 'upgrade' && (
                        <div>
                           <p className="mb-4 text-center">Invest resources to upgrade this village for better yields.</p>
                            <div className="bg-gray-700 p-3 rounded-lg mb-4">
                                <h4 className="font-bold text-lg">Cost to Upgrade to Level {village.level + 1}:</h4>
                                <div className="flex justify-center items-center space-x-4 mt-2 text-yellow-300">
                                    <div className="flex items-center gap-1">
                                        <img src={woodImage} alt="Wood" className="w-6 h-6" />
                                        <span>{cost.wood}</span>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <img src={stoneImage} alt="Stone" className="w-6 h-6" />
                                        <span>{cost.stone}</span>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <img src={silverImage} alt="Silver" className="w-6 h-6" />
                                        <span>{cost.silver}</span>
                                    </div>
                                </div>
                            </div>
                            <button onClick={handleUpgrade} disabled={isProcessing || !canAffordUpgrade} className="btn btn-primary py-3 px-4 w-40">{isProcessing ? 'Processing...' : 'Upgrade Village'}</button>
                        </div>
                    )}
                    {message && <p className="text-green-400 mt-4 text-center">{message}</p>}
                </div>
                 <button onClick={onClose} className="btn btn-primary px-6 py-2 mt-4">Close</button>
            </div>
        </div>
    );
};

export default FarmingVillageModal;
</file>

<file path="src/components/map/GodTownModal.js">
// src/components/map/GodTownModal.js
import React, { useState, useEffect } from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { db } from '../../firebase/config';
import { doc, updateDoc, setDoc, onSnapshot } from 'firebase/firestore';
import PuzzleRenderer from '../puzzles/PuzzleRenderer';
import Countdown from './Countdown';
import TroopDisplay from '../TroopDisplay'; // Import TroopDisplay

const GodTownModal = ({ townId, onClose, onAttack }) => {
    const { currentUser } = useAuth();
    const { worldId } = useGame();
    const [townData, setTownData] = useState(null);
    const [playerProgress, setPlayerProgress] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        if (!worldId || !townId || !currentUser) {
            setLoading(false);
            return;
        }

        // #comment Use onSnapshot for real-time updates for town data
        const townRef = doc(db, 'worlds', worldId, 'godTowns', townId);
        const unsubscribeTown = onSnapshot(townRef, (townSnap) => {
            if (townSnap.exists()) {
                setTownData({ id: townSnap.id, ...townSnap.data() });
            } else {
                onClose(); // Close if the town disappears
            }
        });

        // #comment Use onSnapshot for real-time updates for player progress
        const playerProgressRef = doc(db, 'worlds', worldId, 'godTowns', townId, 'playerProgress', currentUser.uid);
        const unsubscribeProgress = onSnapshot(playerProgressRef, async (progressSnap) => {
            if (progressSnap.exists()) {
                setPlayerProgress(progressSnap.data());
            } else {
                // If progress doc doesn't exist, create it.
                const newProgress = { puzzleSolved: false, damageDealt: 0 };
                try {
                    await setDoc(playerProgressRef, newProgress);
                    setPlayerProgress(newProgress);
                } catch (error) {
                    console.error("Failed to create player progress doc:", error);
                }
            }
        });

        return () => {
            unsubscribeTown();
            unsubscribeProgress();
        };
    }, [worldId, townId, currentUser, onClose]);

    // #comment Determine loading state based on whether data has arrived.
    useEffect(() => {
        if (townData !== null && playerProgress !== null) {
            setLoading(false);
        }
    }, [townData, playerProgress]);


    const handlePuzzleSuccess = async () => {
        if (!worldId || !townId || !currentUser) return;
        const playerProgressRef = doc(db, 'worlds', worldId, 'godTowns', townId, 'playerProgress', currentUser.uid);
        await updateDoc(playerProgressRef, { puzzleSolved: true });
        setPlayerProgress(prev => ({ ...prev, puzzleSolved: true }));
    };

    if (loading) {
        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70">
                <div className="bg-gray-800 p-6 rounded-lg text-white">Loading...</div>
            </div>
        );
    }

    if (!townData) {
        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
                <div className="bg-gray-800 p-6 rounded-lg text-white" onClick={e => e.stopPropagation()}>
                    <p>Could not load God Town information.</p>
                    <button onClick={onClose} className="btn btn-primary mt-4">Close</button>
                </div>
            </div>
        );
    }

    const renderContent = () => {
        if (townData.stage === 'ruins') {
            return (
                <div>
                    <h3 className="font-title text-2xl">Strange Ruins</h3>
                    <p>These ancient ruins hum with a mysterious power. It seems they are slowly reforming into something grander.</p>
                    <p className="mt-4">Time until transformation: 
                        <span className="font-bold text-yellow-400 ml-2">
                            <Countdown arrivalTime={townData.transformationTime} />
                        </span>
                    </p>
                </div>
            );
        }

        if (townData.stage === 'city') {
            if (!playerProgress?.puzzleSolved) {
                return (
                    <div>
                        <h3 className="font-title text-2xl">The God Town's Challenge</h3>
                        <p>To prove your worthiness to attack, you must first solve a riddle posed by the town's ancient guardians.</p>
                        <PuzzleRenderer puzzleId={townData.puzzleId} onSolve={handlePuzzleSuccess} />
                    </div>
                );
            }
            return (
                <div>
                    <h3 className="font-title text-2xl">{townData.name}</h3>
                    <p>The city is vulnerable. Attack to earn war points and resources!</p>
                    <div className="my-4">
                        <TroopDisplay units={townData.troops || {}} title="Garrison" />
                    </div>
                    <button onClick={() => onAttack(townData)} className="btn btn-danger mt-4">Attack</button>
                </div>
            );
        }

        return <p>The God Town has been conquered and has settled on a new island!</p>;
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="other-city-modal-container" onClick={e => e.stopPropagation()}>
                <div className="other-city-modal-header">
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="other-city-modal-content">
                    {renderContent()}
                </div>
            </div>
        </div>
    );
};

export default GodTownModal;
</file>

<file path="src/components/map/MapGrid.js">
// src/components/map/MapGrid.js
import React, { useMemo } from 'react';
import { WaterTile, LandTile, CitySlotTile, FarmingVillageTile, RuinTile, GodTownTile, WonderSpotTile, ConstructingWonderTile } from './Tiles';
import MovementIndicator from './MovementIndicator';
import { useGame } from '../../contexts/GameContext';

const TILE_SIZE = 32;
const defaultSettings = { animations: true, showVisuals: true, showGrid: true };

const MapGrid = ({ mapGrid, worldState, pan, zoom, viewportSize, onCitySlotClick, onVillageClick, onRuinClick, onGodTownClick, onWonderSpotClick, onConstructingWonderClick, isPlacingDummyCity, movements, combinedSlots, villages, ruins, godTowns, playerAlliance, conqueredVillages, gameSettings = defaultSettings, cityPoints, scoutedCities, controlledIslands }) => {
    const { playerCities } = useGame();

    const locationLookup = useMemo(() => {
        const lookup = {};
        Object.values({...combinedSlots, ...villages, ...ruins, ...godTowns}).forEach(loc => {
            if (loc && loc.id) lookup[loc.id] = loc;
        });
        Object.values(playerCities || {}).forEach(city => {
            if (city && city.id) lookup[city.id] = city;
        });
        return lookup;
    }, [combinedSlots, villages, ruins, godTowns, playerCities]);

    if (!mapGrid || !worldState?.islands || viewportSize.width === 0) return null;

    const scaledTileSize = TILE_SIZE * zoom;
    const startCol = Math.max(0, Math.floor(-pan.x / scaledTileSize));
    const endCol = Math.min(worldState.width, Math.ceil((-pan.x + viewportSize.width) / scaledTileSize));
    const startRow = Math.max(0, Math.floor(-pan.y / scaledTileSize));
    const endRow = Math.min(worldState.height, Math.ceil((-pan.y + viewportSize.height) / scaledTileSize));

    const visibleTiles = [];

    for (let y = startRow; y < endRow; y++) {
        for (let x = startCol; x < endCol; x++) {
            const tile = mapGrid[y][x];
            let tileContent;
            switch (tile.type) {
                case 'city_slot':
                    const island = worldState.islands.find(isl => isl.id === tile.data.islandId);
                    tileContent = <CitySlotTile slotData={tile.data} onClick={onCitySlotClick} isPlacingDummyCity={isPlacingDummyCity} playerAlliance={playerAlliance} gameSettings={gameSettings} cityPoints={cityPoints} scoutedCities={scoutedCities} islandCenterX={island ? island.x : 0} />;
                    break;
                case 'village':
                    tileContent = <FarmingVillageTile villageData={tile.data} onClick={onVillageClick} conqueredVillages={conqueredVillages} gameSettings={gameSettings} />;
                    break;
                case 'ruin':
                    tileContent = <RuinTile ruinData={tile.data} onClick={onRuinClick} gameSettings={gameSettings} />;
                    break;
                case 'god_town':
                    tileContent = <GodTownTile townData={tile.data} onClick={onGodTownClick} gameSettings={gameSettings} />;
                    break;
                case 'wonder_spot':
                    // #comment Pass controlledIslands and playerAlliance to the WonderSpotTile
                    tileContent = <WonderSpotTile spotData={tile.data} onClick={onWonderSpotClick} playerAlliance={playerAlliance} controlledIslands={controlledIslands} />;
                    break;
                case 'constructing_wonder':
                    tileContent = <ConstructingWonderTile wonderData={tile.data} onClick={onConstructingWonderClick} />;
                    break;
                case 'land':
                    tileContent = <LandTile tileData={tile.data} gameSettings={gameSettings} />;
                    break;
                default:
                    tileContent = <WaterTile gameSettings={gameSettings} />;
                    break;
            }
            visibleTiles.push(
                <div
                    key={`tile-${x}-${y}`}
                    className="map-tile"
                    style={{ position: 'absolute', left: x * TILE_SIZE, top: y * TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE }}
                >
                    {tileContent}
                </div>
            );
        }
    }

    if (gameSettings.animations) {
        movements.forEach(movement => {
            visibleTiles.push(
                <MovementIndicator
                    key={`movement-${movement.id}`}
                    movement={movement}
                    citySlots={locationLookup}
                    allMovements={movements}
                />
            );
        });
    }

    return <>{visibleTiles}</>;
};

export default MapGrid;
</file>

<file path="src/components/map/MapModals.js">
import React from 'react';
import RadialMenu from './RadialMenu';
import OtherCityModal from './OtherCityModal';
import FarmingVillageModal from './FarmingVillageModal';
import MovementModal from './MovementModal';
import MovementsPanel from './MovementsPanel';
import ReinforcementModal from '../city/ReinforcementModal';
import { useAuth } from '../../contexts/AuthContext';
import EmptyCityModal from './EmptyCityModal';

const MapModals = ({
    modalState,
    closeModal,
    gameState,
    playerCity,
    travelTimeInfo,
    handleSendMovement,
    handleCancelMovement,
    setMessage,
    goToCoordinates,
    handleActionClick,
    worldId,
    movements,
    combinedSlots,
    villages,
    handleRushMovement,
    userProfile,
    onCastSpell,
    onActionClick,
    marketCapacity,
    onEnterCity,
    onSwitchCity,
    onWithdraw,
    onFoundCity,
}) => {
    const { currentUser } = useAuth();
    const { selectedCity } = modalState;

    const renderCityInteraction = () => {
        if (!selectedCity) return null;

        if (selectedCity.isRuinTarget || selectedCity.isVillageTarget) {
            return (
                <OtherCityModal
                    city={selectedCity}
                    playerCity={playerCity}
                    travelTimeInfo={travelTimeInfo}
                    onSendMovement={handleSendMovement}
                    onClose={() => closeModal('city')}
                    onAction={handleActionClick}
                    onGoTo={goToCoordinates}
                    gameState={gameState}
                    onCastSpell={onCastSpell}
                    isVillageTarget={selectedCity.isVillageTarget}
                />
            );
        }

        const isOwn = selectedCity.ownerId === currentUser.uid;
        const isActive = gameState?.id === selectedCity.id;
        const hasReinforcements = selectedCity.reinforcements && Object.keys(selectedCity.reinforcements).length > 0;

        let allActions = [];
        if (isOwn) {
            if (isActive) {
                allActions = [
                    { label: 'Enter City', icon: '🏛️', handler: () => onEnterCity(selectedCity.id) },
                    { label: 'Center on Map', icon: '📍', handler: () => goToCoordinates(selectedCity.x, selectedCity.y) },
                ];
                if (hasReinforcements) {
                    allActions.push({ label: 'Withdraw Troops', icon: '🛡️', handler: () => onWithdraw(selectedCity) });
                }
            } else {
                allActions = [
                    { label: 'Enter City', icon: '🏛️', handler: () => onEnterCity(selectedCity.id) },
                    { label: 'Select City', icon: '✅', handler: () => onSwitchCity(selectedCity.id) },
                    { label: 'Reinforce', icon: '🛡️', handler: () => handleActionClick('reinforce', selectedCity) },
                    { label: 'Trade', icon: '⚖️', handler: () => handleActionClick('trade', selectedCity) },
                    ...(hasReinforcements ? [{ label: 'Withdraw Troops', icon: '🛡️', handler: () => onWithdraw(selectedCity) }] : []),
                    { label: 'Center on Map', icon: '📍', handler: () => goToCoordinates(selectedCity.x, selectedCity.y) },
                ];
            }
        } else {
            allActions = [
                { label: 'Attack', icon: '⚔️', handler: () => handleActionClick('attack', selectedCity) },
                { label: 'Reinforce', icon: '🛡️', handler: () => handleActionClick('reinforce', selectedCity) },
                { label: 'Scout', icon: '👁️', handler: () => handleActionClick('scout', selectedCity) },
                { label: 'Trade', icon: '⚖️', handler: () => handleActionClick('trade', selectedCity) },
                // #comment Corrected this handler to use handleActionClick
                { label: 'Cast Spell', icon: '✨', handler: () => handleActionClick('castSpell', selectedCity) },
                { label: 'Profile', icon: '👤', handler: () => handleActionClick('profile', selectedCity) },
            ];
        }

        const centerAction = allActions.find(a => a.label === 'Select City');
        const radialActions = allActions.filter(a => a.label !== 'Select City');

        return (
            <RadialMenu
                actions={radialActions}
                centerAction={centerAction}
                position={selectedCity.position}
                onClose={() => closeModal('city')}
            />
        );
    };

    return (
        <>
            {renderCityInteraction()}
            {modalState.selectedVillage && (
                <FarmingVillageModal
                    village={modalState.selectedVillage}
                    onClose={() => closeModal('village')}
                    onActionClick={handleActionClick}
                    playerCity={playerCity}
                    worldId={worldId}
                    marketCapacity={marketCapacity}
                />
            )}
            {modalState.actionDetails && (
                <MovementModal
                    mode={modalState.actionDetails.mode}
                    targetCity={modalState.actionDetails.city}
                    onClose={() => closeModal('action')}
                    onSend={handleSendMovement}
                    playerCity={playerCity}
                    gameState={gameState}
                    travelTimeInfo={travelTimeInfo}
                    setMessage={setMessage}
                />
            )}
            {modalState.isMovementsPanelOpen && (
                <MovementsPanel
                    movements={movements}
                    onClose={() => closeModal('movements')}
                    combinedSlots={combinedSlots}
                    villages={villages}
                    goToCoordinates={goToCoordinates}
                    onCancel={handleCancelMovement}
                    onRush={handleRushMovement}
                    isAdmin={userProfile?.is_admin}
                />
            )}
            {modalState.isReinforcementsModalOpen && (
                <ReinforcementModal
                    city={modalState.reinforcementsModalData}
                    onClose={() => closeModal('reinforcements')}
                    onOpenWithdraw={onWithdraw}
                />
            )}
            {modalState.isEmptyCityModalOpen && (
                <EmptyCityModal
                    plot={modalState.emptyCityModalData}
                    onClose={() => closeModal('emptyCity')}
                    onFoundCity={onFoundCity}
                    cityGameState={gameState}
                />
            )}
        </>
    );
};

export default MapModals;
</file>

<file path="src/components/map/MapOverlay.css">
/* src/components/map/MapOverlay.css */
.minimap-container {
    position: absolute;
    top: 40px; /* Position below the top bar */
    left: 0,5rem;
    z-index: 40;
    pointer-events: all; /* Allow interaction with the canvas if needed in future */
}

.coords-info-container {
    position: absolute;
    top: 223px; /* Position below the minimap */
    left: 1.1rem;
    z-index: 40;
    background-color: rgba(245, 222, 179, 0.8);
    border: 2px solid #8B4513;
    padding: 0.1rem 0.5rem;
    border-radius: 6px;
    color: #4a2c2a;
    font-weight: bold;
    font-size: 0.75rem; /* Made font smaller */
    text-align: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.4);
    pointer-events: none;
    width: 150px; /* Match minimap width for alignment */
}

.minimap-canvas {
    border: 3px solid #8B4513;
    box-shadow: 0 4px 8px rgba(0,0,0,0.5);
    background-color: #1e3a8a; /* Water color fallback */
    border-radius: 50%; /* Make the minimap circular */
    overflow: hidden; /* Ensure content stays within the circle */
}
</file>

<file path="src/components/map/MapOverlay.js">
// src/components/map/MapOverlay.js
import React, { useRef, useEffect } from 'react';
import { useAuth } from '../../contexts/AuthContext';

const MINIMAP_SIZE = 175; // The size of the minimap canvas in pixels

const MapOverlay = ({ mouseCoords, pan, zoom, viewportSize, worldState, allCities, ruins, playerAlliance }) => {
    const minimapRef = useRef(null);
    const { currentUser } = useAuth();

    // #comment Calculate the sea name based on the center of the viewport
    const seaName = (() => {
        if (!viewportSize.width || !worldState) return 'Unknown Sea';
        const centerX = (-pan.x + viewportSize.width / 2) / (32 * zoom);
        const centerY = (-pan.y + viewportSize.height / 2) / (32 * zoom);
        const seaX = Math.floor(centerX / 100);
        const seaY = Math.floor(centerY / 100);
        return `Sea ${seaY}${seaX}`;
    })();

    // #comment Draw the minimap
    useEffect(() => {
        const canvas = minimapRef.current;
        if (!canvas || !worldState || !viewportSize.width || !currentUser) return;

        const ctx = canvas.getContext('2d');
        const { width: worldWidth, height: worldHeight, islands } = worldState;
        
        const scaleX = MINIMAP_SIZE / worldWidth;
        const scaleY = MINIMAP_SIZE / worldHeight;

        // Clear and draw background
        ctx.fillStyle = '#1e3a8a'; // Water color
        ctx.fillRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);

        // Draw islands
        ctx.fillStyle = '#2a623d'; // Land color
        islands.forEach(island => {
            ctx.beginPath();
            ctx.arc(
                island.x * scaleX,
                island.y * scaleY,
                island.radius * Math.min(scaleX, scaleY),
                0,
                2 * Math.PI
            );
            ctx.fill();
        });

        // #comment Draw ruins
        if (ruins) {
            ctx.fillStyle = '#a855f7'; // Purple for ruins
            Object.values(ruins).forEach(ruin => {
                ctx.fillRect(ruin.x * scaleX - 1, ruin.y * scaleY - 1, 3, 3);
            });
        }

        // #comment Draw all cities with appropriate colors
        if (allCities) {
            Object.values(allCities).forEach(city => {
                if (!city.ownerId) return; // Skip empty slots

                let cityColor = '#f59e0b'; // Neutral - amber-500

                if (city.ownerId === currentUser.uid) {
                    cityColor = '#facc15'; // My City - yellow-400
                } else if (playerAlliance && city.alliance) {
                    if (city.alliance === playerAlliance.tag) {
                        cityColor = '#3b82f6'; // Alliance - blue-500
                    } else if (playerAlliance.diplomacy?.allies?.some(a => a.tag === city.alliance)) {
                        cityColor = '#22c55e'; // Ally - green-500
                    } else if (playerAlliance.diplomacy?.enemies?.some(e => e.tag === city.alliance)) {
                        cityColor = '#ef4444'; // Enemy - red-500
                    }
                }
                
                ctx.fillStyle = cityColor;
                ctx.fillRect(city.x * scaleX - 1, city.y * scaleY - 1, 3, 3);
            });
        }
        
        // Draw viewport rectangle
        const viewRectX = -pan.x / (32 * zoom) * scaleX;
        const viewRectY = -pan.y / (32 * zoom) * scaleY;
        const viewRectWidth = (viewportSize.width / (32 * zoom)) * scaleX;
        const viewRectHeight = (viewportSize.height / (32 * zoom)) * scaleY;

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.strokeRect(viewRectX, viewRectY, viewRectWidth, viewRectHeight);

    }, [worldState, allCities, ruins, playerAlliance, pan, zoom, viewportSize, currentUser]);


    return (
        <>
            <div className="minimap-container">
                <canvas ref={minimapRef} width={MINIMAP_SIZE} height={MINIMAP_SIZE} className="minimap-canvas"></canvas>
            </div>
            <div className="coords-info-container">
                <p>{seaName} ({mouseCoords.x}, {mouseCoords.y})</p>
            </div>
        </>
    );
};

export default MapOverlay;
</file>

<file path="src/components/map/MovementIndicator.js">
// src/components/map/MovementIndicator.js
import React from 'react';
import { motion } from 'framer-motion';

const TILE_SIZE = 32;

const MovementIndicator = React.memo(({ movement, citySlots, allMovements = [] }) => {
    if (!movement) return null;

    const isReturning = movement.status === 'returning';

    // #comment Prioritize using coordinates directly from the movement object.
    let originCity = isReturning ? movement.targetCoords : movement.originCoords;
    let targetCity = isReturning ? movement.originCoords : movement.targetCoords;

    // #comment Fallback to lookup method if coordinates are not on the movement object.
    if ((!originCity || !targetCity) && citySlots) {
        const originId = isReturning ? (movement.targetSlotId || movement.targetVillageId || movement.targetRuinId || movement.targetTownId) : movement.originCityId;
        const targetId = isReturning ? movement.originCityId : (movement.targetSlotId || movement.targetVillageId || movement.targetRuinId || movement.targetTownId);
        
        if (!originCity) originCity = citySlots[originId];
        if (!targetCity) targetCity = citySlots[targetId];
    }
    
    if (!originCity || !targetCity) {
        // console.warn(`Could not find origin or target for movement ${movement.id}`);
        return null;
    }

    const departureTime = movement.departureTime?.toDate().getTime() || Date.now();
    const arrivalTime = movement.arrivalTime?.toDate().getTime() || Date.now();
    const now = Date.now();
    
    let progress = 0;
    if (now < departureTime) progress = 0;
    else if (now > arrivalTime) progress = 1;
    else progress = (now - departureTime) / (arrivalTime - departureTime);

    const originX = originCity.x * TILE_SIZE + TILE_SIZE / 2;
    const originY = originCity.y * TILE_SIZE + TILE_SIZE / 2;
    const targetX = targetCity.x * TILE_SIZE + TILE_SIZE / 2;
    const targetY = targetCity.y * TILE_SIZE + TILE_SIZE / 2;

    const currentX = originX + (targetX - originX) * progress;
    const currentY = originY + (targetY - originY) * progress;

    const remainingTime = Math.max(0, (arrivalTime - now) / 1000);
    
    const totalUnits = movement.units ? Object.values(movement.units).reduce((sum, count) => sum + count, 0) : 0;
    const size = Math.min(24, 8 + Math.sqrt(totalUnits) * 2);

    const movementTypes = {
        attack: { color: '#ef4444', icon: '⚔️', lineColor: '#ef4444' },
        attack_village: { color: '#ef4444', icon: '⚔️', lineColor: '#ef4444' },
        attack_ruin: { color: '#ef4444', icon: '⚔️', lineColor: '#ef4444' },
        attack_god_town: { color: '#ef4444', icon: '⚔️', lineColor: '#ef4444' },
        reinforce: { color: '#3b82f6', icon: '🛡️', lineColor: '#3b82f6' },
        scout: { color: '#10b981', icon: '👁️', lineColor: '#10b981' },
        trade: { color: '#f59e0b', icon: '💰', lineColor: '#f59e0b' },
        return: { color: '#a855f7', icon: '↩️', lineColor: '#a855f7' },
        default: { color: '#6b7280', icon: '➡️', lineColor: '#6b7280' }
    };

    const config = movementTypes[isReturning ? 'return' : movement.type] || movementTypes.default;

    const overlappingMovements = (Array.isArray(allMovements)) ? allMovements.filter(m => {
        if (!m || m.id === movement.id) return false;
        return (
            (m.originCityId === movement.originCityId && m.targetCityId === movement.targetCityId) ||
            (m.originCityId === movement.targetCityId && m.targetCityId === movement.originCityId)
        );
    }) : [];

    const getBlendedColor = () => {
        if (overlappingMovements.length === 0) return config.lineColor;
        
        const colors = [config.lineColor];
        overlappingMovements.forEach(m => {
            if (!m) return;
            const otherConfig = movementTypes[m.type] || movementTypes.default;
            colors.push(otherConfig.lineColor);
        });

        const blended = colors.reduce((acc, color) => {
            if (!color) return acc;
            const hex = color.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            return {
                r: acc.r + r,
                g: acc.g + g,
                b: acc.b + b,
                count: acc.count + 1
            };
        }, { r: 0, g: 0, b: 0, count: 0 });

        const avgR = Math.round(blended.r / blended.count);
        const avgG = Math.round(blended.g / blended.count);
        const avgB = Math.round(blended.b / blended.count);

        return `#${avgR.toString(16).padStart(2, '0')}${avgG.toString(16).padStart(2, '0')}${avgB.toString(16).padStart(2, '0')}`;
    };

    const lineColor = getBlendedColor();
    const lineWidth = 3 + (overlappingMovements.length * 1.5);

    return (
        <>
            <div 
                className="absolute z-20"
                style={{
                    left: originX,
                    top: originY,
                    width: Math.sqrt(Math.pow(targetX - originX, 2) + Math.pow(targetY - originY, 2)),
                    height: lineWidth,
                    backgroundColor: lineColor,
                    opacity: 0.7,
                    transformOrigin: '0 0',
                    transform: `rotate(${Math.atan2(targetY - originY, targetX - originX)}rad)`,
                }}
            />
            <motion.div
                className="absolute z-30 flex items-center justify-center"
                style={{
                    left: currentX - size / 2,
                    top: currentY - size / 2,
                    width: size,
                    height: size,
                    backgroundColor: `${config.color}80`,
                    borderRadius: '50%',
                    border: `2px solid ${config.color}`,
                    fontSize: size * 0.6,
                }}
                animate={{
                    x: [0, (targetX - originX) * (1 - progress)],
                    y: [0, (targetY - originY) * (1 - progress)],
                }}
                transition={{
                    duration: remainingTime,
                    ease: "linear"
                }}
                whileHover={{ scale: 1.2 }}
            >
                {config.icon}
            </motion.div>
        </>
    );
});

export default MovementIndicator;
</file>

<file path="src/components/map/MovementItem.js">
import React, { useState, useEffect } from 'react';
import Countdown from './Countdown';
import unitConfig from '../../gameData/units.json';
import heroesConfig from '../../gameData/heroes.json';

const images = {};
const unitImageContext = require.context('../../images/troops', false, /\.(png|jpe?g|svg)$/);
unitImageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    images[key] = unitImageContext(item);
});
const heroImageContext = require.context('../../images/heroes', false, /\.(png|jpe?g|svg)$/);
heroImageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    images[key] = heroImageContext(item);
});

const MovementItem = ({ movement, citySlots, onCancel, onRush, isAdmin }) => {
    const [isCancellable, setIsCancellable] = useState(false);
    const originCity = citySlots[movement.originCityId];
    // #comment Determine the correct target ID from the movement object, with fallbacks
    const targetId = movement.targetCityId || movement.targetSlotId || movement.targetVillageId || movement.targetRuinId || movement.targetTownId;
    const targetLocation = citySlots[targetId];

    const movementTypes = {
        attack: { icon: '⚔️' },
        attack_village: { icon: '⚔️' },
        attack_ruin: { icon: '⚔️' },
        attack_god_town: { icon: '⚔️' },
        reinforce: { icon: '🛡️' },
        scout: { icon: '👁️' },
        trade: { icon: '💰' },
        return: { icon: '↩️' },
        found_city: { icon: '🏛️' },
        default: { icon: '➡️' }
    };
    const config = movementTypes[movement.type] || movementTypes.default;

    useEffect(() => {
        const checkCancellable = () => {
            if (movement.cancellableUntil?.toDate) {
                const cancellableTime = movement.cancellableUntil.toDate();
                setIsCancellable(new Date() < cancellableTime);
            } else {
                setIsCancellable(false);
            }
        };
        checkCancellable();
        const interval = setInterval(checkCancellable, 1000);
        return () => clearInterval(interval);
    }, [movement.cancellableUntil]);

    const destinationName = targetLocation?.cityName || targetLocation?.name || movement.targetCityName || movement.targetVillageName || movement.targetRuinName || movement.targetTownName || movement.targetPlotName || 'Unknown';
    const originName = originCity?.cityName || movement.originCityName || 'Unknown';
    const actionText = movement.type.replace(/_/g, ' ');

    const titleText = movement.status === 'returning'
        ? `Returning from ${destinationName}`
        : `${actionText} from ${originName} to ${destinationName}`;

    const cancellableDate = movement.cancellableUntil?.toDate();
    const arrivalDate = movement.arrivalTime?.toDate();

    return (
        <div className="movement-item-row">
            <span className="movement-type-icon">{config.icon}</span>
            <div className="movement-details">
                <p className="title capitalize">
                    {titleText}
                </p>
                <p className="timing">
                    <Countdown arrivalTime={movement.arrivalTime} />
                    (Arrival: {arrivalDate ? arrivalDate.toLocaleTimeString() : 'N/A'})
                    {cancellableDate && ` (Cancellable until: ${cancellableDate.toLocaleTimeString()})`}
                </p>
            </div>
            <button
                onClick={() => onCancel(movement.id)}
                disabled={!isCancellable}
                className="cancel-button"
                title={isCancellable ? "Cancel Movement" : "Cannot be cancelled"}
            >
                &times;
            </button>
            <div className="unit-icons-container">
                {movement.units && Object.entries(movement.units).map(([unitId, count]) => {
                    if (count > 0) {
                        const unit = unitConfig[unitId];
                        return (
                            <img
                                key={unitId}
                                src={images[unit.image]}
                                alt={unit.name}
                                className="unit-icon"
                                title={`${count}x ${unit.name}`}
                            />
                        );
                    }
                    return null;
                })}
                {movement.hero && (() => {
                    const hero = heroesConfig[movement.hero];
                    if (!hero) return null;
                    return (
                        <img
                            key={movement.hero}
                            src={images[hero.image]}
                            alt={hero.name}
                            className="unit-icon"
                            title={hero.name}
                        />
                    );
                })()}
            </div>
            {isAdmin && (
                <button onClick={() => onRush(movement.id)} className="btn btn-primary text-xs px-2 py-1">Rush</button>
            )}
        </div>
    );
};

export default MovementItem;
</file>

<file path="src/components/map/MovementModal.css">
/* src/components/map/MovementModal.css */

.movement-modal-container {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a;
    width: 90%;
    max-width: 500px;
    display: flex;
    flex-direction: column;
}

.movement-modal-header {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0.75rem 1.5rem;
    background-color: #1e3a8a;
    color: #f0e68c;
    border-bottom: 2px solid #cd853f;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.5rem;
}

.movement-modal-content {
    padding: 1rem;
    max-height: 60vh;
    overflow-y: auto;
}

.movement-modal-footer {
    padding: 1rem;
    border-top: 2px solid #8B4513;
    background-color: rgba(139, 69, 19, 0.1);
    text-align: center;
}

.unit-selection-section {
    background-color: rgba(139, 69, 19, 0.1);
    border: 1px solid #d2b48c;
    border-radius: 8px;
    padding: 1rem;
}

.unit-selection-header {
    font-weight: bold;
    font-size: 1.125rem; /* text-lg */
    color: #8B4513; /* saddlebrown */
    margin-bottom: 0.75rem;
    text-align: center;
}

.unit-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
    gap: 0.75rem;
}

.unit-item {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.unit-image-container {
    position: relative;
    width: 48px;
    height: 48px;
    background-color: rgba(0,0,0,0.1);
    border-radius: 4px;
    padding: 2px;
    margin-bottom: 4px;
    cursor: pointer;
}

.unit-image {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

.unit-count-badge {
    position: absolute;
    top: -4px;
    right: -4px;
    background-color: rgba(0,0,0,0.7);
    color: white;
    font-size: 0.7rem;
    padding: 1px 4px;
    border-radius: 8px;
}

.unit-input {
    width: 56px;
    text-align: center;
    background-color: rgba(255, 255, 255, 0.5);
    border: 1px solid #d2b48c;
    border-radius: 4px;
    color: #4a2c2a;
}
</file>

<file path="src/components/map/MovementModal.js">
// src/components/map/MovementModal.js
import React, { useState, useMemo, useEffect } from 'react';
import { calculateTravelTime, formatTravelTime } from '../../utils/travel';
import unitConfig from '../../gameData/units.json';
import heroesConfig from '../../gameData/heroes.json';
import { useGame } from '../../contexts/GameContext';
import './MovementModal.css';

// Import new panels
import TradePanel from './TradePanel';
import ScoutPanel from './ScoutPanel';
import { getTrainableNavalUnits, getTrainableUnits } from '../../utils/nationality';

// Dynamically import all images from the images folder (this is for unit images)
const images = {};
const imageContexts = [
    require.context('../../images/troops', false, /\.(png|jpe?g|svg)$/),
    require.context('../../images/resources', false, /\.(png|jpe?g|svg)$/),
    require.context('../../images/heroes', false, /\.(png|jpe?g|svg)$/),
];

imageContexts.forEach(context => {
    context.keys().forEach((item) => {
        const key = item.replace('./', '');
        images[key] = context(item);
    });
});

// #comment Displays the current weather and wind conditions
const WindInfo = ({ weather, windSpeed }) => {
    const [windRange, setWindRange] = useState('');
    const weatherIcons = {
        Clear: '☀️',
        Rainy: '🌧️',
        Windy: '💨',
        Foggy: '🌫️',
        Stormy: '⛈️',
    };

    useEffect(() => {
        let range = '';
        switch (weather) {
            case 'Clear':
                range = '0-3 knots';
                break;
            case 'Windy':
                range = '3-6 knots';
                break;
            case 'Rainy':
                range = '6-9 knots';
                break;
            case 'Stormy':
                range = '9-10 knots';
                break;
            default:
                range = 'N/A';
                break;
        }
        setWindRange(range);
    }, [weather]);

    return (
        <div className="text-gray-500 text-sm mt-2 flex items-center justify-center" title={`${weather} | Wind: ${windSpeed.toFixed(2)} knots (${windRange})`}>
            <span>{weatherIcons[weather]} {weather} | Wind: {windRange}</span>
        </div>
    );
};


// MovementModal component allows players to send units or resources for various actions.
const MovementModal = ({ mode, targetCity, playerCity, playerUnits: initialPlayerUnits, playerResources: initialPlayerResources, travelTimeInfo, onSend, onClose, setMessage }) => {
    const { gameState, worldState } = useGame();
    const [windSpeed, setWindSpeed] = useState(0);

    const currentUnits = initialPlayerUnits || gameState?.units || {};
    const currentResources = initialPlayerResources || gameState?.resources || {};
    const currentHeroes = gameState?.heroes || {};

    const [selectedUnits, setSelectedUnits] = useState({});
    const [selectedHero, setSelectedHero] = useState(null);
    const [selectedResources, setSelectedResources] = useState({ wood: 0, stone: 0, silver: 0 });
    const [attackLayers, setAttackLayers] = useState({
        front: '',
        mid: '',
        back: ''
    });

    useEffect(() => {
        if (worldState?.weather) {
            let min = 0, max = 0;
            switch (worldState.weather) {
                case 'Clear': min = 0; max = 3; break;
                case 'Windy': min = 3; max = 6; break;
                case 'Rainy': min = 6; max = 9; break;
                case 'Stormy': min = 9; max = 10; break;
                default: break;
            }
            // #comment Calculate a random wind speed within the weather's range for this specific movement
            setWindSpeed(Math.random() * (max - min) + min);
        }
    }, [worldState?.weather]);


    const transportCapacity = useMemo(() => {
        let capacity = 0;
        for (const unitId in selectedUnits) {
            if (unitConfig[unitId]?.type === 'naval' && unitConfig[unitId]?.capacity) {
                capacity += selectedUnits[unitId] * unitConfig[unitId].capacity;
            }
        }
        return capacity;
    }, [selectedUnits]);

    const currentUnitsLoad = useMemo(() => {
        let load = 0;
        for (const unitId in selectedUnits) {
            if (unitConfig[unitId]?.type === 'land' && unitConfig[unitId]?.cost?.population) {
                load += selectedUnits[unitId] * unitConfig[unitId].cost.population;
            }
        }
        return load;
    }, [selectedUnits]);

    useEffect(() => {
        const newAttackLayers = { ...attackLayers };
        let needsReset = false;
        for (const layer in newAttackLayers) {
            const unitId = newAttackLayers[layer];
            if (unitId && (!selectedUnits[unitId] || selectedUnits[unitId] === 0)) {
                newAttackLayers[layer] = '';
                needsReset = true;
            }
        }
        if (needsReset) {
            setAttackLayers(newAttackLayers);
        }
    }, [selectedUnits, attackLayers]);

    const handleUnitChange = (unitId, value) => {
        const amount = Math.max(0, Math.min(currentUnits[unitId] || 0, parseInt(value, 10) || 0));
        setSelectedUnits(prev => ({ ...prev, [unitId]: amount }));
    };

    // #comment Toggles selecting all units of a type or deselecting them.
    const handleUnitIconClick = (unitId, maxAmount) => {
        const currentAmount = selectedUnits[unitId] || 0;
        const newAmount = currentAmount === maxAmount ? 0 : maxAmount;
        handleUnitChange(unitId, newAmount);
    };

    const handleResourceChange = (resource, value) => {
        const parsedAmount = parseInt(value, 10) || 0;
        let amount = parsedAmount;

        if (mode === 'scout' && resource === 'silver') {
            const availableCaveSilver = gameState.cave?.silver || 0;
            amount = Math.max(0, Math.min(availableCaveSilver, parsedAmount));
        } else {
            amount = Math.max(0, Math.min(currentResources[resource] || 0, parsedAmount));
        }
        setSelectedResources(prev => ({ ...prev, [resource]: amount }));
    };

    const handleLayerChange = (layerName, unitId) => {
        setAttackLayers(prev => {
            const newLayers = { ...prev, [layerName]: unitId };
            return newLayers;
        });
    };

    const slowestSpeed = useMemo(() => {
        if (mode === 'trade' || mode === 'scout') return 10;
        const speeds = Object.entries(selectedUnits)
            .filter(([, count]) => count > 0)
            .map(([unitId]) => unitConfig[unitId].speed);
        return speeds.length > 0 ? Math.min(...speeds) : null;
    }, [selectedUnits, mode]);

    const finalTravelTime = useMemo(() => {
        if (!travelTimeInfo?.distance || !slowestSpeed) return 'N/A';

        const hasLandUnits = Object.keys(selectedUnits).some(unitId => unitConfig[unitId]?.type === 'land' && selectedUnits[unitId] > 0);
        const hasNavalUnits = Object.keys(selectedUnits).some(unitId => unitConfig[unitId]?.type === 'naval' && selectedUnits[unitId] > 0);
        const unitTypes = [];
        if (hasLandUnits) unitTypes.push('land');
        if (hasNavalUnits) unitTypes.push('naval');

        const timeInSeconds = calculateTravelTime(travelTimeInfo.distance, slowestSpeed, mode, worldState, unitTypes, windSpeed);
        return formatTravelTime(timeInSeconds);
    }, [slowestSpeed, travelTimeInfo?.distance, mode, worldState, selectedUnits, windSpeed]);

    const handleSend = () => {
        let totalUnitsSelected = Object.values(selectedUnits).reduce((sum, count) => sum + count, 0);
        let totalResourcesSelected = Object.values(selectedResources).reduce((sum, amount) => sum + amount, 0);

        if ((mode === 'attack' || mode === 'reinforce') && totalUnitsSelected === 0 && !selectedHero) {
            setMessage("Please select at least one unit or a hero to send.");
            return;
        }
        if (mode === 'scout') {
            const silverForScout = selectedResources.silver || 0;
            if (silverForScout <= 0) {
                setMessage("Please enter an amount of silver for scouting.");
                return;
            }
            if (silverForScout > (gameState.cave?.silver || 0)) {
                setMessage("Not enough silver in the cave for scouting.");
                return;
            }
        }
        if (mode === 'trade' && totalResourcesSelected === 0) {
            setMessage("Please select at least one resource to trade.");
            return;
        }

        const hasLandUnitsSelected = Object.keys(selectedUnits).some(unitId => unitConfig[unitId]?.type === 'land' && selectedUnits[unitId] > 0);
        const hasNavalUnitsSelected = Object.keys(selectedUnits).some(unitId => unitConfig[unitId]?.type === 'naval' && selectedUnits[unitId] > 0);

        if (hasLandUnitsSelected && hasNavalUnitsSelected && currentUnitsLoad > transportCapacity) {
            setMessage(`Not enough transport ship capacity. You need ${currentUnitsLoad - transportCapacity} more capacity.`);
            return;
        }

        if (mode === 'attack') {
            const selectedLayerUnits = Object.values(attackLayers).filter(unitId => unitId !== '');
            const uniqueLayerUnits = new Set(selectedLayerUnits);

            if (selectedLayerUnits.length !== uniqueLayerUnits.size) {
                setMessage("Each attack formation layer must have a unique unit selected.");
                return;
            }

            for (const layerName in attackLayers) {
                const unitId = attackLayers[layerName];
                if (unitId !== '' && (selectedUnits[unitId] || 0) === 0) {
                    setMessage(`Your selected ${layerName} unit (${unitConfig[unitId].name}) has 0 troops in the current selection. Please adjust unit counts or selection.`);
                    return;
                }
                if (unitId !== '' && unitConfig[unitId]?.type !== 'land') {
                    setMessage(`The unit selected for ${layerName} (${unitConfig[unitId].name}) must be a land unit.`);
                    return;
                }
            }
        }

        const resourcesToSend = {};
        if (mode === 'scout') {
            resourcesToSend.silver = selectedResources.silver;
        } else if (mode === 'trade') {
            Object.assign(resourcesToSend, selectedResources);
        }

        onSend({
            mode,
            targetCity,
            units: mode === 'scout' || mode === 'trade' ? {} : selectedUnits,
            hero: selectedHero,
            resources: resourcesToSend,
            travelTime: finalTravelTime,
            attackFormation: mode === 'attack' ? attackLayers : {}
        });
        onClose();
    };
    
    const renderContent = () => {
        const playerNation = gameState?.playerInfo?.nation;
    
        const trainableLandUnitIds = playerNation ? getTrainableUnits(playerNation) : [];
        const mythicUnitIds = Object.keys(unitConfig).filter(unitId => {
            const unit = unitConfig[unitId];
            return unit.mythical && unit.god === gameState.god;
        });
        const allTrainableLandIds = [...new Set([...trainableLandUnitIds, ...mythicUnitIds])];
        
        const landUnitsList = allTrainableLandIds.map(unitId => ({
            id: unitId,
            ...unitConfig[unitId],
            currentCount: currentUnits[unitId] || 0
        }));
    
        const trainableNavalUnitIds = playerNation ? getTrainableNavalUnits(playerNation) : [];
        const navalUnitsList = trainableNavalUnitIds.map(unitId => ({
            id: unitId,
            ...unitConfig[unitId],
            currentCount: currentUnits[unitId] || 0
        }));

        const availableHeroes = Object.keys(currentHeroes).filter(heroId => 
            currentHeroes[heroId].active && 
            !currentHeroes[heroId].capturedIn && // #comment Filter out captured heroes
            (currentHeroes[heroId].cityId === gameState.id || !currentHeroes[heroId].cityId)
        );

        const selectedLandUnitsForFormation = Object.keys(selectedUnits).filter(unitId => 
            selectedUnits[unitId] > 0 && unitConfig[unitId]?.type === 'land'
        );

        const attackLayerOptions = [
            { name: 'front', label: 'Front Line' },
            { name: 'mid', label: 'Mid Line' },
            { name: 'back', 'label': 'Back Line' }
        ];

        const capacityProgress = transportCapacity > 0 ? (currentUnitsLoad / transportCapacity) * 100 : 0;
        const progressBarColor = capacityProgress > 100 ? 'bg-red-500' : 'bg-green-500';

        if (mode === 'attack' || mode === 'reinforce') {
            return (
                <div className="space-y-4">
                    {availableHeroes.length > 0 && (
                        <div className="unit-selection-section">
                            <h4 className="unit-selection-header">Heroes</h4>
                            <div className="unit-grid">
                                {availableHeroes.map(heroId => {
                                    const hero = heroesConfig[heroId];
                                    return (
                                        <div key={heroId} className="unit-item">
                                            <div className={`unit-image-container ${selectedHero === heroId ? 'border-2 border-yellow-400' : ''}`} title={hero.name} onClick={() => setSelectedHero(prev => prev === heroId ? null : heroId)}>
                                                <img src={images[hero.image]} alt={hero.name} className="unit-image" />
                                            </div>
                                        </div>
                                    )
                                })}
                            </div>
                        </div>
                    )}
                    {landUnitsList.length > 0 && (
                        <div className="unit-selection-section">
                            <h4 className="unit-selection-header">Land Units</h4>
                            <div className="unit-grid">
                                {landUnitsList.map(unit => (
                                    <div key={unit.id} className="unit-item">
                                        <div className="unit-image-container" title={`Select all/none of ${unit.name}`} onClick={() => handleUnitIconClick(unit.id, unit.currentCount)}>
                                            <img src={images[unit.image]} alt={unit.name} className="unit-image" />
                                             <span className="unit-count-badge">
                                                {unit.currentCount}
                                            </span>
                                        </div>
                                        <input
                                            type="number"
                                            value={selectedUnits[unit.id] || 0}
                                            onChange={(e) => handleUnitChange(unit.id, e.target.value)}
                                            className="unit-input hide-number-spinners"
                                            min="0"
                                            max={unit.currentCount}
                                        />
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {navalUnitsList.length > 0 && (
                        <div className="unit-selection-section">
                            <h4 className="unit-selection-header">Naval Units</h4>
                            <div className="unit-grid">
                                {navalUnitsList.map(unit => (
                                    <div key={unit.id} className="unit-item">
                                        <div className="unit-image-container" title={`Select all/none of ${unit.name}`} onClick={() => handleUnitIconClick(unit.id, unit.currentCount)}>
                                            <img src={images[unit.image]} alt={unit.name} className="unit-image" />
                                            <span className="unit-count-badge">
                                                {unit.currentCount}
                                            </span>
                                        </div>
                                        <input
                                            type="number"
                                            value={selectedUnits[unit.id] || 0}
                                            onChange={(e) => handleUnitChange(unit.id, e.target.value)}
                                            className="unit-input hide-number-spinners"
                                            min="0"
                                            max={unit.currentCount}
                                        />
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {transportCapacity > 0 && (
                        <div className="mt-4 pt-4 border-t border-gray-700">
                            <h4 className="text-lg font-bold">Transport Capacity</h4>
                            <div className="w-full bg-gray-700 rounded-full h-6 relative">
                                <div 
                                    className={`h-full rounded-full ${progressBarColor}`} 
                                    style={{ width: `${Math.min(100, capacityProgress)}%` }}
                                ></div>
                                <div className="absolute inset-0 flex items-center justify-center text-white text-sm font-bold">
                                    {currentUnitsLoad} / {transportCapacity}
                                </div>
                            </div>
                            {capacityProgress > 100 && (
                                <p className="text-red-500 text-sm mt-1">Over capacity!</p>
                            )}
                        </div>
                    )}

                    {mode === 'attack' && selectedLandUnitsForFormation.length > 0 && (
                        <div className="mt-4 pt-4 border-t border-gray-700">
                            <h4 className="text-lg font-bold mb-2">Attack Formation</h4>
                            {attackLayerOptions.map(layer => (
                                <div key={layer.name} className="flex flex-col space-y-2 mt-2">
                                    <label>{layer.label}:</label>
                                    <select
                                        value={attackLayers[layer.name]}
                                        onChange={(e) => handleLayerChange(layer.name, e.target.value)}
                                        className="bg-gray-700 text-white rounded p-2"
                                    >
                                        <option value="">None</option>
                                        {selectedLandUnitsForFormation
                                            .filter(unitId => !Object.entries(attackLayers).some(([key, selectedUnit]) => selectedUnit === unitId && key !== layer.name))
                                            .map(unitId => (
                                                <option key={unitId} value={unitId}>{unitConfig[unitId].name}</option>
                                            ))}
                                    </select>
                                </div>
                            ))}
                        </div>
                    )}
                     {mode === 'attack' && selectedLandUnitsForFormation.length === 0 && (
                        <div className="mt-4 pt-4 border-t border-gray-700">
                            <p className="text-gray-400">Select land units to configure attack formation.</p>
                        </div>
                    )}
                </div>
            );
        }
        if (mode === 'scout') {
            return (
                <ScoutPanel
                    selectedResources={selectedResources}
                    gameState={gameState}
                    handleResourceChange={handleResourceChange}
                />
            );
        }
        if (mode === 'trade') {
            return (
                <TradePanel
                    selectedResources={selectedResources}
                    currentResources={currentResources}
                    handleResourceChange={handleResourceChange}
                />
            );
        }
        return null;
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="movement-modal-container" onClick={e => e.stopPropagation()}>
                <h3 className="movement-modal-header capitalize">{mode} {targetCity ? targetCity.cityName || targetCity.name : ''}</h3>
                <div className="movement-modal-content">
                    {renderContent()}
                </div>
                <div className="movement-modal-footer">
                    <p className="mb-2">Travel Time: <span className="font-bold text-yellow-600">{finalTravelTime}</span></p>
                    {worldState?.weather && <WindInfo weather={worldState.weather} windSpeed={windSpeed} />}
                    <button onClick={handleSend} className="btn btn-primary w-full py-2 mt-4">
                        Send
                    </button>
                </div>
            </div>
        </div>
    );
};

export default MovementModal;
</file>

<file path="src/components/map/MovementsPanel.css">
/* src/components/map/MovementsPanel.css */

.movements-panel-bg {
    /* Papyrus-like background */
    background-color: #F5DEB3; /* wheat */
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F); /* saddlebrown to peru */
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a; /* A dark, ink-like brown */
    font-family: 'Inter', sans-serif;
}

.movements-header {
    background-color: #3b82f6; /* A blue similar to the image */
    color: white;
    padding: 0.5rem 1rem;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.25rem;
    border-bottom: 2px solid #2563eb;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

.movement-item-row {
    display: flex;
    align-items: center;
    padding: 0.75rem 1rem;
    border-bottom: 1px solid #D2B48C; /* tan */
    gap: 1rem;
}

.movement-item-row:last-child {
    border-bottom: none;
}

.movement-type-icon {
    font-size: 1.5rem;
    flex-shrink: 0;
}

.movement-details {
    flex-grow: 1;
}

.movement-details .title {
    font-weight: bold;
    font-size: 1rem;
}

.movement-details .timing {
    font-size: 0.8rem;
    color: #6b4a2b;
}

.cancel-button {
    background: none;
    border: none;
    color: #dc2626; /* red-600 */
    font-size: 1.5rem;
    font-weight: bold;
    cursor: pointer;
    transition: color 0.2s;
}

.cancel-button:hover {
    color: #ef4444; /* red-500 */
}

.cancel-button:disabled {
    color: #9ca3af; /* gray-400 */
    cursor: not-allowed;
}

.unit-icons-container {
    display: flex;
    gap: 0.25rem;
    align-items: center;
}

.unit-icon {
    width: 24px;
    height: 24px;
    object-fit: contain;
    background-color: rgba(0,0,0,0.1);
    border-radius: 4px;
    padding: 2px;
}
</file>

<file path="src/components/map/MovementsPanel.js">
import React from 'react';
import MovementItem from './MovementItem';
import './MovementsPanel.css';
import { useGame } from '../../contexts/GameContext';

const MovementsPanel = ({ movements, onClose, combinedSlots, villages, onCancel, onRush, isAdmin }) => {
    const { gameSettings } = useGame();
    const allLocations = { ...combinedSlots, ...villages };


    const isTradeMovement = (m) => {
        if (!m) return false;
        if (m.type === 'trade') return true;

        if (m.status === 'returning' && m.resources && Object.values(m.resources).some(r => r > 0)) {
            if (!m.units || Object.values(m.units).every(count => count === 0)) {
                return true;
            }
        }
        return false;
    };


    const nonTradeMovements = movements.filter(m => {
        if (gameSettings.hideReturningReports && m.status === 'returning') {
            return false;
        }
        return !isTradeMovement(m);
    });

    return (
        <div className="fixed inset-0 z-40 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="movements-panel-bg w-full max-w-4xl rounded-lg" onClick={e => e.stopPropagation()}>
                <div className="movements-header rounded-t-sm">
                    <h3>Movement Overview</h3>
                </div>
                <div className="max-h-[60vh] overflow-y-auto">
                    {nonTradeMovements.length > 0 ? (
                        nonTradeMovements.map(movement => (
                            <div key={movement.id} className="flex items-center">
                                <MovementItem
                                    movement={movement}
                                    citySlots={allLocations}
                                    onCancel={onCancel}
                                    onRush={onRush}
                                    isAdmin={isAdmin}
                                />
                            </div>
                        ))
                    ) : (
                        <p className="p-8 text-center text-gray-700 italic">No active movements.</p>
                    )}
                </div>
            </div>
        </div>
    );
};

export default MovementsPanel;
</file>

<file path="src/components/map/MovementsToolTip.css">
.activity-tooltip {
    position: absolute;
    top: calc(100% + 10px); /* #comment Position below the trigger */
    left: 50%; /* #comment Center the tooltip */
    transform: translateX(-50%); /* #comment Adjust for centering */
    width: 450px;
    background-color: #F5DEB3;
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    z-index: 100;
    color: #4a2c2a;
    /* #comment Removed conflicting relative positioning */
}

.tooltip-lock-timer {
    position: absolute;
    bottom: -14px; /* #comment Position half outside */
    right: -14px; /* #comment Position half outside */
    width: 28px;
    height: 28px;
    background-color: #4a2c2a;
    color: #f0e68c;
    border: 2px solid #8B4513;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: bold;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
</file>

<file path="src/components/map/MovementsToolTip.js">
import React from 'react';
import MovementItem from './MovementItem';
import './MovementsToolTip.css';
import { useGame } from '../../contexts/GameContext';

const MovementsTooltip = ({ movements, combinedSlots, onCancel, isLocked, countdown }) => {
    const { gameSettings } = useGame();

    const isTradeMovement = (m) => {
        if (m.type === 'trade') return true;

        if (m.status === 'returning' && m.resources && Object.values(m.resources).some(r => r > 0)) {
            if (!m.units || Object.values(m.units).every(count => count === 0)) {
                return true;
            }
        }
        return false;
    };


    const activeMovements = movements.filter(m => {
        if (gameSettings.hideReturningReports && m.status === 'returning') {
            return false;
        }
        return !isTradeMovement(m);
    });

    return (
        <div className="activity-tooltip">
            {activeMovements.length > 0 ? (
                activeMovements.map(movement => (
                    <MovementItem
                        key={movement.id}
                        movement={movement}
                        citySlots={combinedSlots}
                        onCancel={onCancel}
                    />
                ))
            ) : (
                <p className="p-4 text-center text-sm">No active movements.</p>
            )}
            <div className="tooltip-lock-timer">
                {isLocked ? '🔒' : countdown}
            </div>
        </div>
    );
};

export default MovementsTooltip;
</file>

<file path="src/components/map/OtherCityModal.css">
/* src/components/map/OtherCityModal.css */

.other-city-modal-container {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a;
    width: 90%;
    max-width: 400px;
}

.other-city-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1.5rem;
    background-color: #1e3a8a;
    color: #f0e68c;
    border-bottom: 2px solid #cd853f;
}

.other-city-modal-content {
    padding: 1rem;
}

.info-box {
    background-color: rgba(139, 69, 19, 0.1);
    border: 1px solid #d2b48c;
    border-radius: 4px;
    padding: 0.75rem;
    margin-bottom: 1rem;
}

.action-buttons-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.75rem;
}

.action-btn {
    @apply font-bold py-2 px-4 rounded-md transition-all duration-200 cursor-pointer transform;
    color: #4a2c2a;
    border: 2px solid #8B4513;
    text-shadow: 0 1px 0 rgba(255, 255, 255, 0.3);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
}

.action-btn:hover {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}

.action-btn.attack-btn {
    background: linear-gradient(to bottom, #fca5a5, #ef4444);
    color: white;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    border-color: #991b1b;
}
.action-btn.attack-btn:hover {
    background: linear-gradient(to bottom, #fecaca, #f87171);
}

.action-btn.reinforce-btn {
    background: linear-gradient(to bottom, #93c5fd, #3b82f6);
    color: white;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    border-color: #1e40af;
}
.action-btn.reinforce-btn:hover {
    background: linear-gradient(to bottom, #bfdbfe, #60a5fa);
}

.action-btn.spell-btn {
    background: linear-gradient(to bottom, #d8b4fe, #a855f7);
    color: white;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    border-color: #6b21a8;
}
.action-btn.spell-btn:hover {
    background: linear-gradient(to bottom, #e9d5ff, #c084fc);
}
</file>

<file path="src/components/map/OtherCityModal.js">
// src/components/map/OtherCityModal.js
import React, { useMemo } from 'react';
import TroopDisplay from '../TroopDisplay';
import unitsData from '../../gameData/units.json';
import ruinsResearch from '../../gameData/ruinsResearch.json';
import woodImage from '../../images/resources/wood.png';
import stoneImage from '../../images/resources/stone.png';
import silverImage from '../../images/resources/silver.png';
import './OtherCityModal.css';
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';

const OtherCityModal = ({ city, onClose, onGoTo, onAction, isVillageTarget }) => {
    const { currentUser } = useAuth();
    const { setActiveCityId } = useGame();

    const canWithdraw = useMemo(() => {
        if (!city || !city.reinforcements) return false;
        return Object.values(city.reinforcements).some(reinf => reinf.ownerId === currentUser.uid);
    }, [city, currentUser.uid]);

    if (!city) return null;

    const isOwnCity = city.ownerId === currentUser.uid;

    const resourceImages = {
        wood: woodImage,
        stone: stoneImage,
        silver: silverImage,
    };

    const handleGoTo = () => {
        if (onGoTo) {
            onGoTo(city.x, city.y);
        }
        onClose();
    };
    
    const handleGoToCity = () => {
        setActiveCityId(city.id);
        onClose();
    };

    const isRuin = city.isRuinTarget;
    const isConqueredRuin = isRuin && city.ownerId && city.ownerId !== 'ruins';
    const researchReward = isRuin ? ruinsResearch[city.researchReward] : null;

    const title = isRuin 
        ? `Ancient Ruins` 
        : isVillageTarget 
        ? `Farming Village: ${city.name || 'Unnamed Village'} (Level ${city.level || '?'})` 
        : `City: ${city.cityName || 'Unnamed City'}`;
    
    const ownerText = `Owner: ${city.ownerUsername || 'Unknown'}`;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="other-city-modal-container" onClick={e => e.stopPropagation()}>
                <div className="other-city-modal-header">
                    <h3 className="font-title text-2xl">{title}</h3>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="other-city-modal-content">
                    {!isConqueredRuin && <p className="mb-2">{ownerText}</p>}
                    {city.ownerFaction && <p className="mb-6">Faction: {city.ownerFaction}</p>}
                    
                    {(isVillageTarget || isRuin) && (
                        <div className="info-box">
                            {isVillageTarget && (
                                <div className="flex justify-center items-center space-x-4">
                                    <div className="flex flex-col items-center">
                                        <span className="text-sm capitalize">Demands</span>
                                        <img src={resourceImages[city.demands]} alt={city.demands} className="w-10 h-10" />
                                    </div>
                                    <span className="text-3xl font-bold">&rarr;</span>
                                    <div className="flex flex-col items-center">
                                        <span className="text-sm capitalize">Supplies</span>
                                        <img src={resourceImages[city.supplies]} alt={city.supplies} className="w-10 h-10" />
                                    </div>
                                </div>
                            )}
                            {isRuin && !isConqueredRuin && researchReward && (
                                 <div className="text-center">
                                    <p className="font-bold text-yellow-700">Potential Reward:</p>
                                    <p className="text-sm">{researchReward.name}</p>
                                    <p className="text-xs italic">"{researchReward.description}"</p>
                                </div>
                            )}

                            {isConqueredRuin && (
                                 <div className="text-center">
                                    <p className="font-bold text-green-700">Conquered by:</p>
                                    <p className="text-lg">{city.ownerUsername}</p>
                                    {city.isConqueredByYou && researchReward && (
                                        <div className="mt-2 border-t border-gray-600 pt-2">
                                            <p className="font-bold text-yellow-700">Research Unlocked:</p>
                                            <p className="text-sm">{researchReward.name}</p>
                                            <p className="text-xs italic">"{researchReward.description}"</p>
                                        </div>
                                    )}
                                </div>
                            )}

                            {city.troops && Object.keys(city.troops).length > 0 && !isConqueredRuin && (
                                <div className="mt-4 border-t border-gray-600 pt-2">
                                    <TroopDisplay units={city.troops} unitsData={unitsData} title={isRuin ? "Guardians" : "Village Troops"} />
                                </div>
                            )}
                        </div>
                    )}
                    
                    {!isRuin &&
                        <div className="info-box">
                            <TroopDisplay
                                units={city.units}
                                reinforcements={city.reinforcements}
                                title="Garrison"
                                cityOwnerId={city.ownerId}
                            />
                        </div>
                    }

                    <div className="action-buttons-grid">
                        {(isVillageTarget || (isRuin && !isConqueredRuin)) ? (
                            <button 
                                onClick={() => onAction('attack', city)}
                                className="action-btn attack-btn col-span-2"
                            >
                                Attack
                            </button>
                        ) : !isRuin ? (
                            <>
                                {isOwnCity ? (
                                    <button 
                                        onClick={handleGoToCity}
                                        className="action-btn col-span-2"
                                    >
                                        Go to City
                                    </button>
                                ) : (
                                    <>
                                        <button 
                                            onClick={() => onAction('attack', city)}
                                            className="action-btn attack-btn"
                                        >
                                            Attack
                                        </button>
                                        <button 
                                            onClick={() => onAction('reinforce', city)}
                                            className="action-btn reinforce-btn"
                                        >
                                            Reinforce
                                        </button>
                                        {canWithdraw && (
                                            <button 
                                                onClick={() => onAction('withdraw', city)}
                                                className="action-btn"
                                            >
                                                Withdraw Troops
                                            </button>
                                        )}
                                        <button 
                                            onClick={() => onAction('scout', city)}
                                            className="action-btn"
                                        >
                                            Scout
                                        </button>
                                        <button 
                                            onClick={() => onAction('trade', city)}
                                            className="action-btn"
                                        >
                                            Trade
                                        </button>
                                         <button 
                                            onClick={() => onAction('castSpell', city)}
                                            className="action-btn spell-btn"
                                        >
                                            Cast Spell
                                        </button>
                                        <button 
                                            onClick={() => onAction('profile', city)}
                                            className="action-btn"
                                        >
                                            Profile
                                        </button>
                                        <button 
                                            onClick={handleGoTo}
                                            className="action-btn"
                                        >
                                            Go To
                                        </button>
                                    </>
                                )}
                            </>
                        ) : null}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default OtherCityModal;
</file>

<file path="src/components/map/OwnActiveCityModal.js">
// src/components/map/OwnActiveCityModal.js
import React from 'react';
import TroopDisplay from '../TroopDisplay';
import unitsData from '../../gameData/units.json';
import './OtherCityModal.css'; // Reuse styles

const OwnActiveCityModal = ({ city, onClose, onGoTo, onEnterCity, onWithdraw }) => {
    if (!city) return null;

    const handleGoTo = () => {
        if (onGoTo) {
            onGoTo(city.x, city.y);
        }
        onClose();
    };

    // #comment Check if there are any reinforcements from other cities owned by the player
    const hasReinforcements = city.reinforcements && Object.keys(city.reinforcements).length > 0;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="other-city-modal-container" onClick={e => e.stopPropagation()}>
                <div className="other-city-modal-header">
                    <h3 className="font-title text-2xl">Your Active City: {city.cityName}</h3>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="other-city-modal-content">
                    <div className="info-box">
                        <TroopDisplay 
                            units={city.units} 
                            unitsData={unitsData} 
                            title="Garrison"
                            reinforcements={city.reinforcements}
                        />
                    </div>
                    <div className="action-buttons-grid">
                        <button onClick={() => onEnterCity(city.id)} className="action-btn">
                            Enter City
                        </button>
                        {/* #comment Conditionally render Withdraw button */}
                        {hasReinforcements && (
                            <button onClick={() => onWithdraw(city)} className="action-btn">
                                Withdraw Troops
                            </button>
                        )}
                        <button onClick={handleGoTo} className={`action-btn ${hasReinforcements ? '' : 'col-span-2'}`}>
                            Center on Map
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default OwnActiveCityModal;
</file>

<file path="src/components/map/OwnInactiveCityModal.js">
// src/components/map/OwnInactiveCityModal.js
import React from 'react';
import TroopDisplay from '../TroopDisplay';
import unitsData from '../../gameData/units.json';
import './OtherCityModal.css'; // Reuse styles

const OwnInactiveCityModal = ({ city, onClose, onAction, onGoTo, onEnterCity, onSelectCity, onWithdraw }) => {
    if (!city) return null;

    const handleGoTo = () => {
        if (onGoTo) {
            onGoTo(city.x, city.y);
        }
        onClose();
    };

    const handleSelect = () => {
        if (onSelectCity) {
            onSelectCity(city.id);
        }
        onClose();
    };

    const hasReinforcements = city.reinforcements && Object.keys(city.reinforcements).length > 0;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="other-city-modal-container" onClick={e => e.stopPropagation()}>
                <div className="other-city-modal-header">
                    <h3 className="font-title text-2xl">Your City: {city.cityName}</h3>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="other-city-modal-content">
                    <div className="info-box">
                        <TroopDisplay 
                            units={city.units} 
                            unitsData={unitsData} 
                            title="Garrison"
                            reinforcements={city.reinforcements}
                        />
                    </div>
                    <div className="action-buttons-grid">
                        <button onClick={() => onEnterCity(city.id)} className="action-btn">
                            Enter City
                        </button>
                        <button onClick={handleSelect} className="action-btn">
                            Select City
                        </button>
                        <button 
                            onClick={() => onAction('reinforce', city)}
                            className="action-btn reinforce-btn"
                        >
                            Reinforce
                        </button>
                        <button 
                            onClick={() => onAction('trade', city)}
                            className="action-btn"
                        >
                            Trade
                        </button>
                        {hasReinforcements && (
                            <button onClick={() => onWithdraw(city)} className="action-btn">
                                Withdraw Troops
                            </button>
                        )}
                        <button onClick={handleGoTo} className="action-btn">
                            Center on Map
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default OwnInactiveCityModal;
</file>

<file path="src/components/map/RadialMenu.css">
.radial-menu-overlay {
    position: fixed;
    inset: 0;
    z-index: 50;
}
.radial-menu-container {
    position: absolute;
    width: 100px;
    height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    border: 2px solid #8B4513;
    box-shadow: 0 0 10px rgba(0,0,0,0.4);
}
.radial-menu-item {
    position: absolute;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: transparent;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    padding: 0;
}
.radial-menu-icon-wrapper {
    width: 35px;
    height: 35px;
    border-radius: 50%;
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #4a2c2a;
    border: 1px solid #8B4513;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
.radial-menu-item:hover .radial-menu-icon-wrapper {
    box-shadow: 0 4px 8px rgba(0,0,0,0.4);
}
.radial-menu-icon {
    font-size: 18px;
}
.radial-menu-center-button {
    position: absolute;
    z-index: 11; /* Above other items */
}
</file>

<file path="src/components/map/RadialMenu.js">
import React from 'react';
import './RadialMenu.css';

const RadialMenu = ({ actions, centerAction, position, onClose }) => {
    const radius = 50; // Changed from 40
    const angleStep = (2 * Math.PI) / actions.length;

    if (!position) {
        return null;
    }

    return (
        <div className="radial-menu-overlay" onClick={onClose}>
            <div
                className="radial-menu-container"
                style={{
                    left: `${position.x}px`,
                    top: `${position.y}px`,
                }}
                onClick={e => e.stopPropagation()}
            >
                {/* Center Button */}
                {centerAction && (
                    <button
                        className="radial-menu-item radial-menu-center-button"
                        onClick={(e) => {
                            e.stopPropagation();
                            centerAction.handler();
                            onClose();
                        }}
                        title={centerAction.label}
                    >
                        <span className="radial-menu-icon-wrapper">
                            <span className="radial-menu-icon">{centerAction.icon}</span>
                        </span>
                    </button>
                )}

                {/* Radial Buttons */}
                {actions.map((action, index) => {
                    const angle = index * angleStep - Math.PI / 2;
                    const x = radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);
                    return (
                        <button
                            key={index}
                            className="radial-menu-item"
                            style={{ transform: `translate(${x}px, ${y}px)` }}
                            onClick={(e) => {
                                e.stopPropagation();
                                action.handler();
                                onClose();
                            }}
                            title={action.label}
                        >
                            <span className="radial-menu-icon-wrapper">
                                <span className="radial-menu-icon">{action.icon}</span>
                            </span>
                        </button>
                    );
                })}
            </div>
        </div>
    );
};

export default RadialMenu;
</file>

<file path="src/components/map/ScoutPanel.js">
// src/components/map/ScoutPanel.js
import React from 'react';

const ScoutPanel = ({ selectedResources, gameState, handleResourceChange }) => {
    const availableCaveSilver = gameState.cave?.silver || 0;

    return (
        <div className="unit-selection-section space-y-2">
            <h4 className="font-bold text-lg text-yellow-700 mb-2">Silver for Espionage</h4>
            <div className="flex justify-between items-center">
                <span className="capitalize">Silver in Cave ({Math.floor(availableCaveSilver)})</span>
                <input
                    type="number"
                    value={selectedResources.silver || 0}
                    onChange={(e) => handleResourceChange('silver', e.target.value)}
                    className="bg-white/50 border border-yellow-800/50 p-1 rounded text-gray-800 w-32"
                />
            </div>
        </div>
    );
};

export default ScoutPanel;
</file>

<file path="src/components/map/SidebarNav.js">
// src/components/map/SidebarNav.js
import React from 'react';

const SidebarNav = ({ onToggleView, view, onOpenReports, onOpenAlliance, onOpenMessages, onOpenSettings, onOpenProfile, unreadReportsCount, unreadMessagesCount, isAdmin, onToggleDummyCityPlacement, onOpenForum, onOpenLeaderboard, onOpenQuests, onOpenCheats, isAllianceMember, handleOpenEvents, onOpenHeroesAltar, onOpenManagementPanel }) => {
    
    const NavButton = ({ icon, text, onClick, notificationCount, glowing, disabled, title }) => (
        <button 
            onClick={onClick} 
            className={`sidebar-button ${glowing ? 'glowing-border' : ''}`}
            disabled={disabled}
            title={title}
        >
            <div className="icon-container">{icon}</div>
            <span className="button-text">{text}</span>
            {notificationCount > 0 && (
                <span className="notification-badge">
                    {notificationCount}
                </span>
            )}
        </button>
    );
    
    return (
        <div className="sidebar" onMouseDown={(e) => e.stopPropagation()}>
            <NavButton icon="🗺️" text={view === 'map' ? 'City View' : 'Map View'} onClick={onToggleView} />
            
            <NavButton icon="📜" text="Reports" onClick={onOpenReports} notificationCount={unreadReportsCount} glowing={unreadReportsCount > 0} />
            <NavButton icon="🏛️" text="Alliance" onClick={onOpenAlliance} />
            <NavButton 
                icon="🖋️" 
                text="Forum" 
                onClick={onOpenForum} 
                disabled={!isAllianceMember}
                title={!isAllianceMember ? "You must be in an alliance to access the forum" : "Forum"}
            />
            <NavButton icon="✉️" text="Messages" onClick={onOpenMessages} notificationCount={unreadMessagesCount} glowing={unreadMessagesCount > 0} />
            <NavButton icon="🏆" text="Leaderboard" onClick={onOpenLeaderboard} />
            <NavButton icon="👤" text="Profile" onClick={() => onOpenProfile()} />
            <NavButton icon="📊" text="Manager" onClick={onOpenManagementPanel} />
            <NavButton icon="⚙️" text="Settings" onClick={onOpenSettings} />
            {isAdmin && (
                <>
                    {view === 'city' && <NavButton icon="🔧" text="Admin Cheats" onClick={onOpenCheats} />}
                    <NavButton icon="✨" text="Events" onClick={handleOpenEvents} />
                    {view === 'map' && (
                        <button onClick={onToggleDummyCityPlacement} className="sidebar-button bg-yellow-700 hover:bg-yellow-600">
                             <div className="icon-container">👑</div>
                             <span className="button-text">Place Dummy</span>
                        </button>
                    )}
                </>
            )}
        </div>
    );
};

export default SidebarNav;
</file>

<file path="src/components/map/Tiles.js">
import React from 'react';
import { useAuth } from '../../contexts/AuthContext';
import godTownImage from '../../images/god-town.png';
import unitConfig from '../../gameData/units.json';
import allianceWonders from '../../gameData/alliance_wonders.json';
const images = {};
const imageContexts = [
    require.context('../../images', false, /\.(png|jpe?g|svg)$/),
    require.context('../../images/troops', false, /\.(png|jpe?g|svg)$/),
];
imageContexts.forEach(context => {
    context.keys().forEach((item) => {
        const key = item.replace('./', '');
        // To prevent overwrites if filenames are the same in different folders, check if key exists.
        if (!images[key]) {
            images[key] = context(item);
        }
    });
});
const defaultSettings = { showVisuals: true, showGrid: true };
const _WaterTile = ({ gameSettings = defaultSettings }) => {
    return <div className="w-full h-full bg-transparent" />;
};
const _LandTile = ({ gameSettings = defaultSettings }) => {
    // #comment Make land tiles transparent so the island images in MapView are visible.
    const bgClass = gameSettings.showVisuals ? 'bg-transparent' : 'bg-gray-800';
    const borderClass = gameSettings.showGrid
        ? `border-r border-b ${gameSettings.showVisuals ? 'border-green-700/20' : 'border-gray-700'}`
        : 'border-r border-b border-transparent';
    return <div className={`w-full h-full ${bgClass} ${borderClass}`} />;
};
const _CitySlotTile = ({ slotData, onClick, isPlacingDummyCity, playerAlliance, gameSettings = defaultSettings, cityPoints, scoutedCities, islandCenterX }) => {
    const { currentUser } = useAuth();
    let slotClass = 'empty-slot';
    let tooltipText = `Empty Plot (${slotData.x}, ${slotData.y})`;
    let citySpriteStyle = {};
    let hasCitySprite = false;
    const formatUnitsForTooltip = (units) => {
        if (!units || Object.keys(units).length === 0) return '';
        const unitEntries = Object.entries(units)
            .filter(([, count]) => count > 0)
            .map(([id, count]) => {
                const unit = unitConfig[id];
                if (!unit) return '';
                const imageUrl = images[unit.image];
                return `
                    <div class="tooltip-troop-item">
                        <img src="${imageUrl}" alt="${unit.name}" class="tooltip-troop-image" />
                        <span class="tooltip-troop-count">${count}</span>
                    </div>
                `;
            })
            .join('');
        if (!unitEntries) return '';
        return `<hr class="tooltip-hr"><b>City Units</b><br><div class="tooltip-troop-grid">${unitEntries}</div>`;
    };
    if (slotData.ownerId) {
        hasCitySprite = true;
        const ownerName = slotData.ownerUsername || 'Unknown';
        const isOwn = slotData.ownerId === currentUser.uid;

        // #comment Use playerAlliance context for consistent alliance info for own cities
        const cityAllianceTag = isOwn ? playerAlliance?.tag : slotData.alliance;
        const cityAllianceName = isOwn ? playerAlliance?.name : slotData.allianceName;
        
        // #comment Use the correct key to find city points for own cities vs other players' cities
        const pointsKey = isOwn ? slotData.slotId : slotData.id;
        const points = cityPoints[pointsKey] || 0;

        let troopsHTML = '';
        if (isOwn) {
            slotClass = 'my-city';
            troopsHTML = formatUnitsForTooltip(slotData.units);
        } else if (slotData.ownerId === 'ghost') {
            slotClass = 'ghost-city';
            hasCitySprite = false;
            troopsHTML = formatUnitsForTooltip(slotData.units);
        } else if (scoutedCities && scoutedCities[slotData.id]) {
            troopsHTML = formatUnitsForTooltip(scoutedCities[slotData.id]);
        }
        const baseInfo = `
            <div class="tooltip-info-section">
                <b>${slotData.cityName}</b><br>
                Owner: ${ownerName}<br>
                Points: ${points.toLocaleString()}<br>
                Alliance: ${cityAllianceName || 'None'}
            </div>
        `;
        tooltipText = `${baseInfo}${troopsHTML}`;
        if (slotData.ownerId !== currentUser.uid && slotData.ownerId !== 'ghost') {
            if (playerAlliance && playerAlliance.tag && cityAllianceTag) {
                const allies = playerAlliance.diplomacy?.allies || [];
                const enemies = playerAlliance.diplomacy?.enemies || [];
                if (cityAllianceTag.toUpperCase() === playerAlliance.tag.toUpperCase()) {
                    slotClass = 'alliance-city';
                } else if (allies.some(ally => ally && ally.tag && ally.tag.toUpperCase() === cityAllianceTag.toUpperCase())) {
                    slotClass = 'ally-city';
                } else if (enemies.some(enemy => enemy && enemy.tag && enemy.tag.toUpperCase() === cityAllianceTag.toUpperCase())) {
                    slotClass = 'enemy-city';
                } else {
                    slotClass = 'neutral-city';
                }
            } else if (slotData.ownerId.startsWith('dummy_')) {
                slotClass = 'dummy-city-plot';
                 hasCitySprite = false;
            } else {
                slotClass = 'neutral-city';
            }
        }
        if (gameSettings.showVisuals && hasCitySprite) {
            const isLeftSide = slotData.x < islandCenterX;
            const backgroundPositionX = isLeftSide ? '0%' : '100%';
            let backgroundPositionY;
            if (points < 2000) {
                backgroundPositionY = '0%';
            } else if (points <= 10000) {
                backgroundPositionY = '50%';
            } else {
                backgroundPositionY = '100%';
            }
            citySpriteStyle = {
                backgroundImage: `url(${images['city_modal.png']})`,
                backgroundSize: '200% 300%',
                backgroundPosition: `${backgroundPositionX} ${backgroundPositionY}`,
            };
        }
    } else if (isPlacingDummyCity) {
        slotClass = 'dummy-placement-plot';
        tooltipText = 'Click to place dummy city';
    }
    const backgroundClass = 'bg-transparent';
    const borderClass = gameSettings.showGrid
        ? `border-r border-b ${gameSettings.showVisuals ? 'border-green-700/20' : 'border-gray-700'}`
        : 'border-r border-b border-transparent';
    return (
        <div className={`w-full h-full ${backgroundClass} ${borderClass} flex justify-center items-center`}>
            <div onClick={(e) => onClick(e, slotData)} className={`city-slot ${slotClass}`}>
                 {gameSettings.showVisuals && hasCitySprite && <div className="city-sprite" style={citySpriteStyle}></div>}
                <span className="map-object-tooltip" dangerouslySetInnerHTML={{ __html: tooltipText }}></span>
            </div>
        </div>
    );
};
const _FarmingVillageTile = ({ villageData, onClick, conqueredVillages, gameSettings = defaultSettings }) => {
    const level = villageData.level || 1;
    let villageClass = `village-level-${level}`;
    let tooltipText = `Village: ${villageData.name}<br>Level: ${level}`;
    const conqueredData = conqueredVillages ? conqueredVillages[villageData.id] : null;
    if (conqueredData) {
        villageClass += ' my-village';
        const happiness = conqueredData.happiness !== undefined ? conqueredData.happiness : 100;
        tooltipText = `Your Village: ${villageData.name}<br>Happiness: ${Math.floor(happiness)}%`;
    } else {
        villageClass += ' other-village-plot';
    }
    const backgroundClass = 'bg-transparent';
    const borderClass = gameSettings.showGrid
        ? `border-r border-b ${gameSettings.showVisuals ? 'border-green-700/20' : 'border-gray-700'}`
        : 'border-r border-b border-transparent';
    return (
        <div className={`w-full h-full ${backgroundClass} ${borderClass} flex justify-center items-center`}>
            <div onClick={(e) => onClick(e, villageData)} className={`village-slot ${villageClass}`}>
                <span className="map-object-tooltip" dangerouslySetInnerHTML={{ __html: tooltipText }}></span>
            </div>
        </div>
    );
};
const _RuinTile = ({ ruinData, onClick, gameSettings = defaultSettings }) => {
    let ruinClass = 'ruin-slot';
    let tooltipText = `Ruin: ${ruinData.name}`;
    if (ruinData.ownerId && ruinData.ownerId !== 'ruins') {
        ruinClass += ' ruin-occupied';
        tooltipText = `Conquered Ruin<br>Owner: ${ruinData.ownerUsername}`;
    } else {
        ruinClass += ' ruin-unoccupied';
    }
    const bgClass = 'bg-transparent';
    return (
        <div className={`w-full h-full ${bgClass} flex justify-center items-center`}>
            <div
                onClick={(e) => onClick(e, ruinData)}
                className={ruinClass}
            >
                <span className="map-object-tooltip" dangerouslySetInnerHTML={{ __html: tooltipText }}></span>
            </div>
        </div>
    );
};
const _GodTownTile = ({ townData, onClick, gameSettings = defaultSettings }) => {
    let townClass = 'god-town-slot';
    let tooltipText = `God Town: ${townData.name}`;
    let image = townData.stage === 'ruins' ? images['ruin_new.png'] : godTownImage;
    if (townData.stage === 'ruins') {
        townClass += ' ruins';
        tooltipText = `Strange Ruins`;
    } else if (townData.stage === 'city') {
        townClass += ' city';
        tooltipText = `God Town: ${townData.name}<br>Health: ${townData.health}`;
    }
    const bgClass = 'bg-transparent';
    return (
        <div className={`w-full h-full ${bgClass} flex justify-center items-center`}>
            <div
                onClick={() => onClick(townData.id)}
                className={townClass}
                style={{ backgroundImage: `url(${image})` }}
            >
                <span className="map-object-tooltip" dangerouslySetInnerHTML={{ __html: tooltipText }}></span>
            </div>
        </div>
    );
};
const _WonderSpotTile = ({ spotData, onClick, playerAlliance, controlledIslands }) => {
    const allianceTag = playerAlliance?.tag;
    const controllingAllianceTag = controlledIslands ? controlledIslands[spotData.islandId] : null;
    const hasControl = allianceTag && allianceTag === controllingAllianceTag;
    const tileClass = `wonder-spot-tile ${hasControl ? 'active' : ''}`;
    const tooltipText = hasControl
        ? "Click to build an Alliance Wonder"
        : "Your alliance must control this entire island to build a wonder.";
    const handleClick = hasControl ? () => onClick(spotData) : undefined;
    return (
        <div className="w-full h-full flex justify-center items-center">
            <div onClick={handleClick} className={tileClass}>
                <span className="map-object-tooltip">{tooltipText}</span>
            </div>
        </div>
    );
};
const _ConstructingWonderTile = ({ wonderData, onClick }) => {
    const wonderConfig = allianceWonders[wonderData.id];
    const tooltipText = `${wonderConfig.name} (Lvl ${wonderData.level})<br>Alliance: ${wonderData.allianceName || 'Unknown'}`;
    return (
        <div className="w-full h-full flex justify-center items-center">
            <div onClick={() => onClick(wonderData)} className="constructing-wonder-tile">
                <span className="map-object-tooltip" dangerouslySetInnerHTML={{ __html: tooltipText }}></span>
            </div>
        </div>
    );
};
export const WaterTile = React.memo(_WaterTile);
export const LandTile = React.memo(_LandTile);
export const CitySlotTile = React.memo(_CitySlotTile);
export const FarmingVillageTile = React.memo(_FarmingVillageTile);
export const RuinTile = React.memo(_RuinTile);
export const GodTownTile = React.memo(_GodTownTile);
export const WonderSpotTile = React.memo(_WonderSpotTile);
export const ConstructingWonderTile = React.memo(_ConstructingWonderTile);
</file>

<file path="src/components/map/TopBar.css">
.top-bar-container {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3;
    border-bottom: 2px solid #8B4513;
    box-shadow: 0 1px 5px rgba(0,0,0,0.5);
    color: #4a2c2a;
    font-size: 0.875rem;
    padding: 0.25rem 0.5rem;
}

.city-name-container {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
}

.city-name-dropdown-btn {
    background-color: rgba(0,0,0,0.1);
    border: 1px solid #8B4513;
    padding: 0.1rem 0.5rem;
    border-radius: 4px;
    transition: background-color 0.2s;
    font-size: 1rem;
}
.city-name-dropdown-btn:hover {
    background-color: rgba(0,0,0,0.2);
}

.city-list-dropdown {
    background-image: linear-gradient(rgba(245, 222, 179, 0.98), rgba(245, 222, 179, 0.98)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3;
    border: 2px solid #8B4513;
    box-shadow: 0 4px 10px rgba(0,0,0,0.4);
    color: #4a2c2a;
    max-height: 320px;
    overflow-y: auto;
}
.city-list-item {
    @apply w-full text-left px-4 py-2 hover:bg-amber-300/50;
}
.city-list-item.active {
    @apply bg-amber-400/60 font-bold;
}
.weather-display {
    background: rgba(0,0,0,0.1);
    border: 1px solid #8B4513;
    border-radius: 9999px;
    padding: 0.1rem 0.5rem;
    display: flex;
    align-items: center;
}
.resource-display {
    display: flex;
    align-items: center;
    background: rgba(0,0,0,0.1);
    padding: 0.1rem 0.25rem;
    border-radius: 4px;
    border: 1px solid #8B4513;
}
.resource-display:hover {
    background: rgba(0,0,0,0.2);
}
.activity-tracker-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background: rgba(0,0,0,0.1);
    border: 1px solid #8B4513;
    border-radius: 9999px;
    padding: 0.1rem 0.25rem;
    margin-right: 1rem;
}
.activity-icon {
    position: relative;
    font-size: 1rem;
    background: none;
    border: none;
    cursor: pointer;
    padding: 0.2rem;
    border-radius: 50%;
    transition: background-color 0.2s;
}
.activity-icon-image-container {
    position: relative;
    background: none;
    border: none;
    cursor: pointer;
    padding: 0.1rem;
    border-radius: 50%;
    transition: background-color 0.2s;
    width: 2rem;
    height: 1.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
}
.activity-icon-image-container:hover {
    background-color: rgba(0,0,0,0.1);
}
.activity-icon-image {
    width: 1.8rem;
    height:1.8rem;
}
.activity-icon:hover {
    background-color: rgba(0,0,0,0.1);
}
.activity-badge {
    position: absolute;
    top: -2px;
    right: -3px;
    background-color: #ef4444;
    color: white;
    font-size: 0.5rem;
    font-weight: bold;
    border-radius: 9999px;
    width: 12px;
    height: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid white;
}
.glowing-attack-icon {
    animation: glowing-icon-animation 1.5s infinite;
}
@keyframes glowing-icon-animation {
    0% {
        text-shadow: 0 0 3px #ef4444;
    }
    50% {
        text-shadow: 0 0 10px #f87171, 0 0 5px #f87171;
    }
    100% {
        text-shadow: 0 0 3px #ef4444;
    }
}
</file>

<file path="src/components/map/TopBar.js">
import React, { useState, useEffect, useRef, useMemo } from 'react';
import { useGame } from '../../contexts/GameContext';
import woodImage from '../../images/resources/wood.png';
import stoneImage from '../../images/resources/stone.png';
import silverImage from '../../images/resources/silver.png';
import populationImage from '../../images/resources/population.png';
import recruitmenticon from '../../images/helmet.png';
import tradeicon from '../../images/trade.png';
import movementicon from '../../images/movement.png'
import battlePointsImage from '../../images/battle_points.png';
import './TopBar.css';
import RecruitmentTooltip from '../city/RecruitmentToolTip';
import TradesTooltip from './TradesToolTip';
import MovementsTooltip from './MovementsToolTip';

const CityListDropdown = ({ cities, onSelect, onClose, activeCityId }) => {
    const dropdownRef = useRef(null);

    useEffect(() => {
        const handleClickOutside = (event) => {
            if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
                onClose();
            }
        };
        document.addEventListener("mousedown", handleClickOutside);
        return () => {
            document.removeEventListener("mousedown", handleClickOutside);
        };
    }, [onClose]);

    return (
        <div ref={dropdownRef} className="city-list-dropdown absolute top-full mt-2 w-64 rounded-lg shadow-lg z-50">
            <ul>
                {Object.values(cities).map(city => (
                    <li key={city.id}>
                        <button
                            onClick={() => onSelect(city.id)}
                            className={`city-list-item ${city.id === activeCityId ? 'active' : ''}`}
                        >
                            {city.cityName}
                        </button>
                    </li>
                ))}
            </ul>
        </div>
    );
};

const WeatherDisplay = ({ season, weather }) => {
    const weatherIcons = {
        Clear: '☀️',
        Rainy: '🌧️',
        Windy: '💨',
        Foggy: '🌫️',
        Stormy: '⛈️',
    };
    const seasonColors = {
        Spring: 'text-pink-600',
        Summer: 'text-yellow-600',
        Autumn: 'text-orange-600',
        Winter: 'text-blue-600',
    };

    return (
        <div className="weather-display">
            <span className="text-xl mr-2">{weatherIcons[weather] || '❓'}</span>
            <span className={`font-bold ${seasonColors[season] || 'text-inherit'}`}>{season}</span>
            <span className="mx-2">|</span>
            <span className="font-bold">{weather}</span>
        </div>
    );
};

const ResourceTooltip = ({ resource, production, capacity, isLocked, countdown }) => {
    if (!resource) return null;

    return (
        <div className="resource-tooltip">
            <h4 className="font-bold capitalize text-lg">{resource}</h4>
            <p className="text-sm">Production: <span className="font-semibold">+{production}/hr</span></p>
            <p className="text-sm">Capacity: <span className="font-semibold">{capacity.toLocaleString()}</span></p>
            <div className="tooltip-lock-timer">
                {isLocked ? '🔒' : countdown}
            </div>
        </div>
    );
};

const TopBar = ({
    view,
    gameState,
    availablePopulation,
    happiness,
    worldState,
    productionRates,
    movements,
    onCancelTrain,
    onCancelMovement,
    combinedSlots,
    onOpenMovements,
    isUnderAttack,
    incomingAttackCount,
    onRenameCity,
    onOpenQuests,
    hasUnclaimedQuests,
    getWarehouseCapacity,
    onSwitchCity,
    battlePoints
}) => {
    const { playerCities, activeCityId } = useGame();
    const [isCityListOpen, setIsCityListOpen] = useState(false);
    const [activeTooltip, setActiveTooltip] = useState(null);
    const [isTooltipLocked, setIsTooltipLocked] = useState(false);
    const tooltipTimeoutRef = useRef(null);
    const lockTooltipTimeoutRef = useRef(null);
    const activityTrackerRef = useRef(null);
    const [isEditingCityName, setIsEditingCityName] = useState(false);
    const [newCityName, setNewCityName] = useState('');
    const [lockCountdown, setLockCountdown] = useState(5);
    const countdownIntervalRef = useRef(null);

    // #comment This hook handles clicks outside the activity tracker to close a locked tooltip.
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (isTooltipLocked && activityTrackerRef.current && !activityTrackerRef.current.contains(event.target)) {
                setIsTooltipLocked(false);
                setActiveTooltip(null);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [isTooltipLocked]);

    useEffect(() => {
        clearTimeout(lockTooltipTimeoutRef.current);
        clearInterval(countdownIntervalRef.current);
        setLockCountdown(5);

        if (activeTooltip && !isTooltipLocked) {
            countdownIntervalRef.current = setInterval(() => {
                setLockCountdown(prev => {
                    if (prev <= 1) {
                        clearInterval(countdownIntervalRef.current);
                        return 0;
                    }
                    return prev - 1;
                });
            }, 1000);

            lockTooltipTimeoutRef.current = setTimeout(() => {
                setIsTooltipLocked(true);
                clearInterval(countdownIntervalRef.current);
            }, 5000);
        }

        return () => {
            clearTimeout(lockTooltipTimeoutRef.current);
            clearInterval(countdownIntervalRef.current);
        };
    }, [activeTooltip, isTooltipLocked]);

    const getSafeDate = (timestamp) => {
        if (!timestamp) return null;
        if (typeof timestamp.toDate === 'function') {
            return timestamp.toDate();
        }
        return new Date(timestamp);
    };

    const isTradeMovement = (m) => {
        if (!m) return false;
        if (m.type === 'trade') return true;
        if (m.status === 'returning' && m.resources && Object.values(m.resources).some(r => r > 0)) {
            if (!m.units || Object.values(m.units).every(count => count === 0)) {
                return true;
            }
        }
        return false;
    };

    const recruitmentCount = useMemo(() => {
        if (!playerCities) return 0;
        return Object.values(playerCities).reduce((acc, city) => {
            const activeUnitQueue = (city.barracksQueue || []).concat(city.shipyardQueue || []).concat(city.divineTempleQueue || []).filter(item => {
                const endDate = getSafeDate(item.endTime);
                return endDate && endDate > new Date();
            });
            const activeHealQueue = (city.healQueue || []).filter(item => {
                const endDate = getSafeDate(item.endTime);
                return endDate && endDate > new Date();
            });
            return acc + activeUnitQueue.length + activeHealQueue.length;
        }, 0);
    }, [playerCities]);

    const tradeCount = useMemo(() => {
        if (!movements) return 0;
        return movements.filter(isTradeMovement).length;
    }, [movements]);

    const movementCount = useMemo(() => {
        if (!movements) return 0;
        return movements.filter(m => !isTradeMovement(m)).length;
    }, [movements]);

    const happinessTooltip = useMemo(() => {
        if (!gameState?.buildings) return `Happiness: ${happiness}%`;
        const baseHappiness = (gameState.buildings.senate?.level || 0) * 5;
        let workerCount = 0;
        const productionBuildings = ['timber_camp', 'quarry', 'silver_mine'];
        productionBuildings.forEach(buildingId => {
            if (gameState.buildings[buildingId]?.workers) {
                workerCount += gameState.buildings[buildingId].workers;
            }
        });
        const happinessPenalty = workerCount * 3;
        return `Happiness: ${happiness}%\nBase: ${baseHappiness}%\nWorker Penalty: -${happinessPenalty}%`;
    }, [gameState, happiness]);


    if (!gameState) return null;
    const { resources, cityName } = gameState;
    const happinessIcon = happiness > 70 ? '😊' : (happiness > 40 ? '😐' : '😠');

    const handleCitySelect = (cityId) => {
    if (onSwitchCity) {
        onSwitchCity(cityId);
    }
    setIsCityListOpen(false);
};

    const handleMouseEnter = (tooltip) => {
        if (isTooltipLocked && activeTooltip !== tooltip) {
            setIsTooltipLocked(false);
        }
        clearTimeout(tooltipTimeoutRef.current);
        setActiveTooltip(tooltip);
    };

    const handleMouseLeave = () => {
        if (isTooltipLocked) return;
        tooltipTimeoutRef.current = setTimeout(() => {
            setActiveTooltip(null);
        }, 300);
    };

    const handleTooltipClick = (e, tooltip) => {
        e.stopPropagation();
        if (isTooltipLocked && activeTooltip === tooltip) {
            setIsTooltipLocked(false);
            setActiveTooltip(null);
        } else {
            setIsTooltipLocked(true);
            setActiveTooltip(tooltip);
        }
    };

    const handleDoubleClick = () => {
        setNewCityName(gameState.cityName);
        setIsEditingCityName(true);
    };

    const handleNameChange = (e) => {
        setNewCityName(e.target.value);
    };

    const handleNameSubmit = async () => {
        if (newCityName.trim() && newCityName.trim() !== gameState.cityName) {
            try {
                await onRenameCity(activeCityId, newCityName.trim());
            } catch (error) {
                console.error("Failed to rename city:", error);
            }
        }
        setIsEditingCityName(false);
    };

    const handleInputKeyDown = (e) => {
        if (e.key === 'Enter') {
            handleNameSubmit();
        } else if (e.key === 'Escape') {
            setIsEditingCityName(false);
        }
    };

    return (
        <div className={`p-2 flex items-center justify-between top-bar-container z-30 ${view === 'map' ? 'absolute top-0 left-0 right-0' : 'relative flex-shrink-0'}`}>
            {/* Left side */}
            <div className="flex-1 flex justify-start items-center space-x-4">
                {worldState && (
                    <div
                        className="relative"
                        onMouseEnter={() => handleMouseEnter('weather')}
                        onMouseLeave={handleMouseLeave}
                        onClick={(e) => handleTooltipClick(e, 'weather')}
                    >
                        <WeatherDisplay season={worldState.season} weather={worldState.weather} />
                        {activeTooltip === 'weather' && (
                            <div className="resource-tooltip">
                                <h4 className="font-bold capitalize text-lg">Weather</h4>
                                <p className="text-sm">Current conditions affect travel times.</p>
                                <div className="tooltip-lock-timer">
                                    {isTooltipLocked ? '🔒' : lockCountdown}
                                </div>
                            </div>
                        )}
                    </div>
                )}
                 <div className="resource-display" title="Battle Points">
                    <img src={battlePointsImage} alt="Battle Points" className="w-6 h-6 mr-2"/>
                    <span className="font-bold text-red-800">{battlePoints.toLocaleString()}</span>
                </div>
            </div>

            {/* Center: City Name */}
            <div className="flex-1 flex justify-center items-center">
                <div className="city-name-container" onDoubleClick={handleDoubleClick}>
                    {isEditingCityName ? (
                        <input
                            type="text"
                            value={newCityName}
                            onChange={handleNameChange}
                            onBlur={handleNameSubmit}
                            onKeyDown={handleInputKeyDown}
                            autoFocus
                            className="font-title text-xl text-center bg-transparent text-yellow-200 border-none focus:ring-0 w-full"
                        />
                    ) : (
                        <div className="relative">
                            <button
                                className="city-name-dropdown-btn"
                                onClick={() => setIsCityListOpen(prev => !prev)}
                                title="Click to switch city | Double-click to rename"
                            >
                                {cityName}
                            </button>
                            {isCityListOpen && (
                                <CityListDropdown
                                    cities={playerCities}
                                    onSelect={handleCitySelect}
                                    onClose={() => setIsCityListOpen(false)}
                                    activeCityId={activeCityId}
                                />
                            )}
                        </div>
                    )}
                </div>
            </div>

            {/* Right side */}
            <div className="flex-1 flex justify-end items-center space-x-2" onMouseLeave={handleMouseLeave}>
                 <div
                    ref={activityTrackerRef}
                    className="activity-tracker-container"
                    onMouseLeave={handleMouseLeave}
                >
                    <div className="relative" onMouseEnter={() => handleMouseEnter('recruitment')} onClick={(e) => handleTooltipClick(e, 'recruitment')}>
                        <button className="activity-icon-image-container">
                            <img src={recruitmenticon} alt="Recruitment" className="activity-icon-image" />
                        </button>
                        {recruitmentCount > 0 && <span className="activity-badge">{recruitmentCount}</span>}
                        {activeTooltip === 'recruitment' && (
                            <RecruitmentTooltip
                                playerCities={playerCities}
                                onCancelTrain={onCancelTrain}
                                isLocked={isTooltipLocked}
                                countdown={lockCountdown}
                            />
                        )}
                    </div>
                    <div className="relative" onMouseEnter={() => handleMouseEnter('trades')} onClick={(e) => handleTooltipClick(e, 'trades')}>
                         <button className="activity-icon-image-container">
                            <img src={tradeicon} alt="Trade" className="activity-icon-image" />
                        </button>
                        {tradeCount > 0 && <span className="activity-badge">{tradeCount}</span>}
                        {activeTooltip === 'trades' && (
                            <TradesTooltip
                                movements={movements}
                                combinedSlots={combinedSlots}
                                onCancel={onCancelMovement}
                                isLocked={isTooltipLocked}
                                countdown={lockCountdown}
                            />
                        )}
                    </div>
                     <div className="relative" onMouseEnter={() => handleMouseEnter('movements')} onClick={(e) => handleTooltipClick(e, 'movements')}>
                        <button onClick={(e) => { e.stopPropagation(); onOpenMovements(); }} className={`activity-icon-image-container ${isUnderAttack ? 'glowing-attack-icon' : ''}`}>
                            <img src={movementicon} alt="Movement" className="activity-icon-image" />
                        </button>
                        {movementCount > 0 && <span className="activity-badge">{movementCount}</span>}
                        {activeTooltip === 'movements' && (
                            <MovementsTooltip
                                movements={movements}
                                combinedSlots={combinedSlots}
                                onCancel={onCancelMovement}
                                isLocked={isTooltipLocked}
                                countdown={lockCountdown}
                            />
                        )}
                    </div>
                </div>
                <div
                    className="resource-display relative"
                    onMouseEnter={() => handleMouseEnter('wood')}
                    onClick={(e) => handleTooltipClick(e, 'wood')}
                >
                    <img src={woodImage} alt="Wood" className="w-6 h-6 mr-2"/>
                    <span className="text-yellow-800 font-bold">{Math.floor(resources.wood || 0)}</span>
                    {activeTooltip === 'wood' && productionRates && getWarehouseCapacity && (
                        <ResourceTooltip
                            resource="wood"
                            production={productionRates.wood}
                            capacity={getWarehouseCapacity(gameState.buildings.warehouse.level)}
                            isLocked={isTooltipLocked}
                            countdown={lockCountdown}
                        />
                    )}
                </div>
                <div
                    className="resource-display relative"
                    onMouseEnter={() => handleMouseEnter('stone')}
                    onClick={(e) => handleTooltipClick(e, 'stone')}
                >
                    <img src={stoneImage} alt="Stone" className="w-6 h-6 mr-2"/>
                    <span className="text-gray-600 font-bold">{Math.floor(resources.stone || 0)}</span>
                     {activeTooltip === 'stone' && productionRates && getWarehouseCapacity && (
                        <ResourceTooltip
                            resource="stone"
                            production={productionRates.stone}
                            capacity={getWarehouseCapacity(gameState.buildings.warehouse.level)}
                            isLocked={isTooltipLocked}
                            countdown={lockCountdown}
                        />
                    )}
                </div>
                <div
                    className="resource-display relative"
                    onMouseEnter={() => handleMouseEnter('silver')}
                    onClick={(e) => handleTooltipClick(e, 'silver')}
                >
                    <img src={silverImage} alt="Silver" className="w-6 h-6 mr-2"/>
                    <span className="text-blue-800 font-bold">{Math.floor(resources.silver || 0)}</span>
                     {activeTooltip === 'silver' && productionRates && getWarehouseCapacity && (
                        <ResourceTooltip
                            resource="silver"
                            production={productionRates.silver}
                            capacity={getWarehouseCapacity(gameState.buildings.warehouse.level)}
                            isLocked={isTooltipLocked}
                            countdown={lockCountdown}
                        />
                    )}
                </div>
                <div className="resource-display">
                    <img src={populationImage} alt="Population" className="w-6 h-6 mr-2"/>
                    <span className="font-bold text-red-800">{Math.floor(availablePopulation || 0)}</span>
                </div>
                <div
                    className="resource-display relative"
                    onMouseEnter={() => handleMouseEnter('happiness')}
                    onClick={(e) => handleTooltipClick(e, 'happiness')}
                >
                    <span className="text-xl mr-2">{happinessIcon}</span>
                    <span className="font-bold text-green-800">{happiness}%</span>
                    {activeTooltip === 'happiness' && (
                        <div className="resource-tooltip happiness-tooltip">
                            <pre>{happinessTooltip}</pre>
                            <div className="tooltip-lock-timer">
                                {isTooltipLocked ? '🔒' : lockCountdown}
                            </div>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default TopBar;
</file>

<file path="src/components/map/TradePanel.js">
// src/components/map/TradePanel.js
import React from 'react';
import woodImage from '../../images/resources/wood.png';
import stoneImage from '../../images/resources/stone.png';
import silverImage from '../../images/resources/silver.png';

const TradePanel = ({ selectedResources, currentResources, handleResourceChange }) => {
    const resourceImages = {
        wood: woodImage,
        stone: stoneImage,
        silver: silverImage,
    };


    return (
        <div className="unit-selection-section space-y-2">
            <h4 className="font-bold text-lg text-yellow-700 mb-2">Select Resources</h4>
            <div className="flex justify-around items-end w-full">
                {Object.keys(selectedResources).map(resource =>
                    <div key={resource} className="flex flex-col items-center">
                        <img
                            src={resourceImages[resource]}
                            alt={resource}
                            className="w-12 h-12 mb-1 bg-black/10 rounded"
                        />
                        <input
                            type="number"
                            value={selectedResources[resource] || 0}
                            onChange={(e) => handleResourceChange(resource, e.target.value)}
                            className="bg-white/50 border border-yellow-800/50 p-1 rounded text-gray-800 text-center w-20 hide-number-spinners"
                            min="0"
                            max={currentResources[resource]}
                        />
                    </div>
                )}
            </div>
        </div>
    );
};

export default TradePanel;
</file>

<file path="src/components/map/TradesToolTip.css">
/* src/components/map/TradesTooltip.css */
.activity-tooltip {
    position: absolute;
    top: calc(100% + 10px);
    left: 50%; /* #comment Center the tooltip */
    transform: translateX(-50%); /* #comment Adjust for centering */
    width: 450px; /* Wider to accommodate movement items */
    background-color: #F5DEB3;
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    z-index: 100;
    color: #4a2c2a;
    /* #comment Removed conflicting relative positioning */
}

.activity-tooltip .movements-header {
    background-color: #3b82f6;
    color: white;
    padding: 0.5rem 1rem;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.25rem;
    border-bottom: 2px solid #2563eb;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

.tooltip-lock-timer {
    position: absolute;
    bottom: -14px; /* #comment Position half outside */
    right: -14px; /* #comment Position half outside */
    width: 28px;
    height: 28px;
    background-color: #4a2c2a;
    color: #f0e68c;
    border: 2px solid #8B4513;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: bold;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
</file>

<file path="src/components/map/TradesToolTip.js">
// src/components/map/TradesToolTip.js
import React from 'react';
import MovementItem from './MovementItem';
import './TradesToolTip.css';

const TradesTooltip = ({ movements, combinedSlots, onCancel, isLocked, countdown }) => {
    // #comment Helper to identify if a movement is trade-related
    const isTradeMovement = (m) => {
        if (m.type === 'trade') return true;
        // It's also a trade if it's a returning trip carrying only resources
        if (m.status === 'returning' && m.resources && Object.values(m.resources).some(r => r > 0)) {
            if (!m.units || Object.values(m.units).every(count => count === 0)) {
                return true;
            }
        }
        return false;
    };

    const tradeMovements = movements.filter(isTradeMovement);

    return (
        <div className="activity-tooltip">
            {tradeMovements.length > 0 ? (
                tradeMovements.map(movement => (
                    <MovementItem
                        key={movement.id}
                        movement={movement}
                        citySlots={combinedSlots}
                        onCancel={onCancel}
                    />
                ))
            ) : (
                <p className="p-4 text-center text-sm">No active trade movements.</p>
            )}
            <div className="tooltip-lock-timer">
                {isLocked ? '🔒' : countdown}
            </div>
        </div>
    );
};

export default TradesTooltip;
</file>

<file path="src/components/MapView.js">
import React, { useRef, useMemo, useCallback, useEffect, useState } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { useGame } from '../contexts/GameContext';
import { useAlliance } from '../contexts/AllianceContext';
import { db } from '../firebase/config';
import { doc, updateDoc, writeBatch, serverTimestamp, getDoc, collection, getDocs, query,orderBy, onSnapshot, where, collectionGroup } from 'firebase/firestore';
import island1 from '../images/islands/island_1.png';
import island2 from '../images/islands/island_2.png';
import SidebarNav from './map/SidebarNav';
import TopBar from './map/TopBar';
import MapGrid from './map/MapGrid';
import MapModals from './map/MapModals';
import SideInfoPanel from './SideInfoPanel';
import DivinePowers from './city/DivinePowers';
import QuestsButton from './QuestsButton';
import MapOverlay from './map/MapOverlay';
import WithdrawModal from './city/WithdrawModal';
import WonderBuilderModal from './alliance/WonderBuilderModal';
import WonderProgressModal from './alliance/WonderProgressModal';
import Modal from './shared/Modal';
import allianceWonders from '../gameData/alliance_wonders.json';
import { useMapInteraction } from '../hooks/useMapInteraction';
import { useMapData } from '../hooks/usemapdatapls';
import { useMapActions } from '../hooks/useMapActions';
import { useCityState } from '../hooks/useCityState';
import { useMapState } from '../hooks/useMapState';
import { useMapClickHandler } from '../hooks/useMapClickHandler';
import buildingConfig from '../gameData/buildings.json';

const TILE_SIZE = 32;
let mapViewCache = {
    cityPoints: null,
    scoutedCities: null,
    timestamp: 0,
};

const islandImageMap = {
    'island_1.png': island1,
    'island_2.png': island2,
};

const MapView = ({
    showCity,
    openModal,
    closeModal,
    modalState,
    unreadReportsCount,
    unreadMessagesCount,
    quests,
    claimReward,
    handleMessageAction,
    panToCoords,
    setPanToCoords,
    handleGoToCityFromProfile,
    movements,
    onCancelTrain,
    onCancelMovement,
    isUnderAttack,
    incomingAttackCount,
    onRenameCity,
    centerOnCity,
    onGodTownClick,
    handleOpenEvents,
    onSwitchCity,
    battlePoints,
    initialMapAction,
    setInitialMapAction,
    onOpenManagementPanel,
}) => {
    const { currentUser, userProfile } = useAuth();
    const { worldState, gameState, setGameState, worldId, playerCity, playerCities, conqueredVillages, conqueredRuins, gameSettings, activeCityId, playerCityPoints } = useGame();
    const { playerAlliance } = useAlliance();
    const viewportRef = useRef(null);
    const mapContainerRef = useRef(null);
    const { isPlacingDummyCity, setIsPlacingDummyCity } = useMapState();
    const { pan, zoom, viewportSize, borderOpacity, isPanning, handleMouseDown, goToCoordinates } = useMapInteraction(viewportRef, mapContainerRef, worldState, playerCity, centerOnCity);
    const { visibleSlots, visibleVillages, visibleRuins, invalidateChunkCache } = useMapData(currentUser, worldId, worldState, pan, zoom, viewportSize);
    const [message, setMessage] = useState('');
    const { travelTimeInfo, setTravelTimeInfo, handleActionClick, handleSendMovement, handleCreateDummyCity, handleWithdrawTroops, handleFoundCity } = useMapActions(openModal, closeModal, showCity, invalidateChunkCache, setMessage);
    const { getFarmCapacity, calculateUsedPopulation, calculateHappiness, getMarketCapacity, calculateTotalPoints, getProductionRates, getWarehouseCapacity } = useCityState(worldId);
    const [cityPoints, setCityPoints] = useState({});
    const [scoutedCities, setScoutedCities] = useState({});
    const [mouseCoords, setMouseCoords] = useState({ x: 0, y: 0 });
    const [controlledIslands, setControlledIslands] = useState({});
    const [wonderSpots, setWonderSpots] = useState({});
    const [wonderBuilderData, setWonderBuilderData] = useState(null);
    const [wonderProgressData, setWonderProgressData] = useState(null);
    const [allCitySlots, setAllCitySlots] = useState(null);
    const [godTowns, setGodTowns] = useState({});
    const [allWonders, setAllWonders] = useState([]);
    const [wonderInfo, setWonderInfo] = useState(null);

    const handleEnterCity = (cityId) => {
        onSwitchCity(cityId);
        showCity();
        closeModal('city');
    };

    useEffect(() => {
        if (!worldId) return;
        const wondersQuery = query(collection(db, 'worlds', worldId, 'alliances'), where('allianceWonder', '!=', null));
        const unsubscribe = onSnapshot(wondersQuery, (snapshot) => {
            const wonders = [];
            snapshot.forEach(doc => {
                wonders.push({
                    ...doc.data().allianceWonder,
                    allianceName: doc.data().name,
                    allianceTag: doc.data().tag,
                    allianceId: doc.id
                });
            });
            setAllWonders(wonders);
        });
        return () => unsubscribe();
    }, [worldId]);

    useEffect(() => {
        if (!worldId) return;
        const citySlotsRef = collection(db, 'worlds', worldId, 'citySlots');
        const unsubscribe = onSnapshot(citySlotsRef, (snapshot) => {
            const slots = {};
            snapshot.forEach(doc => {
                slots[doc.id] = { id: doc.id, ...doc.data() };
            });
            setAllCitySlots(slots);
        });

        const godTownsColRef = collection(db, 'worlds', worldId, 'godTowns');
        const unsubscribeGodTowns = onSnapshot(godTownsColRef, (snapshot) => {
            const townsData = {};
            snapshot.docs.forEach(doc => {
                townsData[doc.id] = { id: doc.id, ...doc.data() };
            });
            setGodTowns(townsData);
        });

        return () => {
            unsubscribe();
            unsubscribeGodTowns();
        };
    }, [worldId]);

    useEffect(() => {
        const viewport = viewportRef.current;
        if (!viewport) return;
        const handleMouseMove = (e) => {
            const rect = viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const mapX = Math.floor((-pan.x + mouseX) / (32 * zoom));
            const mapY = Math.floor((-pan.y + mouseY) / (32 * zoom));
            setMouseCoords({ x: mapX, y: mapY });
        };
        viewport.addEventListener('mousemove', handleMouseMove);
        return () => viewport.removeEventListener('mousemove', handleMouseMove);
    }, [pan, zoom]);

    const fetchAllCityPoints = useCallback(async () => {
        if (!worldId || !worldState) return {};
        const points = {};
        const gamesGroupRef = collectionGroup(db, 'games');
        const q = query(gamesGroupRef, where('worldName', '==', worldState.name));
        const gamesSnapshot = await getDocs(q);
        for (const gameDoc of gamesSnapshot.docs) {
            const userId = gameDoc.ref.parent.parent.id;
            if (userId === currentUser.uid) continue;
            const citiesRef = collection(db, `users/${userId}/games`, worldId, 'cities');
            const citiesSnapshot = await getDocs(citiesRef);
            for (const cityDoc of citiesSnapshot.docs) {
                const cityData = cityDoc.data();
                if (cityData.slotId) {
                    const totalPoints = calculateTotalPoints(cityData);
                    points[cityData.slotId] = totalPoints;
                }
            }
        }
        return points;
    }, [worldId, worldState, calculateTotalPoints, currentUser.uid]);

    const fetchScoutedData = useCallback(async () => {
        if (!currentUser || !worldId) return {};
        const reportsRef = collection(db, 'users', currentUser.uid, 'worlds', worldId, 'reports');
        const q = query(reportsRef, orderBy('timestamp', 'desc'));
        const snapshot = await getDocs(q);
        const latestScouts = {};
        snapshot.forEach(doc => {
            const report = doc.data();
            if (report.type === 'scout' && report.scoutSucceeded) {
                const targetId = report.targetSlotId;
                if (targetId && !latestScouts[targetId]) {
                    latestScouts[targetId] = report.units;
                }
            }
        });
        return latestScouts;
    }, [currentUser, worldId]);

    useEffect(() => {
        const now = Date.now();
        const CACHE_DURATION = 15 * 60 * 1000;
        if (now - mapViewCache.timestamp < CACHE_DURATION && mapViewCache.cityPoints) {
            setCityPoints(mapViewCache.cityPoints);
            setScoutedCities(mapViewCache.scoutedCities);
        } else {
            const fetchData = async () => {
                const pointsData = await fetchAllCityPoints();
                const scoutedData = await fetchScoutedData();
                setCityPoints(pointsData);
                setScoutedCities(scoutedData);
                mapViewCache = {
                    cityPoints: pointsData,
                    scoutedCities: scoutedData,
                    timestamp: now,
                };
            };
            fetchData();
        }
    }, [fetchAllCityPoints, fetchScoutedData]);

    useEffect(() => {
        if (panToCoords) {
            goToCoordinates(panToCoords.x, panToCoords.y);
            setPanToCoords(null);
        }
    }, [panToCoords, goToCoordinates, setPanToCoords]);

    const { onCitySlotClick, onVillageClick, onRuinClick } = useMapClickHandler({
        playerCity,
        isPlacingDummyCity,
        handleCreateDummyCity,
        setTravelTimeInfo,
        openModal,
        closeModal,
        setMessage,
        conqueredVillages,
        conqueredRuins,
        cityGameState: gameState,
    });

    const { availablePopulation, happiness, marketCapacity } = useMemo(() => {
        if (!gameState?.buildings) return { availablePopulation: 0, happiness: 0, marketCapacity: 0 };
        const maxPop = getFarmCapacity(gameState.buildings.farm?.level);
        const usedPop = calculateUsedPopulation(gameState.buildings, gameState.units, gameState.specialBuilding);
        const availablePop = maxPop - usedPop;
        const happinessValue = calculateHappiness(gameState.buildings);
        const marketCap = getMarketCapacity(gameState.buildings.market?.level);
        return { availablePopulation: availablePop, happiness: happinessValue, marketCapacity: marketCap };
    }, [gameState, getFarmCapacity, calculateUsedPopulation, calculateHappiness, getMarketCapacity]);

    const productionRates = useMemo(() => {
        if (!gameState) return { wood: 0, stone: 0, silver: 0 };
        return getProductionRates(gameState.buildings);
    }, [gameState, getProductionRates]);

    const handleOpenAlliance = () => openModal('alliance');

    const combinedSlots = useMemo(() => {
        const newSlots = { ...visibleSlots };
        for (const cityId in playerCities) {
            const pCity = playerCities[cityId];
            if (pCity && pCity.slotId) {
                const existingSlotData = newSlots[pCity.slotId] || {};
                newSlots[pCity.slotId] = {
                    ...existingSlotData,
                    ...pCity,
                    ownerId: currentUser.uid,
                    ownerUsername: userProfile.username
                };
            }
        }
        return newSlots;
    }, [visibleSlots, playerCities, currentUser.uid, userProfile.username]);

    useEffect(() => {
        if (initialMapAction?.type === 'open_city_modal') {
            const { coords } = initialMapAction;
            const targetX = parseFloat(coords.x);
            const targetY = parseFloat(coords.y);
            const citySlot = Object.values(combinedSlots).find(
                slot => slot.x === targetX && slot.y === targetY
            );
            if (citySlot) {
                onCitySlotClick(null, citySlot);
            }
            setInitialMapAction(null);
        }
    }, [initialMapAction, setInitialMapAction, combinedSlots, onCitySlotClick]);

    const combinedLocations = useMemo(() => ({ ...combinedSlots, ...visibleVillages, ...visibleRuins }), [combinedSlots, visibleVillages, visibleRuins]);

    const handleRushMovement = useCallback(async (movementId) => {
        if (userProfile?.is_admin) {
            await updateDoc(doc(db, 'worlds', worldId, 'movements', movementId), { arrivalTime: new Date() });
        }
    }, [userProfile, worldId]);

    const handleToggleDummyCityPlacement = () => {
        setIsPlacingDummyCity(prev => !prev);
        setMessage(isPlacingDummyCity ? 'Dummy city placement OFF.' : 'Dummy city placement ON.');
    };

    const handleCastSpell = async (power, targetCity) => {
        const currentState = gameState;
        if (!currentState?.god || (currentState.worship[currentState.god] || 0) < power.favorCost) {
            setMessage("Not enough favor.");
            return;
        }
        const batch = writeBatch(db);
        const casterGameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);
        const newWorship = { ...currentState.worship, [currentState.god]: currentState.worship[currentState.god] - power.favorCost };
        batch.update(casterGameDocRef, { worship: newWorship });
        const isSelfCast = !targetCity;
        const targetOwnerId = isSelfCast ? currentUser.uid : targetCity.ownerId;
        const targetGameDocRef = doc(db, `users/${targetOwnerId}/games`, worldId);
        const targetGameSnap = await getDoc(targetGameDocRef);
        if (!targetGameSnap.exists()) {
            setMessage("Target city's data not found.");
            await batch.commit();
            setGameState({ ...gameState, worship: newWorship });
            return;
        }
        const targetGameState = targetGameSnap.data();
        let spellEffectMessage = '', casterMessage = '';
        switch (power.effect.type) {
            case 'add_resources':
            case 'add_multiple_resources': {
                const resourcesToAdd = power.effect.type === 'add_resources' ? { [power.effect.resource]: power.effect.amount } : power.effect.resources;
                const newResources = { ...targetGameState.resources };
                let resourcesReceivedMessage = [];
                for (const resource in resourcesToAdd) {
                    newResources[resource] = (newResources[resource] || 0) + resourcesToAdd[resource];
                    resourcesReceivedMessage.push(`${resourcesToAdd[resource]} ${resource}`);
                }
                batch.update(targetGameDocRef, { resources: newResources });
                casterMessage = isSelfCast ? `You blessed yourself with ${resourcesReceivedMessage.join(' & ')}!` : `You blessed ${targetGameState.cityName} with ${resourcesReceivedMessage.join(' & ')}.`;
                if (!isSelfCast) spellEffectMessage = `Your city ${targetGameState.cityName} was blessed with ${resourcesReceivedMessage.join(' & ')} by ${userProfile.username}!`;
                break;
            }
            case 'damage_building': {
                if (isSelfCast) break;
                const buildings = { ...targetGameState.buildings };
                const buildingKeys = Object.keys(buildings).filter(b => buildings[b].level > 0);
                if (buildingKeys.length > 0) {
                    const randomBuildingKey = buildingKeys[Math.floor(Math.random() * buildingKeys.length)];
                    buildings[randomBuildingKey].level = Math.max(0, buildings[randomBuildingKey].level - power.effect.amount);
                    spellEffectMessage = `Your ${buildingConfig[randomBuildingKey]?.name} in ${targetGameState.cityName} was damaged by divine power from ${userProfile.username}!`;
                    casterMessage = `You damaged a building in ${targetGameState.cityName}.`;
                    batch.update(targetGameDocRef, { buildings });
                } else {
                    casterMessage = `You tried to damage a building in ${targetGameState.cityName}, but there were none.`;
                }
                break;
            }
            default: setMessage("Spell effect not implemented."); return;
        }
        const casterReport = { type: 'spell_cast', title: `Spell cast: ${power.name}`, timestamp: serverTimestamp(), outcome: { message: casterMessage }, read: false };
        batch.set(doc(collection(db, `users/${currentUser.uid}/reports`)), casterReport);
        if (!isSelfCast) {
            const targetReport = { type: 'spell_received', title: `Divine Intervention!`, timestamp: serverTimestamp(), outcome: { message: spellEffectMessage, from: playerCity.cityName }, read: false };
            batch.set(doc(collection(db, `users/${targetOwnerId}/reports`)), targetReport);
        }
        try {
            await batch.commit();
            setMessage(`${power.name} has been cast!`);
            closeModal('divinePowers');
            if (isSelfCast) setGameState((await getDoc(casterGameDocRef)).data());
            else setGameState({ ...gameState, worship: newWorship });
        } catch (error) {
            console.error("Error casting spell:", error);
            setMessage("Failed to cast spell.");
        }
    };
    const handleGoToActiveCity = () => {
        if (activeCityId) {
            showCity(activeCityId);
        } else {
            setMessage("No active city to view.");
        }
    };
    const handleOpenWithdrawModal = (city) => {
        openModal('withdraw', city);
    };
    useEffect(() => {
        if (!worldState?.islands || !allCitySlots) {
            return;
        }
        const islandSlotCounts = {};
        const islandAllianceCounts = {};
        worldState.islands.forEach(island => {
            islandSlotCounts[island.id] = 0;
            islandAllianceCounts[island.id] = {};
        });
        Object.values(allCitySlots).forEach(slot => {
            if (slot.islandId && islandSlotCounts.hasOwnProperty(slot.islandId)) {
                islandSlotCounts[slot.islandId]++;
                if (slot.ownerId && slot.alliance) {
                    const allianceTag = slot.alliance;
                    if (!islandAllianceCounts[slot.islandId][allianceTag]) {
                        islandAllianceCounts[slot.islandId][allianceTag] = 0;
                    }
                    islandAllianceCounts[slot.islandId][allianceTag]++;
                }
            }
        });
        const newControlledIslands = {};
        for (const islandId in islandSlotCounts) {
            if (islandSlotCounts[islandId] > 0) {
                for (const allianceTag in islandAllianceCounts[islandId]) {
                    if (islandAllianceCounts[islandId][allianceTag] === islandSlotCounts[islandId]) {
                        newControlledIslands[islandId] = allianceTag;
                    }
                }
            }
        }
        setControlledIslands(newControlledIslands);
    }, [worldState, allCitySlots]);
    useEffect(() => {
        if (!worldState?.islands || !allCitySlots || !visibleVillages) {
            setWonderSpots({});
            return;
        }
        const newSpots = {};
        worldState.islands.forEach(island => {
            if (allWonders.some(w => w.islandId === island.id)) return;
            const centerX = Math.round(island.x);
            const centerY = Math.round(island.y);
            let bestSpot = null;
            let fallbackSpot = null;
            for (let r = 0; r < island.radius * 2 && !bestSpot; r++) {
                for (let dx = -r; dx <= r && !bestSpot; dx++) {
                    for (let dy = -r; dy <= r; dy++) {
                        if (dx*dx + dy*dy > r*r) continue;
                        const x = centerX + dx;
                        const y = centerY + dy;
                        if (x < 0 || x >= worldState.width || y < 0 || y >= worldState.height) continue;
                        const distSq = Math.pow(x - island.x, 2) + Math.pow(y - island.y, 2);
                        if (distSq > Math.pow(island.radius, 2)) continue;
                        const isCitySlot = Object.values(allCitySlots).some(s => s && s.x === x && s.y === y);
                        if (isCitySlot) continue;
                        const isVillage = Object.values(visibleVillages).some(v => v && v.x === x && v.y === y);
                        if (!isVillage) {
                            bestSpot = { x, y, islandId: island.id };
                            break;
                        } else if (!fallbackSpot) {
                            fallbackSpot = { x, y, islandId: island.id };
                        }
                    }
                }
            }
            const finalSpot = bestSpot || fallbackSpot;
            if (finalSpot) {
                newSpots[island.id] = finalSpot;
            }
        });
        setWonderSpots(newSpots);
    }, [worldState, allCitySlots, visibleVillages, allWonders]);
    const handleWonderSpotClick = (spotData) => {
        if (playerAlliance?.leader?.uid !== currentUser.uid) {
            setMessage("Only the alliance leader can begin construction of a wonder.");
            return;
        }
        if (playerAlliance.allianceWonder) {
            setMessage("Your alliance is already building a wonder elsewhere.");
            return;
        }
        setWonderBuilderData({ islandId: spotData.islandId, coords: { x: spotData.x, y: spotData.y } });
    };
    const handleConstructingWonderClick = (wonderData) => {
        if (playerAlliance && playerAlliance.id === wonderData.allianceId) {
            setWonderProgressData(wonderData);
        } else {
            const wonderConfig = allianceWonders[wonderData.id];
            setWonderInfo({
                title: wonderConfig.name,
                message: `Level ${wonderData.level}. Being built by ${wonderData.allianceName} [${wonderData.allianceTag}].`
            });
        }
    };
    const mapGrid = useMemo(() => {
        if (!worldState?.islands) return null;
        const grid = Array(worldState.height).fill(null).map(() => Array(worldState.width).fill({ type: 'water' }));
        worldState.islands.forEach(island => {
            if (!island.imageName) {
                const centerX = Math.round(island.x), centerY = Math.round(island.y);
                for (let i = -Math.floor(island.radius); i <= Math.ceil(island.radius); i++) {
                    for (let j = -Math.floor(island.radius); j <= Math.ceil(island.radius); j++) {
                        if (i * i + j * j <= island.radius * island.radius) {
                            const x = centerX + j, y = centerY + i;
                            if (y >= 0 && y < worldState.height && x >= 0 && x < worldState.width) {
                                grid[y][x] = { type: 'land', data: { hasImage: false } };
                            }
                        }
                    }
                }
            }
        });
        const mergeWithGrid = (items, type) => {
            Object.values(items).forEach(item => {
                if (item.x !== undefined && item.y !== undefined) {
                    const x = Math.round(item.x), y = Math.round(item.y);
                    if (y >= 0 && y < worldState.height && x >= 0 && x < worldState.width) {
                         if (!grid[y][x] || grid[y][x].type === 'water') {
                            grid[y][x] = { type: 'land', data: { hasImage: true } };
                        }
                        grid[y][x] = { type, data: { ...item, ...grid[y][x].data } };
                    }
                }
            });
        };
        mergeWithGrid(combinedSlots, 'city_slot');
        mergeWithGrid(visibleVillages, 'village');
        Object.values(visibleRuins).forEach(ruin => {
            const x = Math.round(ruin.x), y = Math.round(ruin.y);
            if (grid[y]?.[x]) grid[y][x] = { type: 'ruin', data: ruin };
        });
        Object.values(godTowns).forEach(town => {
            const x = Math.round(town.x), y = Math.round(town.y);
            if (grid[y]?.[x]) {
                grid[y][x] = { type: 'god_town', data: town };
            }
        });
        Object.values(wonderSpots).forEach(spot => {
            if (grid[spot.y]?.[spot.x]) {
                grid[spot.y][spot.x] = { type: 'wonder_spot', data: spot };
            }
        });
        allWonders.forEach(wonder => {
            if (wonder.x !== undefined && grid[wonder.y]?.[wonder.x]) {
                grid[wonder.y][wonder.x] = { type: 'constructing_wonder', data: wonder };
            }
        });
        return grid;
    }, [worldState, combinedSlots, visibleVillages, visibleRuins, godTowns, wonderSpots, allWonders]);
    const combinedCityPoints = useMemo(() => {
        return { ...cityPoints, ...playerCityPoints };
    }, [cityPoints, playerCityPoints]);
    return (
        <div className="w-full h-screen flex flex-col bg-gray-900 map-view-wrapper relative">
            {isUnderAttack && <div className="screen-glow-attack"></div>}
            <QuestsButton
                onOpenQuests={() => openModal('quests')}
                quests={quests}
            />
            <div className="flex-grow flex flex-row overflow-visible">
                <div className="main-content flex-grow relative map-surface">
                    <TopBar
                        view="map"
                        gameState={gameState}
                        availablePopulation={availablePopulation}
                        happiness={happiness}
                        worldState={worldState}
                        productionRates={productionRates}
                        getWarehouseCapacity={getWarehouseCapacity}
                        movements={movements}
                        onCancelTrain={onCancelTrain}
                        onCancelMovement={onCancelMovement}
                        combinedSlots={combinedLocations}
                        onOpenMovements={() => openModal('movements')}
                        isUnderAttack={isUnderAttack}
                        incomingAttackCount={incomingAttackCount}
                        onRenameCity={onRenameCity}
                        onSwitchCity={onSwitchCity}
                        battlePoints={battlePoints}
                    />
                    <SidebarNav
                        onToggleView={handleGoToActiveCity}
                        view="map"
                        onOpenReports={() => openModal('reports')}
                        onOpenAlliance={handleOpenAlliance}
                        onOpenForum={() => openModal('allianceForum')}
                        onOpenMessages={() => openModal('messages')}
                        onOpenSettings={() => openModal('settings')}
                        onOpenProfile={() => openModal('profile')}
                        onOpenLeaderboard={() => openModal('leaderboard')}
                        onOpenQuests={() => openModal('quests')}
                        unreadReportsCount={unreadReportsCount}
                        unreadMessagesCount={unreadMessagesCount}
                        isAdmin={userProfile?.is_admin}
                        onToggleDummyCityPlacement={handleToggleDummyCityPlacement}
                        isAllianceMember={!!playerAlliance}
                        handleOpenEvents={handleOpenEvents}
                        onOpenManagementPanel={onOpenManagementPanel}
                    />
                    <SideInfoPanel gameState={gameState} className="absolute top-1/2 right-4 transform -translate-y-1/2 z-20 flex flex-col gap-4" onOpenPowers={() => openModal('divinePowers')} movements={movements} />
                    <MapOverlay
                        mouseCoords={mouseCoords}
                        pan={pan}
                        zoom={zoom}
                        viewportSize={viewportSize}
                        worldState={worldState}
                        allCities={combinedSlots}
                        ruins={visibleRuins}
                        playerAlliance={playerAlliance}
                    />
                    <div className="map-viewport" ref={viewportRef} onMouseDown={handleMouseDown} style={{ cursor: isPanning ? 'grabbing' : (isPlacingDummyCity ? 'crosshair' : 'grab') }}>
                        <div className="map-border top" style={{ opacity: borderOpacity.top }}></div>
                        <div className="map-border bottom" style={{ opacity: borderOpacity.bottom }}></div>
                        <div className="map-border left" style={{ opacity: borderOpacity.left }}></div>
                        <div className="map-border right" style={{ opacity: borderOpacity.right }}></div>
                        <div className="absolute inset-0 z-0">
                            <div ref={mapContainerRef} className="map-surface" style={{ width: worldState?.width * 32, height: worldState?.height * 32, transformOrigin: '0 0' }}>
                                {worldState?.islands && gameSettings.showVisuals && worldState.islands.map(island => (
                                    island.imageName && <img
                                        key={island.id}
                                        src={islandImageMap[island.imageName]}
                                        alt={island.name}
                                        style={{
                                            position: 'absolute',
                                            left: (island.x - island.radius) * TILE_SIZE,
                                            top: (island.y - island.radius) * TILE_SIZE,
                                            width: island.radius * 2 * TILE_SIZE,
                                            height: island.radius * 2 * TILE_SIZE,
                                            pointerEvents: 'none',
                                            zIndex: 1,
                                            userSelect: 'none',
                                            WebkitUserSelect: 'none',
                                            MozUserSelect: 'none',
                                            msUserSelect: 'none',
                                            WebkitUserDrag: 'none',
                                            userDrag: 'none',
                                        }}
                                    />
                                ))}
                                <div style={{ position: 'relative', zIndex: 2 }}>
                                    <MapGrid
                                        mapGrid={mapGrid}
                                        worldState={worldState}
                                        pan={pan}
                                        zoom={zoom}
                                        viewportSize={viewportSize}
                                        onCitySlotClick={onCitySlotClick}
                                        onVillageClick={onVillageClick}
                                        onRuinClick={onRuinClick}
                                        onGodTownClick={onGodTownClick}
                                        onWonderSpotClick={handleWonderSpotClick}
                                        onConstructingWonderClick={handleConstructingWonderClick}
                                        isPlacingDummyCity={isPlacingDummyCity}
                                        movements={movements}
                                        combinedSlots={combinedSlots}
                                        villages={visibleVillages}
                                        ruins={visibleRuins}
                                        godTowns={godTowns}
                                        playerAlliance={playerAlliance}
                                        conqueredVillages={conqueredVillages}
                                        gameSettings={gameSettings}
                                        cityPoints={combinedCityPoints}
                                        scoutedCities={scoutedCities}
                                        controlledIslands={controlledIslands}
                                    />
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            {message && <Modal message={message} onClose={() => setMessage('')} />}
            {wonderInfo && <Modal title={wonderInfo.title} message={wonderInfo.message} onClose={() => setWonderInfo(null)} />}
            <MapModals
                modalState={modalState}
                closeModal={closeModal}
                gameState={gameState}
                playerCity={playerCity}
                travelTimeInfo={travelTimeInfo}
                handleSendMovement={handleSendMovement}
                handleCancelMovement={onCancelMovement}
                setMessage={setMessage}
                goToCoordinates={goToCoordinates}
                handleActionClick={handleActionClick}
                worldId={worldId}
                movements={movements}
                combinedSlots={combinedLocations}
                villages={visibleVillages}
                handleRushMovement={handleRushMovement}
                userProfile={userProfile}
                onCastSpell={handleCastSpell}
                onActionClick={handleMessageAction}
                marketCapacity={marketCapacity}
                onEnterCity={handleEnterCity}
                onSwitchCity={onSwitchCity}
                onWithdraw={handleOpenWithdrawModal}
                onFoundCity={handleFoundCity}
            />
            {modalState.isDivinePowersOpen && <DivinePowers godName={gameState.god} playerReligion={gameState.playerInfo.religion} favor={gameState.worship[gameState.god] || 0} onCastSpell={(power) => handleCastSpell(power, modalState.divinePowersTarget)} onClose={() => closeModal('divinePowers')} targetType={modalState.divinePowersTarget ? 'other' : 'self'} />}
            {modalState.isWithdrawModalOpen && (
                <WithdrawModal
                    city={modalState.withdrawModalData}
                    onClose={() => closeModal('withdraw')}
                    onWithdrawTroops={handleWithdrawTroops}
                />
            )}
            {wonderBuilderData && <WonderBuilderModal onClose={() => setWonderBuilderData(null)} {...wonderBuilderData} />}
            {wonderProgressData && <WonderProgressModal onClose={() => setWonderProgressData(null)} />}
        </div>
    );
};

export default MapView;
</file>

<file path="src/components/messaging/MessagesView.css">
.papyrus-bg {
    background-image: url('../../images/bg/messages_bg.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    background-position: center;
    color: #4a2c2a;
    width: 1000px;
    height: 650px;
    display: flex;
    flex-direction: column;
    background-color: transparent;
    border: none;
    padding: 20px 35px 50px 35px;
    position: fixed;
    z-index: 50;
}
.messages-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 0 10px 0;
    background-color: transparent;
    color: #f0e68c;
    border-bottom: none;
    height: 50px;
    cursor: move;
}
.messages-body {
    display: flex;
    flex-grow: 1;
    overflow: hidden;
    margin-top: 1rem;
}
.messages-left-panel {
    width: 35%;
    display: flex;
    flex-direction: column;
    padding-right: 1rem;
}
.messages-right-panel {
    width: 65%;
    padding-left: 1rem;
    border-left: 2px solid #a17c48;
    display: flex;
    flex-direction: column;
}
.papyrus-text {
    color: #4a2c2a;
    font-family: 'Kalam', cursive;
}
.papyrus-header {
    font-family: 'IM Fell English SC', serif;
    font-size: 1.5rem;
    color: #f0e68c;
}
.papyrus-input {
    background-color: transparent;
    border-bottom: 2px solid #8B4513;
    color: #4a2c2a;
}
.papyrus-input:focus {
    outline: none;
    border-color: #5D4037;
}
.papyrus-input::placeholder {
    color: #856a69;
}
.papyrus-btn {
    background-color: #8B4513;
    color: #F5DEB3;
    font-weight: bold;
    border-radius: 2px;
    padding: 0.5rem 1rem;
    transition: all 0.2s;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
.papyrus-btn:hover {
    background-color: #A0522D;
}
.papyrus-list-item {
    padding: 0.75rem;
    cursor: pointer;
    border: 1px solid #a17c48;
    margin-top: -1px;
    color: #4a2c2a;
}
.papyrus-list-item:hover {
    background-color: rgba(139, 69, 19, 0.1);
}
.papyrus-list-item.selected {
    background-color: rgba(139, 69, 19, 0.2);
}
.papyrus-list-item.unread {
    font-weight: bold;
    color: #000;
}
.glowing-message {
    animation: glowing-message-animation 1.5s infinite;
}
@keyframes glowing-message-animation {
    0% {
        box-shadow: 0 0 3px #fde047;
    }
    50% {
        box-shadow: 0 0 10px #fef08a, 0 0 5px #fef08a;
    }
    100% {
        box-shadow: 0 0 3px #fde047;
    }
}
.papyrus-message-sent {
    background-color: rgba(211, 184, 144, 0.8);
    border-radius: 0.5rem;
    padding: 0.75rem;
    max-width: 80%;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.papyrus-message-received {
    background-color: rgba(230, 203, 168, 0.8);
    border-radius: 0.5rem;
    padding: 0.75rem;
    max-width: 80%;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.bbcode-action {
    color: #1e3a8a;
    font-weight: bold;
    text-decoration: underline;
    cursor: pointer;
}
.bbcode-action:hover {
    color: #3b82f6;
}
</file>

<file path="src/components/messaging/MessagesView.js">
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { db } from '../../firebase/config';
import { collection, query, where, onSnapshot, addDoc, serverTimestamp, orderBy, doc, getDoc, setDoc, getDocs, updateDoc, arrayUnion } from 'firebase/firestore';
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { parseBBCode } from '../../utils/bbcodeParser';
import SharedReportView from '../SharedReportView';
import ReactDOM from 'react-dom';
import './MessagesView.css';
import TextEditor from '../shared/TextEditor';
import { playerCache } from '../alliance/AllianceInvitations';
const MessagesView = ({ onClose, initialRecipientId = null, initialRecipientUsername = null, onActionClick }) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId } = useGame();
    const [conversations, setConversations] = useState([]);
    const [selectedConversation, setSelectedConversation] = useState(null);
    const [messages, setMessages] = useState([]);
    const [newMessage, setNewMessage] = useState('');
    const [newRecipient, setNewRecipient] = useState('');
    const [isComposing, setIsComposing] = useState(false);
    const messagesEndRef = useRef(null);
    const messageContainerRef = useRef(null); // Ref for the message container
    const messagesViewRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 1000) / 2,
        y: (window.innerHeight - 650) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
    // Autocomplete states
    const [allPlayers, setAllPlayers] = useState([]);
    const [suggestions, setSuggestions] = useState([]);

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('messages-header') || e.target.parentElement.classList.contains('messages-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);
    // #comment Fetch all players for autocomplete using the shared cache
    useEffect(() => {
        const fetchPlayers = async () => {
            const now = Date.now();
            const CACHE_DURATION = 10 * 60 * 1000; // 10 minutes
            if (now - playerCache.timestamp < CACHE_DURATION && playerCache.allPlayers) {
                setAllPlayers(playerCache.allPlayers);
            } else {
                const usersRef = collection(db, 'users');
                const snapshot = await getDocs(usersRef);
                const players = snapshot.docs
                    .map(doc => doc.data().username)
                    .filter(username => username !== userProfile.username);
                setAllPlayers(players);
                playerCache.allPlayers = players;
                playerCache.timestamp = now;
            }
        };
        fetchPlayers();
    }, [userProfile.username]);
    const handleCompose = useCallback(async (recipientId = null, recipientUsername = null) => {
        if (recipientId && recipientUsername) {
            const convoQuery = query(
                collection(db, 'worlds', worldId, 'conversations'),
                where('participants', 'in', [[currentUser.uid, recipientId], [recipientId, currentUser.uid]])
            );
            const convoSnapshot = await getDocs(convoQuery);
            if (!convoSnapshot.empty) {
                setSelectedConversation({ id: convoSnapshot.docs[0].id, ...convoSnapshot.docs[0].data() });
                setIsComposing(false);
                return;
            }
        }
        setSelectedConversation(null);
        setIsComposing(true);
        if (recipientUsername) {
            setNewRecipient(recipientUsername);
        }
    }, [currentUser, worldId]);
    useEffect(() => {
        if (!currentUser || !worldId) return;
        const conversationsQuery = query(
            collection(db, 'worlds', worldId, 'conversations'),
            where('participants', 'array-contains', currentUser.uid)
        );
        const unsubscribe = onSnapshot(conversationsQuery, (snapshot) => {
            const convos = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            convos.sort((a, b) => (b.lastMessage?.timestamp?.toDate() || 0) - (a.lastMessage?.timestamp?.toDate() || 0));
            setConversations(convos);
        });
        return () => unsubscribe();
    }, [currentUser, worldId]);
    useEffect(() => {
        if (initialRecipientId && initialRecipientUsername) {
            handleCompose(initialRecipientId, initialRecipientUsername);
        }
    }, [initialRecipientId, initialRecipientUsername, handleCompose]);
    useEffect(() => {
        if (selectedConversation) {
            const messagesQuery = query(
                collection(db, 'worlds', worldId, 'conversations', selectedConversation.id, 'messages'),
                orderBy('timestamp', 'asc')
            );
            const unsubscribe = onSnapshot(messagesQuery, (snapshot) => {
                const msgs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                setMessages(msgs);
            });
            const convoRef = doc(db, 'worlds', worldId, 'conversations', selectedConversation.id);
            updateDoc(convoRef, {
                readBy: arrayUnion(currentUser.uid)
            });
            return () => unsubscribe();
        }
    }, [selectedConversation, worldId, currentUser.uid]);
    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);
    useEffect(() => {
        if (messageContainerRef.current) {
            const placeholders = messageContainerRef.current.querySelectorAll('.shared-report-placeholder');
            placeholders.forEach(placeholder => {
                const reportId = placeholder.dataset.reportId;
                if (reportId) {
                    ReactDOM.render(<SharedReportView reportId={reportId} worldId={worldId} onClose={() => {}} isEmbedded={true} onActionClick={onActionClick} />, placeholder);
                }
            });
        }
    }, [messages, worldId, onActionClick]);
    const handleSelectConversation = async (convo) => {
        setSelectedConversation(convo);
        setIsComposing(false);
    };
    const getOtherParticipant = (convo) => {
        if (!convo || !convo.participants || !convo.participantUsernames) return 'Unknown';
        const otherId = convo.participants.find(p => p !== currentUser.uid);
        return convo.participantUsernames[otherId] || 'Unknown';
    };
    const isSystemChat = selectedConversation ? getOtherParticipant(selectedConversation) === 'System' : false;
    const handleSendMessage = async () => {
        if (isSystemChat) return;
        if (newMessage.trim() === '' || (!selectedConversation && !newRecipient)) return;
        let conversationId = selectedConversation?.id;
        if (isComposing) {
            if (newRecipient.toLowerCase() === 'system') {
                alert("You cannot send messages to the System.");
                return;
            }
            const recipientQuery = query(collection(db, 'users'), where('username', '==', newRecipient));
            const recipientSnapshot = await getDocs(recipientQuery);
            if (recipientSnapshot.empty) {
                alert('Recipient not found.');
                return;
            }
            const recipientData = recipientSnapshot.docs[0].data();
            const recipientId = recipientSnapshot.docs[0].id;
            if (recipientId === currentUser.uid) {
                alert("You cannot send a message to yourself.");
                return;
            }
            const convoQuery = query(
                collection(db, 'worlds', worldId, 'conversations'),
                where('participants', 'in', [[currentUser.uid, recipientId], [recipientId, currentUser.uid]])
            );
            const convoSnapshot = await getDocs(convoQuery);
            if (convoSnapshot.empty) {
                const newConvoRef = doc(collection(db, 'worlds', worldId, 'conversations'));
                await setDoc(newConvoRef, {
                    participants: [currentUser.uid, recipientId],
                    participantUsernames: {
                        [currentUser.uid]: userProfile.username,
                        [recipientId]: recipientData.username,
                    },
                    lastMessage: {
                        text: newMessage,
                        senderId: currentUser.uid,
                        timestamp: serverTimestamp(),
                    },
                    readBy: [currentUser.uid],
                });
                conversationId = newConvoRef.id;
            } else {
                conversationId = convoSnapshot.docs[0].id;
            }
        }
        const convoRef = doc(db, 'worlds', worldId, 'conversations', conversationId);
        await addDoc(collection(convoRef, 'messages'), {
            text: newMessage,
            senderId: currentUser.uid,
            senderUsername: userProfile.username,
            timestamp: serverTimestamp(),
        });
        await updateDoc(convoRef, {
            lastMessage: {
                text: newMessage,
                senderId: currentUser.uid,
                timestamp: serverTimestamp(),
            },
            readBy: [currentUser.uid],
        });
        setNewMessage('');
        if (isComposing) {
            setIsComposing(false);
            setNewRecipient('');
            const newConvo = await getDoc(convoRef);
            setSelectedConversation({ id: newConvo.id, ...newConvo.data() });
        }
    };
    const handleContentClick = (e) => {
        const target = e.target;
        if (target.classList.contains('bbcode-action') && onActionClick) {
            const { actionType, actionId, actionOwnerId, actionCoordsX, actionCoordsY } = target.dataset;
            if (actionType === 'city_link') {
                onActionClick(actionType, { cityId: actionId, ownerId: actionOwnerId, coords: { x: actionCoordsX, y: actionCoordsY } });
            } else {
                const data = actionId || { x: actionCoordsX, y: actionCoordsY };
                if (actionType && data) {
                    onActionClick(actionType, data);
                }
            }
            onClose();
        }
    };
    const handleRecipientChange = (e) => {
        const value = e.target.value;
        setNewRecipient(value);
        if (value.length > 0) {
            const filteredSuggestions = allPlayers.filter(player =>
                player.toLowerCase().startsWith(value.toLowerCase())
            );
            setSuggestions(filteredSuggestions);
        } else {
            setSuggestions([]);
        }
    };
    const handleSuggestionClick = (username) => {
        setNewRecipient(username);
        setSuggestions([]);
    };
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
            <div
                ref={messagesViewRef}
                className="papyrus-bg papyrus-text"
                onClick={e => e.stopPropagation()}
                onMouseDown={handleMouseDown}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="messages-header">
                    <h2 className="papyrus-header">Messages</h2>
                    <button onClick={onClose} className="papyrus-text text-3xl font-bold hover:text-red-700">&times;</button>
                </div>
                <div className="messages-body">
                    <div className="messages-left-panel">
                        <div className="p-2 border-b-2 border-[#8B4513]">
                            <button onClick={() => handleCompose()} className="w-full papyrus-btn">
                                New Scroll
                            </button>
                        </div>
                        <ul className="overflow-y-auto">
                            {conversations.map(convo => {
                                const isUnread = convo.lastMessage?.senderId !== currentUser.uid && !convo.readBy.includes(currentUser.uid);
                                return (
                                <li
                                    key={convo.id}
                                    className={`papyrus-list-item ${selectedConversation?.id === convo.id ? 'selected' : ''} ${isUnread ? 'unread glowing-message' : ''}`}
                                    onClick={() => handleSelectConversation(convo)}
                                >
                                    <p className="font-title text-lg">{getOtherParticipant(convo)}</p>
                                    <p className="text-sm truncate">{convo.lastMessage?.text}</p>
                                </li>
                            )})}
                        </ul>
                    </div>
                    <div className="messages-right-panel">
                        {selectedConversation || isComposing ? (
                            <>
                                <div className="p-4 border-b-2 border-[#8B4513] autocomplete-suggestions-container">
                                    {isComposing ? (
                                        <div>
                                            <input
                                                type="text"
                                                value={newRecipient}
                                                onChange={handleRecipientChange}
                                                placeholder="Scribe the recipient's name..."
                                                className="w-full papyrus-input text-lg"
                                                autoComplete="off"
                                            />
                                            {suggestions.length > 0 && (
                                                <ul className="autocomplete-suggestions-list light">
                                                    {suggestions.map(player => (
                                                        <li key={player} onClick={() => handleSuggestionClick(player)}>
                                                            {player}
                                                        </li>
                                                    ))}
                                                </ul>
                                            )}
                                        </div>
                                    ) : (
                                        <h3 className="font-bold text-lg font-title">{getOtherParticipant(selectedConversation)}</h3>
                                    )}
                                </div>
                                <div ref={messageContainerRef} className="flex-grow overflow-y-auto p-4 space-y-4" onClick={handleContentClick}>
                                    {messages.map(msg => (
                                        <div key={msg.id} className={`flex ${msg.senderId === currentUser.uid ? 'justify-end' : 'justify-start'}`}>
                                            <div className={`${msg.senderId === currentUser.uid ? 'papyrus-message-sent' : 'papyrus-message-received'}`}>
                                                <p className="font-bold text-sm font-title">{msg.senderUsername}</p>
                                                <div dangerouslySetInnerHTML={{ __html: parseBBCode(msg.text) }} />
                                                <p className="text-xs text-gray-100/70 mt-1 text-right">{msg.timestamp?.toDate().toLocaleTimeString()}</p>
                                            </div>
                                        </div>
                                    ))}
                                    <div ref={messagesEndRef} />
                                </div>
                                {!isSystemChat && (
                                    <div className="p-4 border-t-2 border-[#8B4513] mt-auto">
                                        <div className="flex">
                                            <TextEditor value={newMessage} onChange={setNewMessage} />
                                            <button onClick={handleSendMessage} className="papyrus-btn ml-2">Send</button>
                                        </div>
                                    </div>
                                )}
                            </>
                        ) : (
                            <div className="flex items-center justify-center h-full">
                                <p className="text-gray-100 italic">Select a conversation or start a new one.</p>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};
export default MessagesView;
</file>

<file path="src/components/profile/AllianceProfile.css">
/* Reusing styles from ProfileView.css for consistency */
.profile-papyrus {
    @apply w-11/12 max-w-4xl relative p-6 flex flex-col;
    height: auto;
    max-height: 90vh;
    background-image: linear-gradient(rgba(245, 222, 179, 0.98), rgba(245, 222, 179, 0.98)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3;
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 25px rgba(0,0,0,0.7);
    color: #4a2c2a;
}

.profile-close-button {
    @apply absolute top-4 right-6 text-4xl leading-none cursor-pointer hover:text-red-700 transition-colors z-10;
}

.profile-grid {
    @apply grid grid-cols-1 md:grid-cols-5 gap-6 h-full;
}

.profile-left-column {
    @apply md:col-span-2 flex flex-col gap-4 min-h-0;
}

.profile-right-column {
    @apply md:col-span-3;
}

.profile-box {
    @apply p-4 rounded-md flex flex-col;
    background-color: rgba(210, 180, 140, 0.4);
    border: 1px solid #a17c48;
}

.profile-right-column .profile-box {
    @apply h-full;
}

.profile-box-header {
    @apply font-title text-xl font-bold text-center p-2 -m-4 mb-4;
    background-color: rgba(30, 58, 138, 0.8);
    color: #f0e68c;
    border-bottom: 2px solid #cd853f;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

.player-info-content {
    @apply text-lg text-center p-2; /* Adjusted font size */
}

.player-stats {
    @apply mt-auto pt-3 border-t-2;
    border-color: #a17c48;
}

.stat-item {
    @apply flex justify-between items-center py-1.5 text-sm;
}

.cities-list { /* Re-purposed for member list */
    @apply flex-grow;
}

.city-item { /* Re-purposed for member item */
    @apply flex justify-between p-2 text-sm rounded-md;
}

.city-item:hover {
    background-color: rgba(139, 69, 19, 0.1);
}

.city-name-btn { /* Re-purposed for member name button */
    @apply bg-transparent border-none font-bold cursor-pointer p-0 text-left;
    color: #1e3a8a;
}

.city-name-btn:hover {
    @apply underline;
}

.profile-description-box {
    @apply h-full flex flex-col items-center p-2;
}

.profile-description-text {
    @apply w-full flex-grow p-3 overflow-y-auto whitespace-pre-wrap text-sm rounded-md;
    background-color: rgba(255, 255, 255, 0.4);
    border: 1px solid #d2b48c;
}
</file>

<file path="src/components/profile/AllianceProfile.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { doc, getDoc, collectionGroup, query, where, getDocs } from 'firebase/firestore';
import { db } from '../../firebase/config';
import { useGame } from '../../contexts/GameContext';
import './AllianceProfile.css';

const allianceProfileCache = {};

const AllianceProfile = ({ allianceId, onClose, onOpenProfile }) => {
    const { worldId, worldState } = useGame();
    const [allianceData, setAllianceData] = useState(null);
    const [membersData, setMembersData] = useState([]);
    const [loading, setLoading] = useState(true);

    const allianceProfileRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 1000) / 2,
        y: (window.innerHeight - 700) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('profile-box-header') || e.target.parentElement.classList.contains('profile-box-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);
    
    // #comment Fetch all member data for the alliance
    const fetchAllMemberData = useCallback(async (members) => {
        if (!worldId || !worldState || !members || members.length === 0) return [];
        const memberIds = members.map(m => m.uid);
        
        const memberPoints = {};
        
        // #comment Firestore 'in' queries are limited to 30 items, so we chunk the requests.
        for (let i = 0; i < memberIds.length; i += 30) {
            const chunk = memberIds.slice(i, i + 30);
            if (chunk.length > 0) {
                const gamesGroupRef = collectionGroup(db, 'games');
                const q = query(gamesGroupRef, where('worldName', '==', worldState.name), where('__name__', 'in', chunk.map(id => `users/${id}/games/${worldId}`)));
                const gamesSnapshot = await getDocs(q);
                gamesSnapshot.forEach(gameDoc => {
                    const userId = gameDoc.ref.parent.parent.id;
                    memberPoints[userId] = gameDoc.data().totalPoints || 0;
                });
            }
        }

        return members.map(member => ({
            ...member,
            points: memberPoints[member.uid] || 0,
        })).sort((a, b) => b.points - a.points);

    }, [worldId, worldState]);

    useEffect(() => {
        const fetchData = async () => {
            setLoading(true);
            try {
                const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', allianceId);
                const allianceDocSnap = await getDoc(allianceDocRef);

                if (allianceDocSnap.exists()) {
                    const alliance = allianceDocSnap.data();
                    setAllianceData(alliance);

                    const detailedMembers = await fetchAllMemberData(alliance.members);
                    setMembersData(detailedMembers);

                    allianceProfileCache[allianceId] = {
                        data: { alliance, members: detailedMembers },
                        timestamp: Date.now()
                    };
                }
            } catch (error) {
                console.error("Error fetching alliance data:", error);
            }
            setLoading(false);
        };

        const now = Date.now();
        const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

        if (allianceProfileCache[allianceId] && (now - allianceProfileCache[allianceId].timestamp < CACHE_DURATION)) {
            const cached = allianceProfileCache[allianceId].data;
            setAllianceData(cached.alliance);
            setMembersData(cached.members);
            setLoading(false);
        } else {
            fetchData();
        }
    }, [allianceId, worldId, fetchAllMemberData]);

    if (loading) {
        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70">
                <div className="text-white">Loading Alliance Profile...</div>
            </div>
        );
    }

    if (!allianceData) {
        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
                <div className="profile-papyrus" onClick={e => e.stopPropagation()}>
                    <button onClick={onClose} className="profile-close-button">&times;</button>
                    <p className="text-center">Alliance not found.</p>
                </div>
            </div>
        );
    }

    const totalPoints = membersData.reduce((sum, member) => sum + member.points, 0);

    // #comment Render alliance information
    const renderAllianceInfo = () => (
        <div className="profile-box">
            <div className="profile-box-header">
                {allianceData.name} [{allianceData.tag}]
            </div>
            <div className="player-info-content">
                Leader: <button onClick={() => onOpenProfile(allianceData.leader.uid)} className="text-blue-400 hover:underline font-bold">{allianceData.leader.username}</button>
            </div>
            <div className="player-stats">
                <div className="stat-item"><span>👥 Members</span> <span>{allianceData.members.length}</span></div>
                <div className="stat-item"><span>🏆 Total Points</span> <span>{totalPoints.toLocaleString()}</span></div>
            </div>
        </div>
    );

    // #comment Render member list
    const renderMemberList = () => (
        <div className="profile-box h-full flex flex-col">
            <div className="profile-box-header">Members</div>
            <div className="cities-list overflow-y-auto flex-grow">
                {membersData.map(member => (
                    <div key={member.uid} className="city-item">
                        <button onClick={() => onOpenProfile(member.uid)} className="city-name-btn">
                            {member.username} ({member.rank})
                        </button>
                        <span>{member.points.toLocaleString()} points</span>
                    </div>
                ))}
            </div>
        </div>
    );

    // #comment Render description
    const renderDescription = () => (
        <div className="profile-box flex-grow min-h-0 flex flex-col">
            <div className="profile-box-header">Description</div>
            <div className="profile-description-box">
                <div className="profile-description-text">
                    <p>{allianceData.settings.description || 'This alliance has no public description.'}</p>
                </div>
            </div>
        </div>
    );

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div
                ref={allianceProfileRef}
                className="profile-papyrus"
                onClick={e => e.stopPropagation()}
                onMouseDown={handleMouseDown}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <button onClick={onClose} className="profile-close-button">&times;</button>
                <div className="profile-grid">
                    <div className="profile-left-column">
                        {renderAllianceInfo()}
                        {renderDescription()}
                    </div>
                    <div className="profile-right-column">
                        {renderMemberList()}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default AllianceProfile;
</file>

<file path="src/components/profile/ProfileView.css">
.profile-papyrus {
    @apply w-11/12 max-w-4xl relative p-6 flex flex-col; /* Increased padding */
    height: auto; /* Auto height */
    max-height: 90vh; /* Max height */
    background-image: linear-gradient(rgba(245, 222, 179, 0.98), rgba(245, 222, 179, 0.98)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3;
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 25px rgba(0,0,0,0.7);
    color: #4a2c2a;
    position: fixed;
    z-index: 50;
}

.profile-close-button {
    @apply absolute top-4 right-6 text-4xl leading-none cursor-pointer hover:text-red-700 transition-colors z-10;
}

.profile-grid {
    @apply grid grid-cols-1 md:grid-cols-5 gap-6 h-full; /* Responsive grid */
}

.profile-left-column {
    @apply md:col-span-2 flex flex-col gap-4 min-h-0;
}

.profile-right-column {
    @apply md:col-span-3;
}

.profile-box {
    @apply p-4 rounded-md flex flex-col; /* Increased padding and rounded corners */
    background-color: rgba(210, 180, 140, 0.4);
    border: 1px solid #a17c48;
}

.profile-box-header {
    @apply font-title text-xl font-bold text-center p-2 -m-4 mb-4; /* Adjusted font size and padding */
    background-color: rgba(30, 58, 138, 0.8);
    color: #f0e68c;
    border-bottom: 2px solid #cd853f;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    cursor: move;
}

.profile-right-column .profile-box {
    @apply h-full;
}

.player-info-content {
    @apply text-xl font-bold text-center p-2; /* Centered text */
}

.player-stats {
    @apply mt-auto pt-3 border-t-2;
    border-color: #a17c48;
}

.stat-item {
    @apply flex justify-between items-center py-1.5 text-sm; /* Increased padding */
}

.cities-list {
    @apply flex-grow;
}

.city-item {
    @apply flex justify-between p-2 text-sm rounded-md; /* Added padding and rounded corners */
}

.city-item:hover {
    background-color: rgba(139, 69, 19, 0.1);
}

.city-name-btn {
    @apply bg-transparent border-none font-bold cursor-pointer p-0 text-left;
    color: #1e3a8a;
}

.city-name-btn:hover {
    @apply underline;
}

.profile-description-box {
    @apply h-full flex flex-col items-center p-2; /* Added padding */
}

.profile-avatar-large {
    @apply w-32 h-32 object-cover rounded-lg mb-4 shadow-lg; /* Rounded large, added shadow */
    border: 3px solid #8B4513;
}

.profile-description-text {
    @apply w-full flex-grow p-3 overflow-y-auto whitespace-pre-wrap text-sm rounded-md;
    background-color: rgba(255, 255, 255, 0.4);
    border: 1px solid #d2b48c;
}

.profile-edit-button {
    @apply absolute bottom-6 right-6 font-bold py-2 px-4 rounded-md transition-transform hover:scale-105;
    background: #8B4513;
    color: #F5DEB3;
    border: 1px solid #4a2c2a;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}

.btn-cancel, .btn-save {
    @apply font-bold py-1 px-3 rounded-md text-xs;
    background: #8B4513;
    color: #F5DEB3;
    border: 1px solid #4a2c2a;
}

.btn-cancel:hover, .btn-save:hover {
    background: #A0522D;
}
</file>

<file path="src/components/profile/ProfileView.js">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { useAlliance } from '../../contexts/AllianceContext';
import { doc, getDoc, collection, getDocs } from 'firebase/firestore';
import { db } from '../../firebase/config';
import { useCityState } from '../../hooks/useCityState';
import unitConfig from '../../gameData/units.json';
import './ProfileView.css';
import TextEditor from '../shared/TextEditor';
import placeholder_profile from '../../images/placeholder_profile.png';

const profileCache = {};
export const clearProfileCache = () => {
    for (const key in profileCache) {
        delete profileCache[key];
    }
};

const ProfileView = ({ onClose, viewUserId, onGoToCity, onInviteToAlliance, onOpenAllianceProfile }) => {
    const { currentUser, userProfile: ownUserProfile, updateUserProfile } = useAuth();
    const { worldId } = useGame();
    const { playerAlliance } = useAlliance();
    const { calculateTotalPoints } = useCityState(worldId);
    
    const [profileData, setProfileData] = useState(null);
    const [gameData, setGameData] = useState(null);
    const [cities, setCities] = useState([]);
    const [points, setPoints] = useState(0);
    const [totalAttack, setTotalAttack] = useState(0);
    const [totalDefense, setTotalDefense] = useState(0);
    const [loading, setLoading] = useState(true);
    const [newDescription, setNewDescription] = useState('');
    const [newImageUrl, setNewImageUrl] = useState('');
    const [isEditing, setIsEditing] = useState(false);

    const profileRef = useRef(null);
    const [position, setPosition] = useState({ 
        x: (window.innerWidth - 1000) / 2,
        y: (window.innerHeight - 700) / 2
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
        if (e.target.classList.contains('profile-box-header') || e.target.parentElement.classList.contains('profile-box-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);

    const isOwnProfile = !viewUserId || viewUserId === currentUser.uid;

    useEffect(() => {
        const fetchData = async () => {
            setLoading(true);
            const userId = viewUserId || currentUser.uid;
            try {
                // #comment Fetch user profile
                const userDocRef = doc(db, "users", userId);
                const userDocSnap = await getDoc(userDocRef);
                let userData = null;
                if (userDocSnap.exists()) {
                    userData = userDocSnap.data();
                    setProfileData(userData);
                    setNewDescription(userData.description || '');
                    setNewImageUrl(userData.imageUrl || '');
                }
                // #comment Fetch top-level game data (for alliance info)
                const gameDocRef = doc(db, `users/${userId}/games`, worldId);
                const gameDocSnap = await getDoc(gameDocRef);
                const gameData = gameDocSnap.exists() ? gameDocSnap.data() : null;
                setGameData(gameData);
                // #comment Fetch all cities for the user in this world
                const citiesColRef = collection(db, `users/${userId}/games`, worldId, 'cities');
                const citiesSnap = await getDocs(citiesColRef);
                const citiesList = citiesSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                setCities(citiesList);

                let calculatedPoints = 0;
                let calculatedAttack = 0;
                let calculatedDefense = 0;
                for (const city of citiesList) {
                    calculatedPoints += calculateTotalPoints(city);
                    if (city.units) {
                        for (const [unitId, count] of Object.entries(city.units)) {
                            const unit = unitConfig[unitId];
                            if (unit) {
                                calculatedAttack += (unit.attack || 0) * count;
                                calculatedDefense += (unit.defense || 0) * count;
                            }
                        }
                    }
                }
                setPoints(calculatedPoints);
                setTotalAttack(calculatedAttack);
                setTotalDefense(calculatedDefense);

                profileCache[userId] = {
                    data: {
                        profileData: userData,
                        gameData,
                        cities: citiesList,
                        points: calculatedPoints,
                        totalAttack: calculatedAttack,
                        totalDefense: calculatedDefense,
                    },
                    timestamp: Date.now(),
                };
            } catch (error) {
                console.error("Error fetching user data:", error);
            }
            setLoading(false);
        };

        const userId = viewUserId || currentUser.uid;
        const now = Date.now();
        const twentyMinutes = 20 * 60 * 1000;

        if (profileCache[userId] && (now - profileCache[userId].timestamp < twentyMinutes)) {
            const cached = profileCache[userId].data;
            setProfileData(cached.profileData);
            setGameData(cached.gameData);
            setCities(cached.cities);
            setPoints(cached.points);
            setTotalAttack(cached.totalAttack);
            setTotalDefense(cached.totalDefense);
            setNewDescription(cached.profileData.description || '');
            setNewImageUrl(cached.profileData.imageUrl || '');
            setLoading(false);
        } else {
            fetchData();
        }
    }, [viewUserId, currentUser.uid, worldId, calculateTotalPoints]);

    // #comment handle update profile
    const handleUpdateProfile = async (e) => {
        e.preventDefault();
        if (!isOwnProfile) return;
        const profileUpdateData = {
            description: newDescription,
            imageUrl: newImageUrl,
        };
        try {
            await updateUserProfile(profileUpdateData);
            setIsEditing(false);
        } catch (error) {
            console.error("Failed to update profile.", error);
        }
    };

    // #comment get ocean
    const getOcean = (x, y) => {
        if (x === undefined || y === undefined) return '?';
        return `${Math.floor(y / 10)}${Math.floor(x / 10)}`;
    };

    // #comment check if can invite
    const canInvite = (() => {
        if (!playerAlliance || isOwnProfile) {
            return false;
        }
        const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
        if (!member) return false;
        const rank = playerAlliance.ranks.find(r => r.id === member.rank);
        return rank?.permissions?.inviteMembers || false;
    })();

    if (loading) {
        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70">
                <div className="text-white">Loading Profile...</div>
            </div>
        );
    }

    const displayProfile = isOwnProfile ? ownUserProfile : profileData;

    // #comment Render player information
    const renderPlayerInfo = () => (
        <div className="profile-box">
            <div className="profile-box-header">
                {displayProfile?.username}
            </div>
            <div className="player-info-content">
                {gameData?.alliance ? (
                    <button
                        onClick={() => onOpenAllianceProfile(gameData.alliance)}
                        className="text-blue-400 hover:underline font-bold"
                    >
                        [{gameData.alliance}]
                    </button>
                ) : 'No Alliance'}
            </div>
            <div className="player-stats">
                <div className="stat-item"><span>⚔️ Attack Points</span> <span>{totalAttack.toLocaleString()}</span></div>
                <div className="stat-item"><span>🛡️ Defense Points</span> <span>{totalDefense.toLocaleString()}</span></div>
                <div className="stat-item"><span>🏆 Total Points</span> <span>{points.toLocaleString()}</span></div>
            </div>
        </div>
    );

    // #comment Render cities list
    const renderCitiesList = () => (
        <div className="profile-box flex-grow min-h-0">
            <div className="profile-box-header flex justify-between items-center">
                <span>Cities ({cities.length})</span>
                <button className="text-xs bg-gray-500/50 px-2 py-0.5 rounded">BBCode</button>
            </div>
            <div className="cities-list overflow-y-auto">
                {cities.length > 0 ? (
                    cities.map(city => (
                        <div key={city.id} className="city-item">
                            <button onClick={() => onGoToCity(city.x, city.y)} className="city-name-btn">
                                {city.cityName}
                            </button>
                            <span>{calculateTotalPoints(city).toLocaleString()} points | Ocean {getOcean(city.x, city.y)}</span>
                        </div>
                    ))
                ) : (
                    <p className="text-sm text-center p-4">No cities in this world.</p>
                )}
            </div>
        </div>
    );

    // #comment Render profile description
    const renderProfileDescription = () => (
        <div className="profile-box h-full">
            <div className="profile-box-header">Profile</div>
            <div className="profile-description-box">
                <img
                    src={displayProfile?.imageUrl || placeholder_profile}
                    onError={(e) => { e.target.onerror = null; e.target.src=placeholder_profile; }}
                    alt="Profile Avatar"
                    className="profile-avatar-large"
                />
                <div className="profile-description-text">
                    {isEditing ? (
                        <form onSubmit={handleUpdateProfile} className="h-full flex flex-col">
                            <TextEditor value={newDescription} onChange={setNewDescription} />
                            <input type="text" value={newImageUrl} onChange={(e) => setNewImageUrl(e.target.value)} placeholder="Image URL" className="w-full mt-2 bg-white/50 border border-yellow-800/50 p-1" />
                            <div className="flex justify-end gap-2 mt-2">
                                <button type="button" onClick={() => setIsEditing(false)} className="btn-cancel">Cancel</button>
                                <button type="submit" className="btn-save">Save</button>
                            </div>
                        </form>
                    ) : (
                        <p>{displayProfile?.description || 'This player has not written a profile text.'}</p>
                    )}
                </div>
            </div>
        </div>
    );

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div
                ref={profileRef}
                className="profile-papyrus"
                onClick={e => e.stopPropagation()}
                onMouseDown={handleMouseDown}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <button onClick={onClose} className="profile-close-button">&times;</button>
                <div className="profile-grid">
                    <div className="profile-left-column">
                        {renderPlayerInfo()}
                        {renderCitiesList()}
                    </div>
                    <div className="profile-right-column">
                        {renderProfileDescription()}
                    </div>
                </div>
                {isOwnProfile && !isEditing && (
                    <button onClick={() => setIsEditing(true)} className="profile-edit-button">Edit Profile</button>
                )}
                {canInvite && (
                    <button onClick={() => onInviteToAlliance(viewUserId)} className="profile-edit-button">
                        Invite to Alliance
                    </button>
                )}
            </div>
        </div>
    );
};

export default ProfileView;
</file>

<file path="src/components/puzzles/PuzzleRenderer.js">
// src/components/puzzles/PuzzleRenderer.js
import React, { useState, useEffect } from 'react';
import puzzles from '../../gameData/puzzles.json';

const PuzzleRenderer = ({ puzzleId, onSolve }) => {
    const [puzzle, setPuzzle] = useState(null);
    const [answer, setAnswer] = useState('');
    const [message, setMessage] = useState('');

    useEffect(() => {
        if (puzzles[puzzleId]) {
            setPuzzle(puzzles[puzzleId]);
        }
    }, [puzzleId]);

    const handleSubmit = () => {
        if (answer.toLowerCase().trim() === puzzle.answer.toLowerCase().trim()) {
            setMessage('Correct! The way is open.');
            onSolve();
        } else {
            setMessage('Incorrect. The guardians ponder your answer...');
        }
    };

    if (!puzzle) {
        return <div>Loading puzzle...</div>;
    }

    return (
        <div className="p-4 bg-black/10 rounded mt-4">
            <p className="italic">"{puzzle.question}"</p>
            <div className="flex mt-4">
                <input
                    type="text"
                    value={answer}
                    onChange={(e) => setAnswer(e.target.value)}
                    className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Your answer..."
                />
                <button onClick={handleSubmit} className="btn btn-primary ml-2">Submit</button>
            </div>
            {message && <p className="text-center mt-2">{message}</p>}
        </div>
    );
};

export default PuzzleRenderer;
</file>

<file path="src/components/quests/Quests.css">
/* src/components/quests/Quests.css */
.quest-modal-container {
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 8px solid;
    border-image-slice: 1;
    border-image-source: linear-gradient(to right, #8B4513, #CD853F);
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    color: #4a2c2a;
    width: 90%;
    max-width: 600px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
}

.quest-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1.5rem;
    background-color: #1e3a8a;
    color: #f0e68c;
    font-family: 'IM Fell English SC', serif;
    font-size: 1.5rem;
    border-bottom: 2px solid #cd853f;
}

.quest-modal-header .close-btn {
    background: none;
    border: none;
    color: #f0e68c;
    font-size: 2.5rem;
    cursor: pointer;
    line-height: 1;
}

.quest-modal-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.quest-item {
    background-color: rgba(139, 69, 19, 0.1);
    border: 1px solid #d2b48c;
    border-radius: 4px;
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.quest-title {
    font-weight: bold;
    font-size: 1.1rem;
    color: #8B4513;
}

.quest-description {
    font-size: 0.9rem;
    margin-top: 0.25rem;
}

.quest-rewards {
    font-size: 0.8rem;
    margin-top: 0.5rem;
    color: #1e3a8a;
    font-weight: bold;
}

.quest-claim-btn {
    background: linear-gradient(to bottom, #f0e68c, #cd853f);
    color: #4a2c2a;
    font-weight: bold;
    border: 2px solid #8B4513;
    border-radius: 4px;
    padding: 0.5rem 1.5rem;
    transition: all 0.2s;
    cursor: pointer;
    flex-shrink: 0;
}

.quest-claim-btn:hover:not(:disabled) {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}

.quest-claim-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background: #d2b48c;
}
</file>

<file path="src/components/quests/QuestsModal.js">
// src/components/quests/QuestsModal.js
import React from 'react';
import './Quests.css';
import { getNationalUnitReward } from '../../utils/nationality';
import unitConfig from '../../gameData/units.json';

const QuestsModal = ({ quests, claimReward, isClaiming, onClose, cityState }) => {
    const activeQuests = quests.filter(q => !q.isClaimed);
    const playerNation = cityState?.playerInfo?.nation;

    // #comment A helper function to render rewards with dynamic unit names
    const renderRewards = (rewards) => {
        const rewardStrings = [];

        if (rewards.resources) {
            for (const res in rewards.resources) {
                rewardStrings.push(`${rewards.resources[res]} ${res}`);
            }
        }
        
        if (rewards.units && playerNation) {
            for (const unitId in rewards.units) {
                const count = rewards.units[unitId];
                let unitName;
                if (unitId.startsWith('generic_')) {
                    const nationalUnitId = getNationalUnitReward(playerNation, unitId);
                    unitName = unitConfig[nationalUnitId]?.name || nationalUnitId;
                } else {
                    unitName = unitConfig[unitId]?.name || unitId;
                }
                rewardStrings.push(`${count} ${unitName}`);
            }
        }

        return rewardStrings.join(', ');
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="quest-modal-container" onClick={e => e.stopPropagation()}>
                <div className="quest-modal-header">
                    <h2>Quests</h2>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="quest-modal-content">
                    {activeQuests.length > 0 ? activeQuests.map(quest => (
                        <div key={quest.id} className="quest-item">
                            <div>
                                <h3 className="quest-title">{quest.title}</h3>
                                <p className="quest-description">{quest.description}</p>
                                <div className="quest-rewards">
                                    Reward: {renderRewards(quest.rewards)}
                                </div>
                            </div>
                            <button
                                onClick={() => claimReward(quest.id)}
                                disabled={!quest.isComplete || isClaiming}
                                className="quest-claim-btn"
                            >
                                {isClaiming ? 'Claiming...' : (quest.isComplete ? 'Claim' : 'In Progress')}
                            </button>
                        </div>
                    )) : (
                        <p className="text-center">No active quests.</p>
                    )}
                </div>
            </div>
        </div>
    );
};

export default QuestsModal;
</file>

<file path="src/components/QuestsButton.css">
/* src/components/QuestsButton.css */
.quests-button-container {
    position: absolute;
    top: 90px;
    left: 11rem;
    z-index: 50;
    width: 80px;
    height: 80px;
}

.quests-button {
    background: none;
    border: none;
    padding: 0;
    margin: 0;
    cursor: pointer;
    width: 100%;
    height: 100%;
    background-image: url('../images/quests/quest_spritesheet.png');
    background-size: 380% 105%;
    background-repeat: no-repeat;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
    transition: all 0.3s ease-in-out;
    image-rendering: pixelated;
    opacity: 0.3; /* Default transparency */
    transform: scale(0.9); /* Slightly smaller by default */
}

.quests-button:hover {
    opacity: 1; /* Full opacity on hover */
    transform: scale(1.1); /* Grow on hover */
}

/* State-specific styles with hover enhancement */
.quests-button.unclaimed {
    animation: glowing-border-animation 2s infinite;
    background-position: 0% 0%;
}

.quests-button.idle {
    background-position: 50% 0%;
}

.quests-button.completed {
    background-position: 100% 0%;
    animation: none;
}

/* Make the glow more visible during hover */
.quests-button.unclaimed:hover {
    animation: glowing-border-animation 1s infinite;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5)) brightness(1.2);
}

@keyframes glowing-border-animation {
    0% { box-shadow: 0 0 3px #fde047; }
    50% { box-shadow: 0 0 15px #fef08a; }
    100% { box-shadow: 0 0 3px #fde047; }
}
</file>

<file path="src/components/QuestsButton.js">
import React, { useMemo } from 'react';
import './QuestsButton.css';
import questSpritesheet from '../images/quests/quest_spritesheet.png';
import { useGame } from '../contexts/GameContext';

const QuestsButton = ({ quests = [], onOpenQuests }) => {
    const { gameSettings } = useGame();

    const buttonState = useMemo(() => {
        const hasUnclaimed = quests.some(q => q.isComplete && !q.isClaimed);
        const allCompleted = quests.length > 0 && quests.every(q => q.isComplete && q.isClaimed);

        if (hasUnclaimed) return 'unclaimed';
        if (allCompleted) return 'completed';
        return 'idle';
    }, [quests]);

    if (buttonState === 'completed' && gameSettings.hideCompletedQuestsIcon) {
        return null;
    }

    return (
        <div className="quests-button-container">
            <button
                onClick={onOpenQuests}
                className={`quests-button ${buttonState}`}
                title="Open Quests"
                style={{ backgroundImage: `url(${questSpritesheet})` }}
                aria-label="Quests"
            />
        </div>
    );
};

export default QuestsButton;
</file>

<file path="src/components/ReportsView.css">
.reports-container {
    background-image: url('../images/bg/reports_bg.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    background-position: center;
    color: #4a2c2a;
    width: 1000px;
    height: 650px;
    display: flex;
    flex-direction: column;
    background-color: transparent;
    border: none;
    padding: 20px 35px 50px 35px; /* Added padding to fit content inside the background's border */
    position: fixed;
    z-index: 50;
}
.reports-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 0 10px 0;
    background-color: transparent;
    color: #f0e68c;
    border-bottom: none;
    height: 50px; /* Adjust height */
    cursor: move;
}
.close-btn {
    background: none;
    border: none;
    color: #f0e68c;
    font-size: 2.5rem;
    cursor: pointer;
    line-height: 1;
}

/* New classes for two-column layout */
.reports-body {
    display: flex;
    flex-grow: 1;
    overflow: hidden;
    margin-top: 1rem;
}
.reports-left-panel {
    width: 35%;
    display: flex;
    flex-direction: column;
    padding-right: 1rem;
}
.reports-right-panel {
    width: 65%;
    padding-left: 1rem;
    border-left: 2px solid #a17c48; /* Separator line */
    overflow-y: auto;
}


.reports-tabs {
    display: flex;
    background-color: transparent;
    padding: 0;
    border-bottom: 2px solid #a17c48;
    flex-wrap: wrap;
}
.tab-btn {
    padding: 8px 16px;
    background: #d2b48c;
    color: #4a2c2a;
    border: 2px solid #8B4513;
    border-bottom: none;
    margin-right: 4px;
    margin-bottom: 0;
    cursor: pointer;
    font-weight: bold;
    position: relative;
    flex-shrink: 0;
}
.tab-btn:last-child {
    margin-right: 0;
}
.tab-btn.active {
    background: transparent;
    color: #4a2c2a;
    border-bottom: 2px solid transparent;
    margin-bottom: -2px;
}
.reports-list {
    overflow-y: auto;
    flex-grow: 1;
}
.reports-list .report-item {
    padding: 0.75rem;
    cursor: pointer;
    border-bottom: 1px solid #a17c48;
    background-color: transparent;
    color: #4a2c2a;
}
.report-item:hover {
    background-color: rgba(139, 69, 19, 0.1);
}
.report-item.selected {
    background-color: rgba(139, 69, 19, 0.2);
    border-left: 4px solid #8B4513;
}
.report-item.unread {
    font-weight: bold;
    color: #000;
}
.delete-btn {
    background: none;
    border: none;
    color: #a0522d;
    font-size: 1.2rem;
    font-weight: bold;
    cursor: pointer;
}
.glowing-tab {
    animation: glowing-tab-border-animation 1.5s infinite;
}
@keyframes glowing-tab-border-animation {
    0% {
        box-shadow: 0 0 4px #fde047;
        border-color: #fde047;
    }
    50% {
        box-shadow: 0 0 12px #fef08a, 0 0 8px #fef08a;
        border-color: #fef08a;
    }
    100% {
        box-shadow: 0 0 4px #fde047;
        border-color: #fde047;
    }
}
.tab-badge {
    position: absolute;
    top: 2px;
    right: 2px;
    background-color: #ef4444;
    color: white;
    font-size: 0.65rem;
    font-weight: bold;
    border-radius: 9999px;
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid white;
}
</file>

<file path="src/components/ReportsView.js">
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { collection, onSnapshot, doc, updateDoc, deleteDoc, query, orderBy, setDoc } from 'firebase/firestore';
import { db } from '../firebase/config';
import { useAuth } from '../contexts/AuthContext';
import { useGame } from '../contexts/GameContext';
import unitConfig from '../gameData/units.json';
import buildingConfig from '../gameData/buildings.json';
import godsConfig from '../gameData/gods.json';
import ruinsResearch from '../gameData/ruinsResearch.json';
import heroesConfig from '../gameData/heroes.json';
import { parseBBCode } from '../utils/bbcodeParser';
import battlePointsImage from '../images/battle_points.png';
import './ReportsView.css';

// #comment Pre-load all necessary images for reports
const images = {};
const imageContexts = [
    require.context('../images/troops', false, /\.(png|jpe?g|svg)$/),
    require.context('../images/resources', false, /\.(png|jpe?g|svg)$/),
    require.context('../images/buildings', false, /\.(png|jpe?g|svg)$/),
    require.context('../images/gods', false, /\.(png|jpe?g|svg)$/),
    require.context('../images/heroes', false, /\.(png|jpe?g|svg)$/),
];
imageContexts.forEach(context => {
    context.keys().forEach((item) => {
        const keyWithSubdir = context.id.includes('/resources') ? `resources/${item.replace('./', '')}` :
                              context.id.includes('/buildings') ? `buildings/${item.replace('./', '')}` :
                              context.id.includes('/gods') ? `gods/${item.replace('./', '')}` :
                              context.id.includes('/heroes') ? `heroes/${item.replace('./', '')}` :
                              item.replace('./', '');
        images[keyWithSubdir] = context(item);
    });
});


const ReportsView = ({ onClose, onActionClick }) => {
    const { currentUser } = useAuth();
    const { worldId, gameSettings } = useGame(); // Get worldId from context
    const [reports, setReports] = useState([]);
    const [selectedReport, setSelectedReport] = useState(null);
    const [activeTab, setActiveTab] = useState('Combat');
    const [message, setMessage] = useState('');
    const reportsRef = useRef(null);
    const [position, setPosition] = useState({
        x: (window.innerWidth - 1000) / 2, // Center horizontally
        y: (window.innerHeight - 650) / 2  // Center vertically
    });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const tabs = {
        'Combat': ['attack', 'attack_village', 'attack_ruin', 'attack_god_town'],
        'Reinforce': ['reinforce'],
        'Trade': ['trade'],
        'Scout': ['scout', 'spy_caught'],
        'Misc': ['return', 'spell_cast', 'spell_received', 'spell_fail'],
    };

    // #comment Handle dragging the modal window
    const handleMouseDown = (e) => {
        if (e.target.classList.contains('reports-header') || e.target.parentElement.classList.contains('reports-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);

    // #comment Fetch reports from Firestore in real-time
    useEffect(() => {
        if (!currentUser || !worldId) return;
        const reportsQuery = query(collection(db, 'users', currentUser.uid, 'worlds', worldId, 'reports'), orderBy('timestamp', 'desc'));
        const unsubscribe = onSnapshot(reportsQuery, (snapshot) => {
            const reportsData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setReports(reportsData);
        });
        return () => unsubscribe();
    }, [currentUser, worldId]);

    // #comment Handle selecting a report and marking it as read
    const handleSelectReport = async (report) => {
        setSelectedReport(report);
        if (!report.read) {
            const reportRef = doc(db, 'users', currentUser.uid, 'worlds', worldId, 'reports', report.id);
            await updateDoc(reportRef, { read: true });
        }
    };

    // #comment Handle deleting a report
    const handleDeleteReport = async (reportId) => {
        const reportRef = doc(db, 'users', currentUser.uid, 'worlds', worldId, 'reports', reportId);
        await deleteDoc(reportRef);
        if (selectedReport && selectedReport.id === reportId) {
            setSelectedReport(null);
        }
    };

    // #comment Handle sharing a report by creating a shared document and copying BBCode
    const handleShareReport = async (report) => {
        setMessage('');
        try {
            const sharedReportRef = doc(db, 'worlds', worldId, 'shared_reports', report.id);
            await setDoc(sharedReportRef, report);
            // This is the corrected part: always use the generic [report] tag with the ID
            const bbCode = `[report]${report.id}[/report]`;
            navigator.clipboard.writeText(bbCode);
            setMessage('Report shared! BBCode copied to clipboard.');
            setTimeout(() => setMessage(''), 3000);
        } catch (error) {
            console.error("Error sharing report:", error);
            setMessage('Failed to share report.');
        }
    };

    const handleTabClick = (tabName) => {
        setActiveTab(tabName);
        setSelectedReport(null);
    };

    // #comment This function handles clicks inside the report content area for BBCode actions
    const handleContentClick = (e) => {
        const target = e.target;
        if (target.classList.contains('bbcode-action') && onActionClick) {
            let { actionType, actionId, actionOwnerId, actionCoordsX, actionCoordsY } = target.dataset;
            if (actionType === 'city_link') {
                onActionClick(actionType, { cityId: actionId, ownerId: actionOwnerId, coords: { x: actionCoordsX, y: actionCoordsY } });
            } else {
                onActionClick(actionType, actionId || { x: actionCoordsX, y: actionCoordsY });
            }
        }
    };

    // #comment Determine the color of the report title based on its type and outcome
    const getReportTitleColor = (report) => {
        switch (report.type) {
            case 'attack':
            case 'attack_village':
            case 'attack_ruin':
            case 'attack_god_town':
                return report.outcome?.attackerWon ? 'text-green-600' : 'text-red-600';
            case 'scout':
                return report.scoutSucceeded ? 'text-green-600' : 'text-red-600';
            case 'spy_caught':
                return 'text-red-600';
            case 'spell_cast':
            case 'spell_received':
                return 'text-purple-600';
            case 'spell_fail':
                return 'text-red-600';
            case 'return':
            case 'reinforce':
                return 'text-blue-600';
            case 'trade':
                return 'text-yellow-600';
            default:
                return 'text-gray-800';
        }
    };

    // #comment Get the display title for a report
    const getReportTitle = (report) => {
        let title = report.title || 'Untitled Report';
        if (report.type === 'attack' || report.type === 'attack_village' || report.type === 'attack_ruin' || report.type === 'attack_god_town') {
            title += report.outcome?.attackerWon ? ' (Victory)' : ' (Defeat)';
        }
        return title;
    };

    // #comment Render a list of units, optionally styled as losses
    const renderUnitList = (units, isLosses = false) => {
        if (!units || Object.keys(units).length === 0) return 'None';
        const content = Object.entries(units)
            .map(([id, count]) => `${count} ${unitConfig[id]?.name || id}`)
            .join(', ');
        return isLosses ? <span className="text-red-600 font-semibold">{content}</span> : content;
    };

    // #comment Safely get an image URL from the pre-loaded images map
    const getImageUrl = (imageName) => {
        if (!imageName || !images[imageName]) {
            console.warn(`Image not found: ${imageName}`);
            return '';
        }
        return images[imageName];
    };

    // #comment Render a grid of troop icons with counts
    const renderTroopDisplay = (units) => {
        if (!units || Object.keys(units).length === 0) return null;
        return (
            <div className="flex flex-wrap items-center justify-center gap-2">
                {Object.entries(units).map(([unitId, count]) => {
                    if (count > 0) {
                        const unit = unitConfig[unitId];
                        const imageSrc = getImageUrl(unit?.image || '');
                        return (
                            <div key={unitId} className="flex flex-col items-center">
                                {imageSrc && <img src={imageSrc} alt={unit?.name || unitId} className="w-8 h-8"/>}
                                <span className="text-sm">{count}</span>
                            </div>
                        );
                    }
                    return null;
                })}
            </div>
        );
    };

    // #comment Render hero display in a report
    const renderHeroDisplay = (heroId) => {
        if (!heroId) return null;
        const hero = heroesConfig[heroId];
        if (!hero) return null;
        const imageSrc = getImageUrl(`heroes/${hero.image}`);
        return (
            <div className="flex flex-col items-center mt-2">
                <h5 className="font-semibold text-yellow-700">Hero</h5>
                <div className="flex flex-col items-center">
                    {imageSrc && <img src={imageSrc} alt={hero.name} className="w-10 h-10"/>}
                    <span className="text-sm">{hero.name}</span>
                </div>
            </div>
        );
    };

    // #comment Render resource icons with amounts
    const renderResourceIcons = (resources) => {
        return Object.entries(resources || {}).map(([res, amount]) => {
            const imagePath = `resources/${res}.png`;
            const imageSrc = getImageUrl(imagePath);
            return (
                <div key={res} className="flex flex-col items-center mx-2">
                    {imageSrc && <img src={imageSrc} alt={res} className="w-8 h-8"/>}
                    <span className="text-sm">{Math.floor(amount)}</span>
                </div>
            );
        });
    };

    // #comment Render building icons with levels
    const renderBuildingDisplay = (buildings) => {
        if (!buildings || Object.keys(buildings).length === 0) return null;
        return (
            <div className="flex flex-wrap items-center justify-center gap-2">
                {Object.entries(buildings).map(([buildingId, data]) => {
                    if (data.level > 0) {
                        const building = buildingConfig[buildingId];
                        const imageSrc = getImageUrl(`buildings/${building?.image}` || '');
                        return (
                            <div key={buildingId} className="flex flex-col items-center">
                                {imageSrc && <img src={imageSrc} alt={building?.name || buildingId} className="w-8 h-8"/>}
                                <span className="text-sm">{building?.name || buildingId} (Lvl {data.level})</span>
                            </div>
                        );
                    }
                    return null;
                })}
            </div>
        );
    };

    // #comment Main function to render the detailed content of a selected report
    const renderReportOutcome = (report) => {
        const outcome = report.outcome || {};
        const attacker = report.attacker || {};
        const defender = report.defender || {};

        switch (report.type) {
            case 'attack_god_town':
            case 'attack':
            case 'attack_village':
                const battlePointsGained = report.title.startsWith('Attack') ? outcome.attackerBattlePoints : outcome.defenderBattlePoints;
                return (
                    <div className="flex flex-col items-center">
                        <p className={`font-bold text-2xl mb-4 ${outcome.attackerWon ? 'text-green-600' : 'text-red-600'}`}>
                            {outcome.attackerWon ? 'Victory!' : 'Defeat!'}
                        </p>
                        <div className="flex items-center justify-between w-full mb-4">
                            <div className="flex flex-col items-center w-1/3">
                                <p className="font-bold text-lg" dangerouslySetInnerHTML={{ __html: parseBBCode(`[city id=${attacker.cityId} owner=${attacker.ownerId} x=${attacker.x} y=${attacker.y}]${attacker.cityName}[/city]`) }}></p>
                                <p className="text-sm text-gray-500" dangerouslySetInnerHTML={{ __html: parseBBCode(`[player id=${attacker.ownerId}]${attacker.username}[/player]`) }}></p>
                                {attacker.allianceId && <p className="text-sm text-gray-500" dangerouslySetInnerHTML={{ __html: parseBBCode(`[alliance id=${attacker.allianceId}]${attacker.allianceName || attacker.allianceId}[/alliance]`) }}></p>}
                            </div>
                            <div className="w-1/3 text-center">
                                <img src={getImageUrl('swordman.png')} alt="Attack Icon" className="mx-auto h-12 w-auto"/>
                            </div>
                            <div className="flex flex-col items-center w-1/3">
                               {defender.cityName ? (
                                    <>
                                        <p className="font-bold text-lg" dangerouslySetInnerHTML={{ __html: parseBBCode(`[city id=${defender.cityId} owner=${defender.ownerId} x=${defender.x} y=${defender.y}]${defender.cityName}[/city]`) }}></p>
                                        <p className="text-sm text-gray-500" dangerouslySetInnerHTML={{ __html: parseBBCode(`[player id=${defender.ownerId}]${defender.username}[/player]`) }}></p>
                                        {defender.allianceId && <p className="text-sm text-gray-500" dangerouslySetInnerHTML={{ __html: parseBBCode(`[alliance id=${defender.allianceId}]${defender.allianceName || defender.allianceId}[/alliance]`) }}></p>}
                                    </>
                                ) : (
                                    <p className="font-bold text-lg">{defender.villageName || defender.ruinName || 'Unknown Target'}</p>
                                )}
                            </div>
                        </div>

                        <div className="w-full grid grid-cols-2 gap-4 text-sm mt-4">
                            <div className="p-3 bg-black/5 rounded flex flex-col items-center">
                                <h4 className="font-semibold text-lg text-yellow-700 mb-2">Attacker Units</h4>
                                {renderTroopDisplay(attacker.units)}
                                {renderHeroDisplay(attacker.hero)}
                                <p className="mt-2"><strong>Losses:</strong> {renderUnitList(outcome.attackerLosses, true)}</p>
                                {outcome.wounded && Object.keys(outcome.wounded).length > 0 && (
                                    <p className="mt-2 text-orange-600"><strong>Wounded:</strong> {renderUnitList(outcome.wounded)}</p>
                                )}
                            </div>
                            <div className="p-3 bg-black/5 rounded flex flex-col items-center">
                                <h4 className="font-semibold text-lg text-yellow-700 mb-2">Defender Units</h4>
                                {outcome.message ? (
                                    <p className="text-gray-500 italic">Unknown</p>
                                ) : (
                                    <>
                                        {renderTroopDisplay(defender.units || defender.troops)}
                                        {renderHeroDisplay(defender.hero)}
                                        <p className="mt-2"><strong>Losses:</strong> {renderUnitList(outcome.defenderLosses, true)}</p>
                                    </>
                                )}
                            </div>
                        </div>

                        {outcome.attackerWon && outcome.plunder && (
                            <div className="w-full p-3 bg-green-800/10 rounded mt-4 text-center">
                                <h4 className="font-semibold text-lg text-green-700 mb-2">Plundered Resources</h4>
                                <div className="flex justify-center">
                                    {renderResourceIcons(outcome.plunder)}
                                </div>
                            </div>
                        )}
                        {outcome.capturedHero && (
                            <div className="w-full p-3 bg-red-800/10 rounded mt-4 text-center">
                                <h4 className="font-semibold text-lg text-red-700 mb-2">Hero Captured!</h4>
                                <p>{heroesConfig[outcome.capturedHero.heroId]?.name} was captured by the {outcome.capturedHero.capturedBy}.</p>
                            </div>
                        )}

                        {typeof battlePointsGained === 'number' && (
                            <div className="w-full p-3 bg-blue-800/10 rounded mt-4 text-center">
                                <h4 className="font-semibold text-lg text-blue-700 mb-2">Battle Points Gained</h4>
                                <div className="flex items-center justify-center">
                                    <img src={battlePointsImage} alt="Battle Points" className="w-6 h-6 mr-2"/>
                                    <p>{battlePointsGained.toLocaleString()}</p>
                                </div>
                            </div>
                        )}
                        <p className="text-gray-500 mt-4 italic">{outcome.message || ''}</p>
                    </div>
                );
            case 'attack_ruin':
                 return (
                    <div className="flex flex-col items-center">
                        <p className={`font-bold text-2xl mb-4 ${outcome.attackerWon ? 'text-green-600' : 'text-red-600'}`}>
                            {outcome.attackerWon ? 'Victory!' : 'Defeat!'}
                        </p>
                         <div className="w-full grid grid-cols-2 gap-4 text-sm mt-4">
                            <div className="p-3 bg-black/5 rounded flex flex-col items-center">
                                <h4 className="font-semibold text-lg text-yellow-700 mb-2">Attacker Units</h4>
                                {renderTroopDisplay(attacker.units)}
                                <p className="mt-2"><strong>Losses:</strong> {renderUnitList(outcome.attackerLosses, true)}</p>
                            </div>
                            <div className="p-3 bg-black/5 rounded flex flex-col items-center">
                                <h4 className="font-semibold text-lg text-yellow-700 mb-2">Guardian Units</h4>
                                {renderTroopDisplay(defender.troops)}
                                <p className="mt-2"><strong>Losses:</strong> {renderUnitList(outcome.defenderLosses, true)}</p>
                            </div>
                        </div>
                        {report.reward && (
                            <div className="w-full p-3 bg-green-800/10 rounded mt-4 text-center">
                                <h4 className="font-semibold text-lg text-green-700 mb-2">Research Unlocked!</h4>
                                <p>{ruinsResearch[report.reward]?.name}</p>
                            </div>
                        )}
                    </div>
                );
            case 'scout':
                const scoutedGod = (report.god && report.playerReligion) ? godsConfig[report.playerReligion.toLowerCase()]?.[report.god] : null;
                return (
                    <div className="space-y-3">
                        {report.scoutSucceeded ? (
                            <>
                                <p className="font-bold text-green-600 text-lg">Scout Successful!</p>
                                {scoutedGod && (
                                    <div className="flex items-center gap-2 mt-2">
                                        <p><strong>Worshipped God:</strong> {scoutedGod.name}</p>
                                        <img src={getImageUrl(`gods/${scoutedGod.image}`)} alt={scoutedGod.name} className="w-8 h-8"/>
                                    </div>
                                )}
                                <div className="mt-4">
                                    <h5 className="font-semibold text-yellow-700">Resources:</h5>
                                    <div className="flex flex-wrap gap-2">{renderResourceIcons(report.resources)}</div>
                                </div>
                                <div className="mt-4">
                                    <h5 className="font-semibold text-yellow-700">Units:</h5>
                                    {renderTroopDisplay(report.units)}
                                </div>
                                <div className="mt-4">
                                    <h5 className="font-semibold text-yellow-700">Buildings:</h5>
                                    {renderBuildingDisplay(report.buildings)}
                                </div>
                            </>
                        ) : (
                            <p className="font-bold text-red-600">{report.message || 'Scout Failed!'}</p>
                        )}
                    </div>
                );
            case 'spell_cast':
            case 'spell_received':
            case 'spell_fail':
                return (
                    <div className="space-y-2 text-center">
                        <p className="font-bold text-lg">{report.title}</p>
                        <p>{outcome.message}</p>
                        {outcome.from && <p className="text-sm text-gray-500">From: {outcome.from}</p>}
                    </div>
                );
            case 'return':
                return (
                    <div className="space-y-1">
                        <p className="font-bold text-blue-600">Troops Returned</p>
                        <p><strong>Surviving Units:</strong></p>
                        {renderTroopDisplay(report.units)}
                        {report.wounded && Object.keys(report.wounded).length > 0 && (
                            <>
                                <p className="font-bold text-orange-600 mt-2">Wounded Units:</p>
                                {renderTroopDisplay(report.wounded)}
                            </>
                        )}
                        <div className="flex flex-wrap gap-2 mt-2">
                            <strong>Loot:</strong> {renderResourceIcons(report.resources)}
                        </div>
                    </div>
                );
            case 'spy_caught':
                return (
                    <div className="space-y-1">
                        <p className="font-bold text-red-600">Spy Detected!</p>
                        <p>A spy from {report.originCityName || 'an unknown city'} was detected.</p>
                        {report.silverGained > 0 && (
                            <div className="flex items-center gap-2">
                                <p>You gained:</p> {renderResourceIcons({ silver: report.silverGained })}
                            </div>
                        )}
                    </div>
                );
            case 'reinforce':
                const originReinforcePlayer = report.originPlayer || {};
                const targetReinforcePlayer = report.targetPlayer || {};
                return (
                    <div className="space-y-1">
                        <p className="font-bold text-blue-600">Reinforcement Arrived</p>
                        <p><strong>From:</strong> <span dangerouslySetInnerHTML={{ __html: parseBBCode(`[city id=${originReinforcePlayer.cityId} owner=${originReinforcePlayer.id} x=${originReinforcePlayer.x} y=${originReinforcePlayer.y}]${report.originCityName}[/city]`) }}></span></p>
                        <p><strong>To:</strong> <span dangerouslySetInnerHTML={{ __html: parseBBCode(`[city id=${targetReinforcePlayer.cityId} owner=${targetReinforcePlayer.id} x=${targetReinforcePlayer.x} y=${targetReinforcePlayer.y}]${report.targetCityName}[/city]`) }}></span></p>
                        <p><strong>Units:</strong></p>
                        {renderTroopDisplay(report.units)}
                    </div>
                );
            case 'trade':
                const originPlayer = report.originPlayer || {};
                const targetPlayer = report.targetPlayer || {};
                return (
                    <div className="space-y-1">
                        <p className="font-bold text-yellow-600">Trade Complete</p>
                        <p><strong>From:</strong> <span dangerouslySetInnerHTML={{ __html: parseBBCode(`[city id=${originPlayer.cityId} owner=${originPlayer.id} x=${originPlayer.x} y=${originPlayer.y}]${report.originCityName}[/city]`) }}></span></p>
                        <p><strong>To:</strong> <span dangerouslySetInnerHTML={{ __html: parseBBCode(`[city id=${targetPlayer.cityId} owner=${targetPlayer.id} x=${targetPlayer.x} y=${targetPlayer.y}]${report.targetCityName}[/city]`) }}></span></p>
                        <div className="flex flex-wrap gap-2 mt-2">
                            <strong>Resources:</strong> {renderResourceIcons(report.resources)}
                        </div>
                    </div>
                );
            default:
                return <p>Report type not recognized.</p>;
        }
    };

    const filteredReports = reports.filter(report => {
        if (gameSettings.hideReturningReports && report.type === 'return') {
            return false;
        }
        return tabs[activeTab]?.includes(report.type);
    });

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
            <div
                ref={reportsRef}
                className="reports-container"
                onClick={e => e.stopPropagation()}
                onMouseDown={handleMouseDown}
                style={{ top: `${position.y}px`, left: `${position.x}px` }}
            >
                <div className="reports-header">
                    <h2 className="font-title text-3xl">Reports</h2>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="flex flex-grow overflow-hidden">
                    <div className="w-1/3 border-r-2 border-[#8B4513] flex flex-col">
                        <div className="reports-tabs">
                            {Object.keys(tabs).map(tabName => {
                                const unreadCount = reports.filter(report => tabs[tabName].includes(report.type) && !report.read).length;
                                const hasUnread = unreadCount > 0;
                                return (
                                    <button
                                        key={tabName}
                                        onClick={() => handleTabClick(tabName)}
                                        className={`tab-btn ${activeTab === tabName ? 'active' : ''} ${hasUnread ? 'glowing-tab' : ''}`}
                                    >
                                        {tabName}
                                        {hasUnread && <span className="tab-badge">{unreadCount}</span>}
                                    </button>
                                )
                            })}
                        </div>
                        <ul className="overflow-y-auto reports-list">
                            {filteredReports.length > 0 ? (
                                filteredReports.map(report => (
                                    <li
                                        key={report.id}
                                        className={`report-item ${selectedReport && selectedReport.id === report.id ? 'selected' : ''} ${!report.read ? 'unread' : ''}`}
                                        onClick={() => handleSelectReport(report)}
                                    >
                                        <div className="flex justify-between items-center">
                                            <span className={`truncate pr-2 ${getReportTitleColor(report)}`}>
                                                {getReportTitle(report)}
                                            </span>
                                            <div className="flex gap-2">
                                                <button onClick={(e) => { e.stopPropagation(); handleShareReport(report); }} className="text-blue-500 hover:text-blue-400">Share</button>
                                                <button onClick={(e) => { e.stopPropagation(); handleDeleteReport(report.id); }} className="delete-btn">&times;</button>
                                            </div>
                                        </div>
                                        <p className="text-xs text-gray-500">{report.timestamp?.toDate().toLocaleString()}</p>
                                    </li>
                                ))
                            ) : (
                                <p className="p-4 text-center text-gray-500">No reports in this category.</p>
                            )}
                        </ul>
                    </div>
                    <div className="w-2/3 p-4 overflow-y-auto report-outcome-container" onClick={handleContentClick}>
                        {message && <p className="text-center text-green-500 mb-2">{message}</p>}
                        {selectedReport ? (
                            <div>
                                <h3 className="text-lg font-bold mb-2">{selectedReport.title || 'Report Details'}</h3>
                                <div className="space-y-2">
                                    {renderReportOutcome(selectedReport)}
                                </div>
                            </div>
                        ) : (
                            <div className="flex items-center justify-center h-full">
                                <p className="text-gray-500">Select a report to view its details.</p>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default ReportsView;
</file>

<file path="src/components/SelectionScreen.js">
// src/components/SelectionScreen.js
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { useGame } from '../contexts/GameContext';
import { doc, runTransaction, collection, query, where, limit, getDocs } from "firebase/firestore";
import { db } from '../firebase/config';
import Modal from './shared/Modal';
import buildingConfig from '../gameData/buildings.json';

const nationsByReligion = {
    'Greek': ['Athenian', 'Spartan', 'Corinthian'],
    'Roman': ['Julian', 'Cornelian', 'Fabian'],
    'Egyptian': ['Ptolemaic', 'Nubian', 'Bedouin']
};

const SelectionScreen = () => {
    const { currentUser, userProfile, loading: authLoading } = useAuth();
    const { worldState } = useGame();
    const [selectedReligion, setSelectedReligion] = useState(null);
    const [selectedNation, setSelectedNation] = useState(null);
    const [message, setMessage] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);

    const placeNewCity = async (userId, userEmail, username, religion, nation) => {
        if (!worldState || !worldState.id) {
            setMessage("World data is not loaded correctly.");
            return;
        }

        const worldId = worldState.id;
        const citySlotsCollectionRef = collection(db, 'worlds', worldId, 'citySlots');
        
        let claimed = false;
        let attempts = 0;
        const maxAttempts = 5;
        const fetchLimit = 10; // Fetch more empty slots at once

        while (!claimed && attempts < maxAttempts) {
            attempts++;
            // Capture the current value of 'attempts' for this iteration
            const currentAttempt = attempts; 

            let availableSlots = [];
            try {
                // Fetch a batch of available slots
                const q = query(citySlotsCollectionRef, where("ownerId", "==", null), limit(fetchLimit));
                const querySnapshot = await getDocs(q);
                
                if (querySnapshot.empty) {
                    setMessage("This world is full! No empty city slots are available.");
                    return; // No slots found, exit
                }
                availableSlots = querySnapshot.docs;
            } catch (error) {
                console.error(`Error fetching empty slots (attempt ${currentAttempt}):`, error);
                setMessage(`Failed to find a location due to a technical issue. Retrying... (${currentAttempt}/${maxAttempts})`);
                await new Promise(resolve => setTimeout(resolve, 1000 * currentAttempt)); // Use currentAttempt here
                continue; // Try fetching again
            }

            // Try to claim one of the fetched slots
            for (const emptySlotDoc of availableSlots) {
                const emptySlotRef = emptySlotDoc.ref;
                try {
                    await runTransaction(db, async (transaction) => {
                        const slotSnap = await transaction.get(emptySlotRef);
                        if (!slotSnap.exists() || slotSnap.data().ownerId !== null) {
                            // This slot was taken, throw to try the next one in the list
                            throw new Error("Slot was already taken. Trying another...");
                        }

                        const newCityName = `${username}'s Landing`;
                        const faction = `${nation} (${religion})`;
                        transaction.update(emptySlotRef, {
                            ownerId: userId,
                            ownerEmail: userEmail,
                            ownerUsername: username,
                            cityName: newCityName,
                            ownerFaction: faction
                        });

                        const gameDocRef = doc(db, `users/${userId}/games`, worldId);
                        
                        const initialBuildings = {};
                        // All buildings from config start at level 0
                        for (const buildingId in buildingConfig) {
                            initialBuildings[buildingId] = { level: 0 };
                        }
                        // Set specific buildings to level 1
                        initialBuildings.senate = { level: 1 };
                        initialBuildings.farm = { level: 1 };
                        initialBuildings.warehouse = { level: 1 };
                        initialBuildings.timber_camp = { level: 1 };
                        initialBuildings.quarry = { level: 1 };
                        initialBuildings.silver_mine = { level: 1 };

                        const newGameState = {
                            cityName: newCityName,
                            playerInfo: { religion, nation },
                            resources: { wood: 500, stone: 500, silver: 100 },
                            buildings: initialBuildings,
                            units: {},
                            cave: { silver: 0 },
                            lastUpdated: Date.now(), 
                            cityLocation: {
                                mapId: worldId,
                                slotId: emptySlotDoc.id,
                                islandId: slotSnap.data().islandId
                            }
                        };
                        transaction.set(gameDocRef, newGameState);
                    });
                    claimed = true; // Successfully claimed a slot, exit outer loop
                    console.log("Transaction successful: City placed!");
                    return; // Exit the function after successful claim
                } catch (e) {
                    console.warn(`Failed to claim slot ${emptySlotDoc.id}: ${e.message}`);
                    // Continue to next slot in availableSlots array
                }
            }
            if (!claimed && currentAttempt < maxAttempts) { // Use currentAttempt here
                setMessage(`Failed to claim any of the found slots. Retrying to find new ones... (${currentAttempt}/${maxAttempts})`); // Use currentAttempt here
                await new Promise(resolve => setTimeout(resolve, 1000 * currentAttempt)); // Use currentAttempt here
            }
        }

        if (!claimed) {
            setMessage(`Could not place your city after ${maxAttempts} attempts. The world might be full or under heavy load. Please try again later.`);
        }
    };

    const handleConfirm = async () => {
        if (!selectedReligion || !selectedNation) {
            setMessage("Please select both a religion and a nation.");
            return;
        }
        if (authLoading || !userProfile || !userProfile.username) {
            setMessage("User profile is not loaded yet. Please wait a moment and try again.");
            return;
        }
        setIsSubmitting(true);
        setMessage("Founding your first city...");
        await placeNewCity(currentUser.uid, currentUser.email, userProfile.username, selectedReligion, selectedNation);
        setIsSubmitting(false);
    };

    const isButtonDisabled = !selectedReligion || !selectedNation || isSubmitting || authLoading;

    return (
        <div className="w-full min-h-screen flex items-center justify-center p-4">
             <Modal message={message} onClose={() => setMessage('')} />
            <div className="w-full max-w-2xl">
                <div className="bg-gray-800 p-8 rounded-lg shadow-2xl">
                    <h1 className="font-title text-4xl text-center text-gray-300 mb-6">Choose Your Path</h1>
                    <p className="text-center text-gray-400 mb-8">Your choice of Religion and Nation will define your journey in this world.</p>
                    <div className="mb-8">
                        <h2 className="font-title text-2xl text-gray-300 mb-4">Select Religion</h2>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            {Object.keys(nationsByReligion).map(religion => (
                                <div key={religion} onClick={() => { setSelectedReligion(religion); setSelectedNation(null); }} className={`selection-card p-4 rounded-lg text-center ${selectedReligion === religion ? 'selected' : ''}`}>
                                    <h3 className="text-xl font-bold">{religion}</h3>
                                </div>
                            ))}
                        </div>
                    </div>
                    {selectedReligion && (
                        <div className="mb-8">
                            <h2 className="font-title text-2xl text-gray-300 mb-4">Select Nation</h2>
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                {nationsByReligion[selectedReligion].map(nation => (
                                    <div key={nation} onClick={() => setSelectedNation(nation)} className={`selection-card p-4 rounded-lg text-center ${selectedNation === nation ? 'selected' : ''}`}>
                                        <h3 className="text-xl font-bold">{nation}</h3>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    <button onClick={handleConfirm} disabled={isButtonDisabled} className="w-full btn btn-confirm font-bold py-3 rounded-lg disabled:btn-disabled">
                         {isSubmitting ? 'Founding City...' : (authLoading ? 'Loading Profile...' : 'Found My Empire')}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SelectionScreen;
</file>

<file path="src/components/shared/LoadingScreen.js">
import React from 'react';

/**
 * A simple loading screen component.
 * @param {object} props - The component props.
 * @param {string} [props.message='Loading...'] - The message to display below the spinner.
 * @returns {JSX.Element} The rendered loading screen.
 */
const LoadingScreen = ({ message = 'Loading...' }) => {
    return (
        <div className="w-full h-screen flex flex-col items-center justify-center bg-gray-900 text-white">
            {/* A simple CSS spinner */}
            <div className="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-blue-500"></div>
            <p className="mt-4 text-lg font-semibold">{message}</p>
        </div>
    );
};

export default LoadingScreen;
</file>

<file path="src/components/shared/Modal.js">
import React from 'react';

const Modal = ({ message, title, children, onClose }) => {
    // Render nothing if no message, title, or children are provided
    if (!message && !title && !children) return null;

    return (
        <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-60"
            onClick={onClose} // Close modal on backdrop click
        >
            <div
                className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-center border border-gray-600"
                onClick={e => e.stopPropagation()} // Prevent modal from closing when clicking inside it
            >
                {title && <h2 className="text-2xl font-bold mb-4 text-center text-yellow-400">{title}</h2>}
                {message && <p className="mb-4 text-lg text-gray-300">{message}</p>}
                {children} {/* Render children passed to the modal */}
                <button
                    onClick={onClose}
                    className="btn btn-primary px-6 py-2 mt-4"
                >
                    Close
                </button>
            </div>
        </div>
    );
};

export default Modal;
</file>

<file path="src/components/shared/Notification.css">
/* src/components/shared/Notification.css */
@keyframes slideInFromRight {
    from {
        opacity: 0;
        transform: translateX(100%);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

.notification-wrapper {
    position: relative;
    width: 60px;
    height: 60px;
    margin-bottom: 8px;
    animation: slideInFromRight 0.5s cubic-bezier(0.215, 0.610, 0.355, 1.000) forwards;
}
.notification-wrapper:last-child {
    margin-bottom: 0;
}

.notification-container {
    position: absolute;
    top: -100%;
    right: 0;
    display: flex;
    align-items: center;
    width: 60px;
    height: 60px;
    background-color: rgba(30, 41, 59, 0.9); /* slate-800 with opacity */
    color: #e2e8f0; /* slate-200 */
    border: 1px solid #475569; /* slate-600 */
    border-radius: 50%;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    overflow: hidden;
    transition: width 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), border-radius 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
    z-index: 1;
}

.notification-wrapper:hover .notification-container {
    width: 320px; /* Expand on hover */
    border-radius: 8px; /* Become rectangular on hover */
    z-index: 2;
}

.notification-icon-wrapper {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}

.notification-icon {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

.notification-content {
    flex-grow: 1;
    opacity: 0; /* Hidden by default */
    transition: opacity 0.2s 0.2s ease-in-out; /* Delay opacity transition */
    white-space: nowrap;
    overflow: hidden;
    margin-left: 60px; /* Make space for the icon */
    padding-right: 10px;
}

.notification-wrapper:hover .notification-content {
    opacity: 1; /* Show on hover */
    white-space: normal;
}

.notification-message {
    font-size: 0.9rem;
}

.notification-progress-bar {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 4px;
    background-color: #38bdf8; /* sky-400 */
    animation: shrink 5s linear forwards;
}

@keyframes shrink {
    from {
        width: 100%;
    }
    to {
        width: 0%;
    }
}
</file>

<file path="src/components/shared/Notification.js">
import React, { useEffect, useState } from 'react';
import './Notification.css';
import buildingConfig from '../../gameData/buildings.json';
import unitConfig from '../../gameData/units.json';

// #comment Dynamically import all images
const images = {};
const imageContexts = [
    require.context('../../images/troops', false, /\.(png|jpe?g|svg)$/),
    require.context('../../images/buildings', false, /\.(png|jpe?g|svg)$/),
];
imageContexts.forEach(context => {
    context.keys().forEach((item) => {
        const key = item.replace('./', '');
        images[key] = context(item);
    });
});

const Notification = ({ message, iconType, iconId, onClose }) => {
    const [iconSrc, setIconSrc] = useState('');

    useEffect(() => {
        let imagePath = '';
        if (iconType === 'building' && buildingConfig[iconId]) {
            imagePath = buildingConfig[iconId].image;
        } else if (iconType === 'unit' && unitConfig[iconId]) {
            imagePath = unitConfig[iconId].image;
        }
        
        if (imagePath && images[imagePath]) {
            setIconSrc(images[imagePath]);
        }
    }, [iconType, iconId]);

    // #comment Automatically trigger the close function after the animation duration
    useEffect(() => {
        const timer = setTimeout(() => {
            onClose();
        }, 5000); // This duration should match the CSS animation timings

        return () => clearTimeout(timer);
    }, [onClose]);

    return (
        <div className="notification-wrapper">
            <div className="notification-container">
                <div className="notification-icon-wrapper">
                    {iconSrc && <img src={iconSrc} alt="icon" className="notification-icon" />}
                </div>
                <div className="notification-content">
                    <p className="notification-message">{message}</p>
                </div>
                <div className="notification-progress-bar"></div>
            </div>
        </div>
    );
};

export default Notification;
</file>

<file path="src/components/shared/SettingsModal.js">
import React, { useState } from 'react';
import { useGame } from '../../contexts/GameContext';
import { useAuth } from '../../contexts/AuthContext';
import { db } from '../../firebase/config';
import { doc, writeBatch, collection, getDocs, query} from 'firebase/firestore';
import { v4 as uuidv4 } from 'uuid';

const ConfirmationModal = ({ message, onConfirm, onCancel, confirmText = 'Confirm', cancelText = 'Cancel' }) => {
    return (
        <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black bg-opacity-70">
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-center border border-gray-600 text-white">
                <p className="mb-6 text-lg">{message}</p>
                <div className="flex justify-center space-x-4">
                    <button onClick={onCancel} className="btn btn-primary px-6 py-2">
                        {cancelText}
                    </button>
                    <button onClick={onConfirm} className="btn btn-danger px-6 py-2">
                        {confirmText}
                    </button>
                </div>
            </div>
        </div>
    );
};


const SettingsModal = ({ onClose }) => {
    const { gameSettings, setGameSettings, worldId, playerCity, activeCityId } = useGame();
    const { currentUser } = useAuth();
    const [activeTab, setActiveTab] = useState('gameplay');
    const [confirmAction, setConfirmAction] = useState(null);

    const handleChange = (e) => {
        const { name, type, checked, value } = e.target;
        setGameSettings(prevSettings => ({
            ...prevSettings,
            [name]: type === 'checkbox' ? checked : value
        }));
    };

    // #comment handle changes for worker preset inputs
    const handlePresetChange = (e) => {
        const { name, value } = e.target;
        setGameSettings(prev => ({
            ...prev,
            workerPresets: {
                ...prev.workerPresets,
                [name]: parseInt(value, 10) || 0
            }
        }));
    };

    const handleSave = () => {

        onClose();
    };

    const handleResetGame = async () => {
        if (!worldId || !currentUser || !playerCity || !activeCityId) {
            console.error("Missing world, user, or city data for reset.");
            setConfirmAction(null);
            return;
        }

        const batch = writeBatch(db);


        const ruinId = uuidv4();
        const ruinDocRef = doc(db, 'worlds', worldId, 'ruins', ruinId);
        const newRuinData = {
            id: ruinId,
            x: playerCity.x,
            y: playerCity.y,
            name: `Abandoned City of ${playerCity.cityName}`,
            ownerId: 'ruins',
            ownerUsername: 'Ancient Guardians',
            troops: {
                hoplite: 50,
                swordsman: 50,
                archer: 30
            },
            researchReward: `qol_research_${Math.floor(Math.random() * 3)}`
        };
        batch.set(ruinDocRef, newRuinData);


        const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', playerCity.slotId);
        batch.update(citySlotRef, {
            ownerId: null,
            ownerUsername: null,
            cityName: 'Unclaimed',
            ownerFaction: null,
            alliance: null,
            allianceName: null
        });

        const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);


        const deleteSubcollection = async (subcollectionPath) => {
            const collectionRef = collection(gameDocRef, subcollectionPath);
            const q = query(collectionRef);
            const snapshot = await getDocs(q);
            snapshot.docs.forEach(doc => {
                batch.delete(doc.ref);
            });
        };

        await deleteSubcollection('cities');
        await deleteSubcollection('conqueredVillages');
        await deleteSubcollection('conqueredRuins');
        await deleteSubcollection('quests');


        batch.delete(gameDocRef);


        try {
            await batch.commit();
            setConfirmAction(null);
            onClose();
        } catch (error) {
            console.error("Error resetting game:", error);
            setConfirmAction({
                message: `Failed to reset game: ${error.message}`,
                onConfirm: () => setConfirmAction(null),
                onCancel: () => setConfirmAction(null),
                confirmText: 'OK',
                cancelText: null
            });
        }
    };


    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            {confirmAction && (
                <ConfirmationModal
                    message={confirmAction.message}
                    onConfirm={confirmAction.onConfirm}
                    onCancel={confirmAction.onCancel}
                    confirmText={confirmAction.confirmText}
                    cancelText={confirmAction.cancelText}
                />
            )}
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border-2 border-gray-600 text-white" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-2xl font-bold text-center text-yellow-400">Game Settings</h2>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>

                <div className="settings-tabs mb-4 flex border-b border-gray-600">
                    <button onClick={() => setActiveTab('gameplay')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'gameplay' ? 'bg-gray-700 text-white' : 'text-gray-400 hover:bg-gray-700'}`}>Gameplay</button>
                    <button onClick={() => setActiveTab('display')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'display' ? 'bg-gray-700 text-white' : 'text-gray-400 hover:bg-gray-700'}`}>Display</button>
                    <button onClick={() => setActiveTab('notifications')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'notifications' ? 'bg-gray-700 text-white' : 'text-gray-400 hover:bg-gray-700'}`}>Notifications</button>
                    <button onClick={() => setActiveTab('account')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'account' ? 'bg-gray-700 text-white' : 'text-gray-400 hover:bg-gray-700'}`}>Account</button>
                </div>

                <div className="space-y-4">
                    {activeTab === 'gameplay' && (
                        <>
                            <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                                <label htmlFor="showVisuals" className="text-lg font-semibold">Enable Visuals</label>
                                <input
                                    type="checkbox"
                                    id="showVisuals"
                                    name="showVisuals"
                                    checked={gameSettings.showVisuals}
                                    onChange={handleChange}
                                    className="w-6 h-6 rounded text-blue-600 bg-gray-600 border-gray-500 focus:ring-blue-500"
                                />
                            </div>

                            <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                                <label htmlFor="showGrid" className="text-lg font-semibold">Enable Grid</label>
                                <input
                                    type="checkbox"
                                    id="showGrid"
                                    name="showGrid"
                                    checked={gameSettings.showGrid}
                                    onChange={handleChange}
                                    className="w-6 h-6 rounded text-blue-600 bg-gray-600 border-gray-500 focus:ring-blue-500"
                                />
                            </div>

                            <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                                <label htmlFor="animations" className="text-lg font-semibold">Enable Animations</label>
                                <input
                                    type="checkbox"
                                    id="animations"
                                    name="animations"
                                    checked={gameSettings.animations}
                                    onChange={handleChange}
                                    className="w-6 h-6 rounded text-blue-600 bg-gray-600 border-gray-500 focus:ring-blue-500"
                                />
                            </div>
                        </>
                    )}

                    {activeTab === 'display' && (
                        <>
                            <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                                <label htmlFor="theme" className="text-lg font-semibold">Theme</label>
                                <select
                                    id="theme"
                                    name="theme"
                                    value={gameSettings.theme}
                                    onChange={handleChange}
                                    className="bg-gray-600 text-white p-2 rounded"
                                >
                                    <option value="dark">Dark</option>
                                    <option value="light">Light</option>
                                </select>
                            </div>
                            <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                                <label htmlFor="mapZoomSensitivity" className="text-lg font-semibold">Map Zoom Sensitivity</label>
                                <input
                                    type="range"
                                    id="mapZoomSensitivity"
                                    name="mapZoomSensitivity"
                                    min="0.1"
                                    max="1"
                                    step="0.1"
                                    value={gameSettings.mapZoomSensitivity}
                                    onChange={handleChange}
                                    className="w-1/2"
                                />
                            </div>
                            <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                                <label htmlFor="hideCompletedQuestsIcon" className="text-lg font-semibold">Hide Quest Icon When Done</label>
                                <input
                                    type="checkbox"
                                    id="hideCompletedQuestsIcon"
                                    name="hideCompletedQuestsIcon"
                                    checked={gameSettings.hideCompletedQuestsIcon || false}
                                    onChange={handleChange}
                                    className="w-6 h-6 rounded text-blue-600 bg-gray-600 border-gray-500 focus:ring-blue-500"
                                />
                            </div>
                        </>
                    )}

                    {activeTab === 'automation' && (
                        <>
                            <h3 className="text-xl font-semibold text-center">Worker Presets</h3>
                            <p className="text-sm text-gray-400 text-center mb-4">Set the desired number of workers for each resource building. You can apply these presets from the Senate.</p>
                            <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                                <label htmlFor="timber_camp_preset" className="text-lg font-semibold">Timber Camp</label>
                                <input
                                    type="number"
                                    id="timber_camp_preset"
                                    name="timber_camp"
                                    value={gameSettings.workerPresets?.timber_camp || 0}
                                    onChange={handlePresetChange}
                                    className="bg-gray-600 text-white p-2 rounded w-24 text-center"
                                    min="0"
                                />
                            </div>
                            <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                                <label htmlFor="quarry_preset" className="text-lg font-semibold">Quarry</label>
                                <input
                                    type="number"
                                    id="quarry_preset"
                                    name="quarry"
                                    value={gameSettings.workerPresets?.quarry || 0}
                                    onChange={handlePresetChange}
                                    className="bg-gray-600 text-white p-2 rounded w-24 text-center"
                                    min="0"
                                />
                            </div>
                            <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                                <label htmlFor="silver_mine_preset" className="text-lg font-semibold">Silver Mine</label>
                                <input
                                    type="number"
                                    id="silver_mine_preset"
                                    name="silver_mine"
                                    value={gameSettings.workerPresets?.silver_mine || 0}
                                    onChange={handlePresetChange}
                                    className="bg-gray-600 text-white p-2 rounded w-24 text-center"
                                    min="0"
                                />
                            </div>
                        </>
                    )}

                    {activeTab === 'notifications' && (
                        <>
                            <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                                <label htmlFor="attackNotifications" className="text-lg font-semibold">Incoming Attack Alerts</label>
                                <input
                                    type="checkbox"
                                    id="attackNotifications"
                                    name="attackNotifications"
                                    checked={gameSettings.attackNotifications}
                                    onChange={handleChange}
                                    className="w-6 h-6 rounded text-blue-600 bg-gray-600 border-gray-500 focus:ring-blue-500"
                                />
                            </div>
                            <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                                <label htmlFor="tradeNotifications" className="text-lg font-semibold">Trade Completed Alerts</label>
                                <input
                                    type="checkbox"
                                    id="tradeNotifications"
                                    name="tradeNotifications"
                                    checked={gameSettings.tradeNotifications}
                                    onChange={handleChange}
                                    className="w-6 h-6 rounded text-blue-600 bg-gray-600 border-gray-500 focus:ring-blue-500"
                                />
                            </div>
                            <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                                <label htmlFor="unitCompleteNotifications" className="text-lg font-semibold">Recruitment Complete</label>
                                <input
                                    type="checkbox"
                                    id="unitCompleteNotifications"
                                    name="unitCompleteNotifications"
                                    checked={gameSettings.unitCompleteNotifications}
                                    onChange={handleChange}
                                    className="w-6 h-6 rounded text-blue-600 bg-gray-600 border-gray-500 focus:ring-blue-500"
                                />
                            </div>
                            <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                                <label htmlFor="hideReturningReports" className="text-lg font-semibold">Hide Returning Troop Reports</label>
                                <input
                                    type="checkbox"
                                    id="hideReturningReports"
                                    name="hideReturningReports"
                                    checked={gameSettings.hideReturningReports || false}
                                    onChange={handleChange}
                                    className="w-6 h-6 rounded text-blue-600 bg-gray-600 border-gray-500 focus:ring-blue-500"
                                />
                            </div>
                        </>
                    )}

                    {activeTab === 'account' && (
                        <>
                            <p className="text-sm text-gray-400">Warning: This action is irreversible!</p>
                            <button
                                onClick={() => setConfirmAction({
                                    message: "Are you absolutely sure you want to reset your game? This will destroy all your cities and cannot be undone.",
                                    onConfirm: handleResetGame,
                                    onCancel: () => setConfirmAction(null),
                                    confirmText: 'Reset Forever',
                                    cancelText: 'Cancel'
                                })}
                                className="btn btn-danger w-full py-2"
                            >
                                Reset Game
                            </button>
                        </>
                    )}
                </div>

                <div className="mt-6 flex justify-center space-x-4">
                    <button
                        onClick={handleSave}
                        className="btn btn-confirm py-2 px-6"
                    >
                        Close
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SettingsModal;
</file>

<file path="src/components/shared/TextEditor.css">
.text-editor-container {
    background-color: #fdf6e7;
    border: 1px solid #d2b48c;
    border-radius: 4px;
    color: #4a2c2a;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.editor-toolbar {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    padding: 4px;
    background-color: #e6cba8;
    border-bottom: 1px solid #d2b48c;
    flex-shrink: 0;
}
.toolbar-btn {
    background-color: #f0e68c;
    border: 1px solid #8B4513;
    color: #4a2c2a;
    font-weight: bold;
    width: 28px;
    height: 28px;
    margin: 2px;
    cursor: pointer;
    transition: background-color 0.2s;
}
.toolbar-btn:hover {
    background-color: #fff2b2;
}
.toolbar-btn.italic {
    font-style: italic;
}
.toolbar-btn.underline {
    text-decoration: underline;
}
.editor-textarea {
    width: 100%;
    flex-grow: 1;
    background-color: transparent;
    border: none;
    padding: 0.5rem;
    color: #4a2c2a;
    resize: none;
}
.editor-textarea:focus {
    outline: none;
}
.mention-input-popup {
    position: fixed;
    z-index: 120;
    background-color: #e6cba8;
    border: 1px solid #8B4513;
    padding: 8px;
    border-radius: 4px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}
.mention-input {
    width: 100%;
    padding: 0.5rem;
    border-radius: 4px;
    background-color: rgba(255, 255, 255, 0.5);
    border: 1px solid #d2b48c;
    color: #4a2c2a;
}
.mention-suggestions {
    list-style: none;
    padding: 0;
    margin: 4px 0 0 0;
    max-height: 120px;
    overflow-y: auto;
}
.mention-suggestions li {
    padding: 0.5rem;
    cursor: pointer;
}
.mention-suggestions li:hover {
    background-color: #d2b48c;
}
</file>

<file path="src/components/shared/TextEditor.js">
import React, { useRef, useState, useEffect } from 'react';
import { db } from '../../firebase/config';
import { collection, getDocs, query, where } from 'firebase/firestore';
import { useGame } from '../../contexts/GameContext';
import './TextEditor.css';

// #comment Input component for BBCode mentions with autocomplete
const MentionInput = ({ type, data, onSelect, onClose, buttonRef }) => {
    const [inputValue, setInputValue] = useState('');
    const [suggestions, setSuggestions] = useState([]);
    const popupRef = useRef(null);
    const inputRef = useRef(null);

    // #comment Position the popup relative to the button that opened it
    const popupStyle = () => {
        if (!buttonRef) return {};
        const rect = buttonRef.getBoundingClientRect();
        return {
            top: `${rect.bottom + window.scrollY + 5}px`,
            left: `${rect.left + window.scrollX}px`,
        };
    };

    // #comment Filter suggestions based on user input for players, cities, and alliances
    useEffect(() => {
        if (type === 'player' || type === 'city' || type === 'alliance') {
            if (inputValue.length > 0) {
                const filtered = data.filter(item => item.toLowerCase().startsWith(inputValue.toLowerCase()));
                setSuggestions(filtered.slice(0, 5)); // Limit to 5 suggestions
            } else {
                setSuggestions([]);
            }
        }
    }, [inputValue, data, type]);

    // #comment Focus the input field when the popup opens
    useEffect(() => {
        inputRef.current?.focus();
    }, []);

    // #comment Close the popup if the user clicks outside of it
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (popupRef.current && !popupRef.current.contains(event.target)) {
                onClose();
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, [onClose]);

    const handleSubmit = (value) => {
        if (value.trim()) {
            onSelect(value.trim());
        }
    };

    const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            handleSubmit(inputValue);
        } else if (e.key === 'Escape') {
            onClose();
        }
    };

    return (
        <div ref={popupRef} className="mention-input-popup" style={popupStyle()}>
            <input
                ref={inputRef}
                type="text"
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyDown={handleKeyDown}
                placeholder={`Enter ${type} name...`}
                className="mention-input"
            />
            {(type === 'player' || type === 'city' || type === 'alliance') && suggestions.length > 0 && (
                <ul className="mention-suggestions">
                    {suggestions.map(item => (
                        <li key={item} onClick={() => handleSubmit(item)}>
                            {item}
                        </li>
                    ))}
                </ul>
            )}
        </div>
    );
};

// #comment Cache for editor autocomplete data to reduce reads.
const editorDataCache = {
    players: null,
    cities: null,
    alliances: null,
    timestamp: 0,
};


// #comment The main text editor component
const TextEditor = ({ value, onChange }) => {
    const { worldId } = useGame();
    const textareaRef = useRef(null);
    const [showColors, setShowColors] = useState(false);
    const [mentionState, setMentionState] = useState({ visible: false, type: null, buttonRef: null });

    const [players, setPlayers] = useState([]);
    const [cities, setCities] = useState([]);
    const [alliances, setAlliances] = useState([]);

    // #comment Fetch players, cities, and alliances for autocomplete, using a cache.
    useEffect(() => {
        if (!worldId) return;

        const fetchData = async () => {
            const now = Date.now();
            const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

            if (now - editorDataCache.timestamp < CACHE_DURATION && editorDataCache.players) {
                setPlayers(editorDataCache.players);
                setCities(editorDataCache.cities);
                setAlliances(editorDataCache.alliances);
                return;
            }

            // Fetch all data in parallel if cache is stale
            const usersRef = collection(db, 'users');
            const citiesRef = collection(db, 'worlds', worldId, 'citySlots');
            const alliancesRef = collection(db, 'worlds', worldId, 'alliances');

            const playersQuery = getDocs(usersRef);
            const citiesQuery = getDocs(query(citiesRef, where("ownerId", "!=", null)));
            const alliancesQuery = getDocs(alliancesRef);

            const [playersSnapshot, citiesSnapshot, alliancesSnapshot] = await Promise.all([
                playersQuery,
                citiesQuery,
                alliancesQuery
            ]);

            const playersData = playersSnapshot.docs.map(doc => doc.data().username);
            const citiesData = citiesSnapshot.docs.map(doc => doc.data().cityName);
            const alliancesData = alliancesSnapshot.docs.map(doc => doc.data().name);

            setPlayers(playersData);
            setCities(citiesData);
            setAlliances(alliancesData);

            // Update cache
            editorDataCache.players = playersData;
            editorDataCache.cities = citiesData;
            editorDataCache.alliances = alliancesData;
            editorDataCache.timestamp = now;
        };

        fetchData();
    }, [worldId]);

    const applyFormat = (tag, param = '') => {
        const textarea = textareaRef.current;
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        let selectedText = value.substring(start, end);
        
        // #comment If no text is selected, use the parameter as the content
        if (!selectedText && param) {
            selectedText = param;
        }

        let openTag = `[${tag}${param && tag !== 'url' ? `=${param}` : ''}]`;
        if (tag === 'url' && param) {
            openTag = `[url=${selectedText}]`;
            selectedText = param; // The param becomes the display text
        }

        const closeTag = `[/${tag}]`;
        const newText = `${value.substring(0, start)}${openTag}${selectedText}${closeTag}${value.substring(end)}`;
        
        onChange(newText);

        setTimeout(() => {
            textarea.focus();
            const newCursorPos = start + openTag.length + selectedText.length + closeTag.length;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
        }, 0);
    };
    
    const handleColorClick = (color) => {
        applyFormat('color', color);
        setShowColors(false);
    };

    const handleMentionButtonClick = (type, e) => {
        setMentionState({
            visible: true,
            type: type,
            buttonRef: e.currentTarget,
        });
    };

    const handleMentionSelect = (name) => {
        applyFormat(mentionState.type, name);
        setMentionState({ visible: false, type: null, buttonRef: null });
    };
    
    const colors = ['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];

    return (
        <div className="text-editor-container">
             {mentionState.visible && (
                <MentionInput
                    type={mentionState.type}
                    data={
                        mentionState.type === 'player' ? players :
                        mentionState.type === 'city' ? cities :
                        mentionState.type === 'alliance' ? alliances : []
                    }
                    onSelect={handleMentionSelect}
                    onClose={() => setMentionState({ visible: false, type: null, buttonRef: null })}
                    buttonRef={mentionState.buttonRef}
                />
            )}
            <div className="editor-toolbar">
                <button type="button" onClick={() => applyFormat('b')} className="toolbar-btn" title="Bold">B</button>
                <button type="button" onClick={() => applyFormat('i')} className="toolbar-btn italic" title="Italic">I</button>
                <button type="button" onClick={() => applyFormat('u')} className="toolbar-btn underline" title="Underline">U</button>
                <button type="button" onClick={() => applyFormat('spoiler')} className="toolbar-btn" title="Spoiler">S</button>
                <div className="relative">
                    <button type="button" onClick={() => setShowColors(!showColors)} className="toolbar-btn" title="Text Color">A</button>
                    {showColors && (
                        <div className="color-palette">
                            {colors.map(color => (
                                <button key={color} type="button" onClick={() => handleColorClick(color)} className="color-swatch" style={{ backgroundColor: color }} />
                            ))}
                        </div>
                    )}
                </div>
                <button type="button" onClick={() => applyFormat('size', '10')} className="toolbar-btn" title="Font Size">Size</button>
                <button type="button" onClick={() => applyFormat('img')} className="toolbar-btn" title="Image">Img</button>
                <button type="button" onClick={() => applyFormat('url', 'Link Text')} className="toolbar-btn" title="URL">URL</button>
                <button type="button" onClick={(e) => handleMentionButtonClick('player', e)} className="toolbar-btn" title="Player">P</button>
                <button type="button" onClick={(e) => handleMentionButtonClick('alliance', e)} className="toolbar-btn" title="Alliance">A</button>
                <button type="button" onClick={(e) => handleMentionButtonClick('city', e)} className="toolbar-btn" title="City">C</button>
                <button type="button" onClick={(e) => handleMentionButtonClick('island', e)} className="toolbar-btn" title="Island">I</button>
            </div>
            <textarea
                ref={textareaRef}
                value={value}
                onChange={(e) => onChange(e.target.value)}
                className="editor-textarea"
            />
        </div>
    );
};

export default TextEditor;
</file>

<file path="src/components/SharedReportView.js">
// src/components/SharedReportView.js
import React, { useState, useEffect } from 'react';
import { doc, getDoc } from 'firebase/firestore';
import { db } from '../firebase/config';
import { useGame } from '../contexts/GameContext';
import unitConfig from '../gameData/units.json';
import buildingConfig from '../gameData/buildings.json';
import godsConfig from '../gameData/gods.json';
import ruinsResearch from '../gameData/ruinsResearch.json';
import { parseBBCode } from '../utils/bbcodeParser';
import battlePointsImage from '../images/battle_points.png'; // Import the new image
import './ReportsView.css';

const images = {};
const imageContexts = [
    require.context('../images/troops', false, /\.(png|jpe?g|svg)$/),
    require.context('../images/resources', false, /\.(png|jpe?g|svg)$/),
    require.context('../images/buildings', false, /\.(png|jpe?g|svg)$/),
    require.context('../images/gods', false, /\.(png|jpe?g|svg)$/),
];
imageContexts.forEach(context => {
    context.keys().forEach((item) => {
        const keyWithSubdir = context.id.includes('/resources') ? `resources/${item.replace('./', '')}` :
                              context.id.includes('/buildings') ? `buildings/${item.replace('./', '')}` :
                              context.id.includes('/gods') ? `gods/${item.replace('./', '')}` :
                              item.replace('./', '');
        images[keyWithSubdir] = context(item);
    });
});

const SharedReportView = ({ reportId, onClose, worldId: propWorldId, isEmbedded, onActionClick }) => {
    const gameContext = useGame();
    const worldId = propWorldId || gameContext?.worldId;
    const [report, setReport] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');

    useEffect(() => {
        const fetchReport = async () => {
            if (!worldId || !reportId) {
                setError('Invalid report information.');
                setLoading(false);
                return;
            }
            try {
                const reportRef = doc(db, 'worlds', worldId, 'shared_reports', reportId);
                const reportSnap = await getDoc(reportRef);
                if (reportSnap.exists()) {
                    setReport(reportSnap.data());
                } else {
                    setError('This report could not be found. It may have been deleted or is no longer shared.');
                }
            } catch (err) {
                setError('An error occurred while fetching the report.');
                console.error(err);
            }
            setLoading(false);
        };

        fetchReport();
    }, [worldId, reportId]);

    const handleContentClick = (e) => {
        if (!onActionClick) return;
        const target = e.target;
        if (target.classList.contains('bbcode-action')) {
            const { actionType, actionId, actionOwnerId, actionCoordsX, actionCoordsY } = target.dataset;
            if (actionType === 'city_link') {
                onActionClick(actionType, { cityId: actionId, ownerId: actionOwnerId, coords: { x: actionCoordsX, y: actionCoordsY } });
            } else {
                const data = actionId || { x: actionCoordsX, y: actionCoordsY };
                if (actionType && data) {
                    onActionClick(actionType, data);
                }
            }
        }
    };

    const renderUnitList = (units) => {
        if (!units || Object.keys(units).length === 0) return 'None';
        return Object.entries(units)
            .map(([id, count]) => `${count} ${unitConfig[id]?.name || id}`)
            .join(', ');
    };

    const getImageUrl = (imageName) => {
        if (!imageName || !images[imageName]) {
            return '';
        }
        return images[imageName];
    };

    const renderTroopDisplay = (units) => {
        if (!units || Object.keys(units).length === 0) return null;
        return (
            <div className="flex flex-wrap items-center justify-center gap-2">
                {Object.entries(units).map(([unitId, count]) => {
                    if (count > 0) {
                        const unit = unitConfig[unitId];
                        const imageSrc = getImageUrl(unit?.image || '');
                        return (
                            <div key={unitId} className="flex flex-col items-center">
                                {imageSrc && <img src={imageSrc} alt={unit?.name || unitId} className="w-8 h-8"/>}
                                <span className="text-sm">{count}</span>
                            </div>
                        );
                    }
                    return null;
                })}
            </div>
        );
    };

    const renderResourceIcons = (resources) => {
        return Object.entries(resources || {}).map(([res, amount]) => {
            const imagePath = `resources/${res}.png`;
            const imageSrc = getImageUrl(imagePath);
            return (
                <div key={res} className="flex flex-col items-center mx-2">
                    {imageSrc && <img src={imageSrc} alt={res} className="w-8 h-8"/>}
                    <span className="text-sm">{Math.floor(amount)}</span>
                </div>
            );
        });
    };

    const renderBuildingDisplay = (buildings) => {
        if (!buildings || Object.keys(buildings).length === 0) return null;
        return (
            <div className="flex flex-wrap items-center justify-center gap-2">
                {Object.entries(buildings).map(([buildingId, data]) => {
                    if (data.level > 0) {
                        const building = buildingConfig[buildingId];
                        const imageSrc = getImageUrl(`buildings/${building?.image}` || '');
                        return (
                            <div key={buildingId} className="flex flex-col items-center">
                                {imageSrc && <img src={imageSrc} alt={building?.name || buildingId} className="w-8 h-8"/>}
                                <span className="text-sm">{building?.name || buildingId} (Lvl {data.level})</span>
                            </div>
                        );
                    }
                    return null;
                })}
            </div>
        );
    };

    const renderReportOutcome = (report) => {
        const outcome = report.outcome || {};
        const attacker = report.attacker || {};
        const defender = report.defender || {};
        switch (report.type) {
            case 'attack_god_town':
            case 'attack':
            case 'attack_village':
                const battlePointsGained = report.title.startsWith('Attack') ? outcome.attackerBattlePoints : outcome.defenderBattlePoints;
                return (
                    <div className="flex flex-col items-center">
                        <p className={`font-bold text-2xl mb-4 ${outcome.attackerWon ? 'text-green-600' : 'text-red-600'}`}>
                            {outcome.attackerWon ? 'Victory!' : 'Defeat!'}
                        </p>
                        <div className="flex items-center justify-between w-full mb-4">
                            <div className="flex flex-col items-center w-1/3">
                                <p className="font-bold text-lg" dangerouslySetInnerHTML={{ __html: parseBBCode(`[city id=${attacker.cityId} owner=${attacker.ownerId} x=${attacker.x} y=${attacker.y}]${attacker.cityName}[/city]`) }}></p>
                                <p className="text-sm text-gray-500" dangerouslySetInnerHTML={{ __html: parseBBCode(`[player id=${attacker.ownerId}]${attacker.username}[/player]`) }}></p>
                                {attacker.allianceId && <p className="text-sm text-gray-500" dangerouslySetInnerHTML={{ __html: parseBBCode(`[alliance id=${attacker.allianceId}]${attacker.allianceName || attacker.allianceId}[/alliance]`) }}></p>}
                            </div>
                            <div className="w-1/3 text-center">
                                <img src={getImageUrl('swordman.png')} alt="Attack Icon" className="mx-auto h-12 w-auto"/>
                            </div>
                            <div className="flex flex-col items-center w-1/3">
                               {defender.cityName ? (
                                    <>
                                        <p className="font-bold text-lg" dangerouslySetInnerHTML={{ __html: parseBBCode(`[city id=${defender.cityId} owner=${defender.ownerId} x=${defender.x} y=${defender.y}]${defender.cityName}[/city]`) }}></p>
                                        <p className="text-sm text-gray-500" dangerouslySetInnerHTML={{ __html: parseBBCode(`[player id=${defender.ownerId}]${defender.username}[/player]`) }}></p>
                                        {defender.allianceId && <p className="text-sm text-gray-500" dangerouslySetInnerHTML={{ __html: parseBBCode(`[alliance id=${defender.allianceId}]${defender.allianceName || defender.allianceId}[/alliance]`) }}></p>}
                                    </>
                                ) : (
                                    <p className="font-bold text-lg">{defender.villageName || defender.ruinName || 'Unknown Target'}</p>
                                )}
                            </div>
                        </div>
                        <div className="w-full grid grid-cols-2 gap-4 text-sm mt-4">
                            <div className="p-3 bg-black/5 rounded flex flex-col items-center">
                                <h4 className="font-semibold text-lg text-yellow-700 mb-2">Attacker Units</h4>
                                {renderTroopDisplay(attacker.units)}
                                <p className="mt-2"><strong>Losses:</strong> {renderUnitList(outcome.attackerLosses)}</p>
                                {outcome.wounded && Object.keys(outcome.wounded).length > 0 && (
                                    <p className="mt-2 text-orange-600"><strong>Wounded:</strong> {renderUnitList(outcome.wounded)}</p>
                                )}
                            </div>
                            <div className="p-3 bg-black/5 rounded flex flex-col items-center">
                                <h4 className="font-semibold text-lg text-yellow-700 mb-2">Defender Units</h4>
                                {outcome.message ? (
                                    <p className="text-gray-500 italic">Unknown</p>
                                ) : (
                                    <>
                                        {renderTroopDisplay(defender.units || defender.troops)}
                                        <p className="mt-2"><strong>Losses:</strong> {renderUnitList(outcome.defenderLosses)}</p>
                                    </>
                                )}
                            </div>
                        </div>
                        {outcome.attackerWon && outcome.plunder && (
                            <div className="w-full p-3 bg-green-800/10 rounded mt-4 text-center">
                                <h4 className="font-semibold text-lg text-green-700 mb-2">Plundered Resources</h4>
                                <div className="flex justify-center">
                                    {renderResourceIcons(outcome.plunder)}
                                </div>
                            </div>
                        )}
                        {typeof battlePointsGained === 'number' && (
                            <div className="w-full p-3 bg-blue-800/10 rounded mt-4 text-center">
                                <h4 className="font-semibold text-lg text-blue-700 mb-2">Battle Points Gained</h4>
                                <div className="flex items-center justify-center">
                                    <img src={battlePointsImage} alt="Battle Points" className="w-6 h-6 mr-2"/>
                                    <p>{battlePointsGained.toLocaleString()}</p>
                                </div>
                            </div>
                        )}
                        {outcome.message && <p className="text-gray-500 mt-4 italic">{outcome.message}</p>}
                    </div>
                );
            case 'attack_ruin':
                 return (
                    <div className="flex flex-col items-center">
                        <p className={`font-bold text-2xl mb-4 ${outcome.attackerWon ? 'text-green-600' : 'text-red-600'}`}>
                            {outcome.attackerWon ? 'Victory!' : 'Defeat!'}
                        </p>
                         <div className="w-full grid grid-cols-2 gap-4 text-sm mt-4">
                            <div className="p-3 bg-black/5 rounded flex flex-col items-center">
                                <h4 className="font-semibold text-lg text-yellow-700 mb-2">Attacker Units</h4>
                                {renderTroopDisplay(attacker.units)}
                                <p className="mt-2"><strong>Losses:</strong> {renderUnitList(outcome.attackerLosses)}</p>
                            </div>
                            <div className="p-3 bg-black/5 rounded flex flex-col items-center">
                                <h4 className="font-semibold text-lg text-yellow-700 mb-2">Guardian Units</h4>
                                {renderTroopDisplay(defender.troops)}
                                <p className="mt-2"><strong>Losses:</strong> {renderUnitList(outcome.defenderLosses)}</p>
                            </div>
                        </div>
                        {report.reward && (
                            <div className="w-full p-3 bg-green-800/10 rounded mt-4 text-center">
                                <h4 className="font-semibold text-lg text-green-700 mb-2">Research Unlocked!</h4>
                                <p>{ruinsResearch[report.reward]?.name}</p>
                            </div>
                        )}
                    </div>
                );
            case 'scout':
                const scoutedGod = (report.god && report.playerReligion) ? godsConfig[report.playerReligion.toLowerCase()]?.[report.god] : null;
                return (
                    <div className="space-y-3">
                        {report.scoutSucceeded ? (
                            <>
                                <p className="font-bold text-green-600 text-lg">Scout Successful!</p>
                                {scoutedGod && (
                                    <div className="flex items-center gap-2 mt-2">
                                        <p><strong>Worshipped God:</strong> {scoutedGod.name}</p>
                                        <img src={getImageUrl(`gods/${scoutedGod.image}`)} alt={scoutedGod.name} className="w-8 h-8"/>
                                    </div>
                                )}
                                <div className="mt-4">
                                    <h5 className="font-semibold text-yellow-700">Resources:</h5>
                                    <div className="flex flex-wrap gap-2">{renderResourceIcons(report.resources)}</div>
                                </div>
                                <div className="mt-4">
                                    <h5 className="font-semibold text-yellow-700">Units:</h5>
                                    {renderTroopDisplay(report.units)}
                                </div>
                                <div className="mt-4">
                                    <h5 className="font-semibold text-yellow-700">Buildings:</h5>
                                    {renderBuildingDisplay(report.buildings)}
                                </div>
                            </>
                        ) : (
                            <p className="font-bold text-red-600">{report.message || 'Scout Failed!'}</p>
                        )}
                    </div>
                );
            default:
                return <p>This type of report cannot be shared.</p>;
        }
    };

    if (isEmbedded) {
        if (loading) return <div className="text-xs">Loading report...</div>;
        if (error) return <div className="text-xs text-red-500">{error}</div>;
        if (!report) return null;
        return (
            <div className="p-2 border border-yellow-800/50 my-2" onClick={handleContentClick}>
                <h4 className="font-bold text-center text-sm mb-2">{report.title}</h4>
                {renderReportOutcome(report)}
            </div>
        );
    }

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-[100] flex items-center justify-center" onClick={onClose}>
            <div className="reports-container" onClick={e => e.stopPropagation()}>
                <div className="reports-header">
                    <h2 className="font-title text-3xl">Shared Report</h2>
                    <button onClick={onClose} className="close-btn">&times;</button>
                </div>
                <div className="p-4 overflow-y-auto" onClick={handleContentClick}>
                    {loading && <p>Loading report...</p>}
                    {error && <p className="text-red-500 text-center">{error}</p>}
                    {report && (
                        <div>
                            <h3 className="text-lg font-bold mb-2 text-center">{report.title}</h3>
                            <p className="text-xs text-center text-gray-500 mb-4">{report.timestamp?.toDate().toLocaleString()}</p>
                            {renderReportOutcome(report)}
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default SharedReportView;
</file>

<file path="src/components/SideInfoPanel.js">
import React from 'react';
import WorshipDisplay from './city/WorshipDisplay';
import TroopDisplay from './TroopDisplay';
import HeroDisplay from './city/HeroDisplay';
import { useGame } from '../contexts/GameContext';

const SideInfoPanel = ({ gameState, className, onOpenPowers, movements }) => {
    const { activeCityId } = useGame();
    if (!gameState) {
        return null;
    }
    return (
        <div className={className}>
            <WorshipDisplay
                godName={gameState.god}
                playerReligion={gameState.playerInfo.religion}
                worship={gameState.worship}
                buildings={gameState.buildings}
                onOpenPowers={onOpenPowers}
            />
            <HeroDisplay 
                heroes={gameState.heroes} 
                agents={gameState.agents} 
                movements={movements} 
                activeCityId={activeCityId} 
            />
            <TroopDisplay units={gameState.units || {}} />
        </div>
    );
};

export default SideInfoPanel;
</file>

<file path="src/components/Temple.js">
import React, { useState } from 'react';
import { useGame } from '../contexts/GameContext';
import godsConfig from '../gameData/gods.json';
import Modal from './shared/Modal';

const Temple = ({ onClose }) => {
    const { gameState, setGameState, playerNationality } = useGame();
    const [selectedGod, setSelectedGod] = useState(gameState.god || null);
    const [message, setMessage] = useState('');

    const handleSelectGod = (god) => {
        setSelectedGod(god);
    };

    const handleWorship = () => {
        if (!selectedGod) {
            setMessage("You must select a god to worship.");
            return;
        }
        const newGameState = { ...gameState, god: selectedGod };
        setGameState(newGameState);
        setMessage(`You are now worshipping ${selectedGod}.`);
        onClose();
    };

    const availableGods = godsConfig[playerNationality.toLowerCase()] || {};

    return (
        <Modal onClose={onClose} title="Temple">
            <div className="p-4 bg-gray-800 text-white rounded-lg max-w-2xl w-full">
                <h2 className="text-2xl font-bold text-yellow-400 mb-4 text-center">Choose a Deity to Worship</h2>
                {message && <p className="text-center text-green-400 mb-4">{message}</p>}
                
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    {Object.keys(availableGods).map(godId => {
                        const god = availableGods[godId];
                        const isSelected = selectedGod === god.name;
                        return (
                            <div 
                                key={god.name}
                                className={`p-4 rounded-lg cursor-pointer transition-all border-2 ${isSelected ? 'border-yellow-400 bg-gray-700' : 'border-gray-600 bg-gray-900 hover:bg-gray-700'}`}
                                onClick={() => handleSelectGod(god.name)}
                            >
                                <h3 className="text-xl font-bold text-center text-yellow-500">{god.name}</h3>
                                <p className="text-sm text-gray-400 mt-2 text-center">{god.description}</p>
                                {/* Future additions for powers and units can go here */}
                            </div>
                        );
                    })}
                </div>

                <div className="mt-6 flex justify-center">
                    <button 
                        onClick={handleWorship}
                        className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition-colors"
                    >
                        Worship {selectedGod || '...'}
                    </button>
                </div>
            </div>
        </Modal>
    );
};

export default Temple;
</file>

<file path="src/components/TroopDisplay.js">
// src/components/TroopDisplay.js
import React, { useState, useEffect, useRef } from 'react';
import unitConfig from '../gameData/units.json';

// Dynamically import all images from the images and images/buildings folder
const images = {};
const imageContexts = [
    require.context('../images/troops', false, /\.(png|jpe?g|svg)$/),
    require.context('../images/buildings', false, /\.(png|jpe?g|svg)$/),
    require.context('../images/gods', false, /\.(png|jpe?g|svg)$/),
];

imageContexts.forEach(context => {
    context.keys().forEach((item) => {
        const key = item.replace('./', '');
        images[key] = context(item);
    });
});

const TroopDisplay = ({ units, reinforcements, title }) => {
    const [hoveredUnit, setHoveredUnit] = useState(null);
    const [isTooltipLocked, setIsTooltipLocked] = useState(false);
    const [lockCountdown, setLockCountdown] = useState(5);
    const tooltipTimeoutRef = useRef(null);
    const lockTooltipTimeoutRef = useRef(null);
    const countdownIntervalRef = useRef(null);
    const containerRef = useRef(null);

    useEffect(() => {
        const handleClickOutside = (event) => {
            if (isTooltipLocked && containerRef.current && !containerRef.current.contains(event.target)) {
                setIsTooltipLocked(false);
                setHoveredUnit(null);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [isTooltipLocked]);

    useEffect(() => {
        clearTimeout(lockTooltipTimeoutRef.current);
        clearInterval(countdownIntervalRef.current);
        setLockCountdown(5);

        if (hoveredUnit && !isTooltipLocked) {
            countdownIntervalRef.current = setInterval(() => {
                setLockCountdown(prev => {
                    if (prev <= 1) {
                        clearInterval(countdownIntervalRef.current);
                        return 0;
                    }
                    return prev - 1;
                });
            }, 1000);

            lockTooltipTimeoutRef.current = setTimeout(() => {
                setIsTooltipLocked(true);
                clearInterval(countdownIntervalRef.current);
            }, 5000);
        }

        return () => {
            clearTimeout(lockTooltipTimeoutRef.current);
            clearInterval(countdownIntervalRef.current);
        };
    }, [hoveredUnit, isTooltipLocked]);
    
    const handleMouseEnter = (unitId) => {
        if (isTooltipLocked && hoveredUnit !== unitId) {
            setIsTooltipLocked(false);
        }
        clearTimeout(tooltipTimeoutRef.current);
        setHoveredUnit(unitId);
    };

    const handleMouseLeave = () => {
        if (isTooltipLocked) return;
        tooltipTimeoutRef.current = setTimeout(() => {
            setHoveredUnit(null);
        }, 300);
    };

    const handleTooltipClick = (e, unitId) => {
        e.stopPropagation();
        if (isTooltipLocked && hoveredUnit === unitId) {
            setIsTooltipLocked(false);
            setHoveredUnit(null);
        } else {
            setIsTooltipLocked(true);
            setHoveredUnit(unitId);
        }
    };

    const landUnits = Object.entries(units || {}).filter(([id, count]) => count > 0 && unitConfig[id]?.type === 'land' && !unitConfig[id]?.mythical);
    const navalUnits = Object.entries(units || {}).filter(([id, count]) => count > 0 && unitConfig[id]?.type === 'naval' && !unitConfig[id]?.mythical);
    const mythicUnits = Object.entries(units || {}).filter(([id, count]) => count > 0 && unitConfig[id]?.mythical);

    const hasReinforcements = reinforcements && Object.keys(reinforcements).length > 0;
    const hasUnits = landUnits.length > 0 || navalUnits.length > 0 || mythicUnits.length > 0;


    const renderUnit = ([unitId, count]) => {
        const unit = unitConfig[unitId];
        if (!unit || !unit.image) return null;

        const imageUrl = images[unit.image];
        if (!imageUrl) return null;

        return (
            <div 
                key={unitId} 
                className="troop-item" 
                onMouseEnter={() => handleMouseEnter(unitId)} 
                onClick={(e) => handleTooltipClick(e, unitId)}
            >
                <img src={imageUrl} alt={unit.name} className="troop-image" />
                <span className="troop-count">{count}</span>
            </div>
        );
    };

    const renderTooltip = () => {
        if (!hoveredUnit) return null;
        const unit = unitConfig[hoveredUnit];
        if (!unit) return null;

        const counters = unit.counters?.map(counterId => unitConfig[counterId]?.name).join(', ');

        return (
            <div className="unit-tooltip" onMouseEnter={() => clearTimeout(tooltipTimeoutRef.current)} onMouseLeave={handleMouseLeave}>
                <div className="tooltip-header">
                    <h3 className="tooltip-title">{unit.name}</h3>
                </div>
                <div className="tooltip-body">
                    <img src={images[unit.image]} alt={unit.name} className="tooltip-image" />
                    <div className="tooltip-stats">
                        <div className="stat-row"><span>⚔️ Attack</span><span>{unit.attack}</span></div>
                        <div className="stat-row"><span>🛡️ Defense</span><span>{unit.defense}</span></div>
                        <div className="stat-row"><span>🏃 Speed</span><span>{unit.speed}</span></div>
                    </div>
                    {counters && (
                        <div className="tooltip-counters">
                            <strong>Counters:</strong> {counters}
                        </div>
                    )}
                    <p className="tooltip-description">{unit.description}</p>
                </div>
                <div className="tooltip-lock-timer">
                    {isTooltipLocked ? '🔒' : lockCountdown}
                </div>
            </div>
        );
    };

    return (
        <div className="troop-display-container" ref={containerRef} onMouseLeave={handleMouseLeave}>
            {renderTooltip()}
            {landUnits.length > 0 && (
                <div className="troop-section">
                    <h4 className="troop-section-header">Units</h4>
                    <div className="troop-grid">
                        {landUnits.map(renderUnit)}
                    </div>
                </div>
            )}
            {mythicUnits.length > 0 && (
                <div className="troop-section">
                    <h4 className="troop-section-header">Mythic Units</h4>
                    <div className="troop-grid">
                        {mythicUnits.map(renderUnit)}
                    </div>
                </div>
            )}
            {navalUnits.length > 0 && (
                 <div className="troop-section">
                    <h4 className="troop-section-header">Ships</h4>
                    <div className="troop-grid">
                        {navalUnits.map(renderUnit)}
                    </div>
                </div>
            )}
            {hasReinforcements && (
                <div className="troop-section">
                    <h4 className="troop-section-header">Reinforcements</h4>
                    {Object.entries(reinforcements).map(([originCityId, reinfData]) => (
                        <div key={originCityId} className="mb-2 last:mb-0">
                            <p className="text-xs text-center font-semibold text-yellow-600">{reinfData.originCityName}</p>
                            <div className="troop-grid">
                                {Object.entries(reinfData.units || {}).map(renderUnit)}
                            </div>
                        </div>
                    ))}
                </div>
            )}
            {!hasUnits && !hasReinforcements && (
                 <p className="text-gray-500 text-xs text-center p-4">No troops in this city.</p>
            )}
        </div>
    );
};

export default TroopDisplay;
</file>

<file path="src/components/WorldSelectionScreen.css">
/* src/components/WorldSelectionScreen.css */
.world-selection-container {
    background-image: url('../images/world_selection_screen.png');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
}

.world-selection-window {
    background-color: rgba(10, 10, 20, 0.8); /* Dark, semi-transparent background */
    border: 1px solid #a17c48; /* Gold-like border */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    border-radius: 10px;
    color: #f0e68c; /* Khaki text color */
}

.world-selection-window h1, .world-selection-window h2 {
    color: #f0e68c;
    text-shadow: 1px 1px 4px rgba(0,0,0,0.6);
}

.world-selection-window .selection-card {
    background-color: rgba(0, 0, 0, 0.25);
    border: 1px solid #a17c48;
    transition: all 0.2s ease-in-out;
    color: #f0e68c;
}

.world-selection-window .selection-card:hover {
    background-color: rgba(161, 124, 72, 0.4);
    border-color: #f0e68c;
}

.world-selection-window .selection-card h3 {
     color: #f0e68c;
}

.world-selection-window p {
    color: #d2b48c; /* Tan color for paragraphs */
}

.world-selection-window .btn-danger {
    background: #991b1b;
}

.world-selection-window .btn-confirm {
    background: #a17c48;
    border-color: #f0e68c;
    color: #1a1a2e;
}

.world-selection-window .btn-confirm:hover {
     background: #f0e68c;
}

.world-selection-window input {
    background-color: rgba(0, 0, 0, 0.3) !important;
    border-color: #a17c48 !important;
    color: #f0e68c !important;
}
</file>

<file path="src/components/WorldSelectionScreen.js">
// src/components/WorldSelectionScreen.js
import React, { useState, useEffect} from 'react';
import { collection, getDocs, doc, writeBatch, serverTimestamp, getDoc, deleteDoc, query, limit, onSnapshot } from 'firebase/firestore';
import { signOut } from "firebase/auth";
import { db, auth } from '../firebase/config';
import { useAuth } from '../contexts/AuthContext';
import Modal from './shared/Modal';
import { generateIslands, generateCitySlots, generateFarmingVillages, generateRuins } from '../utils/worldGeneration';
import logoutIcon from '../images/logout.png';
import worldIcon from '../images/world_selection.png';
import './WorldSelectionScreen.css';

const ConfirmationModal = ({ message, onConfirm, onCancel, confirmText = 'Confirm', cancelText = 'Cancel' }) => {
    if (!message) return null;

    return (
        <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-60"
            onClick={onCancel}
        >
            <div
                className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-center border border-gray-600"
                onClick={e => e.stopPropagation()}
            >
                <p className="mb-6 text-lg text-gray-300">{message}</p>
                <div className="flex justify-center space-x-4">
                    <button
                        onClick={onCancel}
                        className="btn btn-primary px-6 py-2"
                    >
                        {cancelText}
                    </button>
                    <button
                        onClick={onConfirm}
                        className="btn btn-danger px-6 py-2"
                    >
                        {confirmText}
                    </button>
                </div>
            </div>
        </div>
    );
};

const WorldSelectionScreen = ({ onWorldSelected }) => {
    const { currentUser, userProfile } = useAuth();
    const [worlds, setWorlds] = useState([]);
    const [userGames, setUserGames] = useState([]);
    const [loading, setLoading] = useState(true);
    const [message, setMessage] = useState('');
    const [newWorldName, setNewWorldName] = useState('');
    const [isCreating, setIsCreating] = useState(false);
    const [worldToDelete, setWorldToDelete] = useState(null);

    useEffect(() => {
        setLoading(true);
        const worldsCollectionRef = collection(db, 'worlds');
        const unsubscribeWorlds = onSnapshot(worldsCollectionRef, (worldsSnapshot) => {
            const worldsList = worldsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setWorlds(worldsList);
        }, (error) => {
            console.error("Error fetching worlds:", error);
            setMessage('Could not load world list.');
        });

        let unsubscribeGames;
        if (currentUser) {
            const gamesCollectionRef = collection(db, `users/${currentUser.uid}/games`);
            unsubscribeGames = onSnapshot(gamesCollectionRef, (gamesSnapshot) => {
                const gamesList = gamesSnapshot.docs.map(doc => doc.id);
                setUserGames(gamesList);
                setLoading(false);
            }, (error) => {
                console.error("Error fetching user games:", error);
                setLoading(false);
            });
        } else {
            setLoading(false);
        }

        return () => {
            unsubscribeWorlds();
            if (unsubscribeGames) {
                unsubscribeGames();
            }
        };
    }, [currentUser]);

    const handleCreateWorld = async (e) => {
        e.preventDefault();
        if (!newWorldName.trim()) {
            setMessage('Please enter a world name.');
            return;
        }

        setIsCreating(true);
        setMessage('Creating a new world, this may take a moment...');

        try {
            const worldId = newWorldName.trim().toLowerCase().replace(/\s+/g, '-');
            const worldDocRef = doc(db, 'worlds', worldId);

            const existingWorld = await getDoc(worldDocRef);
            if (existingWorld.exists()) {
                setMessage(`A world with the ID '${worldId}' already exists. Please choose a different name.`);
                setIsCreating(false);
                return;
            }

            const worldWidth = 100;
            const worldHeight = 100;
            const islandCount = 4;

            // Generate all world data
            const islands = generateIslands(worldWidth, worldHeight, islandCount);
            const citySlots = generateCitySlots(islands, worldWidth, worldHeight);
            const villages = generateFarmingVillages(islands, citySlots, worldWidth, worldHeight);
            const ruins = generateRuins(islands, worldWidth, worldHeight);

            const worldData = {
                name: newWorldName.trim(),
                islands,
                width: worldWidth,
                height: worldHeight,
                createdAt: serverTimestamp(),
                season: 'Spring',
                weather: 'Clear',
                seasonLastUpdate: serverTimestamp(),
                weatherLastUpdate: serverTimestamp()
            };

            await writeBatch(db).set(worldDocRef, worldData).commit();

            const batchSize = 400;

            // Batch write city slots
            const citySlotsCollectionRef = collection(db, 'worlds', worldId, 'citySlots');
            const slotEntries = Object.entries(citySlots);
            for (let i = 0; i < slotEntries.length; i += batchSize) {
                const batch = writeBatch(db);
                const chunk = slotEntries.slice(i, i + batchSize);
                setMessage(`Creating world... writing city data ${i + chunk.length}/${slotEntries.length}`);
                for (const [slotId, slotData] of chunk) {
                    const slotDocRef = doc(citySlotsCollectionRef, slotId);
                    batch.set(slotDocRef, slotData);
                }
                await batch.commit();
            }

            // Batch write villages
            const villagesCollectionRef = collection(db, 'worlds', worldId, 'villages');
            const villageEntries = Object.entries(villages);
            for (let i = 0; i < villageEntries.length; i += batchSize) {
                const batch = writeBatch(db);
                const chunk = villageEntries.slice(i, i + batchSize);
                setMessage(`Creating world... writing village data ${i + chunk.length}/${villageEntries.length}`);
                for (const [villageId, villageData] of chunk) {
                    const villageDocRef = doc(villagesCollectionRef, villageId);
                    batch.set(villageDocRef, { ...villageData, lastCollected: serverTimestamp() });
                }
                await batch.commit();
            }

            // Batch write ruins
            const ruinsCollectionRef = collection(db, 'worlds', worldId, 'ruins');
            const ruinEntries = Object.entries(ruins);
            for (let i = 0; i < ruinEntries.length; i += batchSize) {
                const batch = writeBatch(db);
                const chunk = ruinEntries.slice(i, i + batchSize);
                setMessage(`Creating world... writing ancient ruins ${i + chunk.length}/${ruinEntries.length}`);
                for (const [ruinId, ruinData] of chunk) {
                    const ruinDocRef = doc(ruinsCollectionRef, ruinId);
                    batch.set(ruinDocRef, ruinData);
                }
                await batch.commit();
            }

            setMessage('World created successfully!');
            onWorldSelected(worldId);

        } catch (error) {
            console.error("Error creating world:", error);
            setMessage(`Failed to create world: ${error.message}`);
        }
        setIsCreating(false);
        setNewWorldName('');
    };

    const handleDeleteWorld = async (worldId, worldName) => {
        setMessage(`Deleting world "${worldName}"... This may take a moment.`);
        try {
            const worldDocRef = doc(db, 'worlds', worldId);
            
            const deleteCollectionBatch = async (collectionRef) => {
                const q = query(collectionRef, limit(500));
                const snapshot = await getDocs(q);
                if (snapshot.size === 0) {
                    return 0;
                }
                const batch = writeBatch(db);
                snapshot.docs.forEach(doc => batch.delete(doc.ref));
                await batch.commit();
                return snapshot.size;
            };

            // Delete subcollections
            let deletedCount;
            const citySlotsRef = collection(db, 'worlds', worldId, 'citySlots');
            while ((deletedCount = await deleteCollectionBatch(citySlotsRef)) > 0) {
                console.log(`Deleted ${deletedCount} city slots...`);
            }
            
            const villagesRef = collection(db, 'worlds', worldId, 'villages');
            while ((deletedCount = await deleteCollectionBatch(villagesRef)) > 0) {
                console.log(`Deleted ${deletedCount} villages...`);
            }

            const ruinsRef = collection(db, 'worlds', worldId, 'ruins');
             while ((deletedCount = await deleteCollectionBatch(ruinsRef)) > 0) {
                console.log(`Deleted ${deletedCount} ruins...`);
            }
            
            // Delete the main world doc
            await deleteDoc(worldDocRef);

            setMessage(`World "${worldName}" has been deleted successfully.`);
            // After deletion, re-fetch worlds to update the UI
            const worldsCollectionRef = collection(db, 'worlds');
            const worldsSnapshot = await getDocs(worldsCollectionRef);
            const worldsList = worldsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setWorlds(worldsList);

        } catch (error) {
            console.error("Error deleting world:", error);
            setMessage(`Failed to delete world: ${error.message}`);
        } finally {
            setWorldToDelete(null);
        }
    };

    if (loading) {
        return <div className="text-white text-center p-10">Loading Worlds...</div>;
    }

    const availableWorlds = worlds.filter(world => !userGames.includes(world.id));
    const joinedWorlds = worlds.filter(world => userGames.includes(world.id));

    return (
        <div className="w-full min-h-screen flex items-center justify-center p-4 world-selection-container">
            <Modal message={message} onClose={() => setMessage('')} />
            {worldToDelete && (
                <ConfirmationModal
                    message={`Are you sure you want to permanently delete the world "${worldToDelete.name}"? This will delete all your cities and progress within it.`}
                    onConfirm={() => handleDeleteWorld(worldToDelete.id, worldToDelete.name)}
                    onCancel={() => setWorldToDelete(null)}
                    confirmText="Delete World"
                />
            )}
            <div className="world-selection-window w-full max-w-4xl p-8 relative">
                <button
                    onClick={() => signOut(auth)}
                    className="absolute top-4 right-4 text-sm text-red-400 hover:text-red-300 px-3 py-1 rounded"
                >
                    <img src={logoutIcon} alt="Logout" className="w-8 h-8" />
                </button>
                <h1 className="font-title text-4xl text-center mb-8">SELECT A WORLD</h1>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <div>
                        <h2 className="font-title text-2xl mb-4">YOUR WORLDS</h2>
                        {joinedWorlds.length > 0 ? (
                            joinedWorlds.map(world => (
                                <div key={world.id} className="selection-card p-4 rounded-lg text-center mb-2 flex justify-between items-center">
                                    <div className="flex items-center cursor-pointer" onClick={() => onWorldSelected(world.id)}>
                                        <img src={worldIcon} alt="World" className="w-8 h-8 mr-4" />
                                        <h3 className="text-xl font-bold flex-grow text-left">{world.name}</h3>
                                    </div>
                                    {userProfile?.is_admin && (
                                        <button
                                            onClick={() => setWorldToDelete(world)}
                                            className="btn btn-danger px-3 py-1 text-xs rounded"
                                        >
                                            Delete
                                        </button>
                                    )}
                                </div>
                            ))
                        ) : (
                            <p>You have not joined any worlds yet.</p>
                        )}
                    </div>

                    <div>
                        <h2 className="font-title text-2xl mb-4">JOIN A NEW WORLD</h2>
                        {availableWorlds.length > 0 ? (
                            availableWorlds.map(world => (
                                <div key={world.id} className="selection-card p-4 rounded-lg text-center mb-2 flex justify-between items-center">
                                    <div className="flex items-center cursor-pointer" onClick={() => onWorldSelected(world.id)}>
                                        <img src={worldIcon} alt="World" className="w-8 h-8 mr-4" />
                                        <h3 className="text-xl font-bold flex-grow text-left">{world.name}</h3>
                                    </div>
                                    {userProfile?.is_admin && (
                                        <button
                                            onClick={() => setWorldToDelete(world)}
                                            className="btn btn-danger px-3 py-1 text-xs rounded"
                                        >
                                            Delete
                                        </button>
                                    )}
                                </div>
                            ))
                        ) : (
                            <p>No new worlds are available to join.</p>
                        )}
                    </div>
                </div>

                {userProfile?.is_admin && (
                    <div className="mt-12 border-t border-gray-700 pt-8">
                        <h2 className="font-title text-2xl mb-4">ADMIN PANEL</h2>
                        <form onSubmit={handleCreateWorld} className="flex flex-col sm:flex-row gap-4 mb-4">
                            <input
                                type="text"
                                value={newWorldName}
                                onChange={(e) => setNewWorldName(e.target.value)}
                                placeholder="Enter new world name"
                                className="flex-grow bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                                disabled={isCreating}
                            />
                            <button type="submit" className="btn btn-confirm px-6 py-2" disabled={isCreating}>
                                {isCreating ? 'Creating...' : 'Create New World'}
                            </button>
                        </form>
                    </div>
                )}
            </div>
        </div>
    );
};

export default WorldSelectionScreen;
</file>

<file path="src/contexts/AllianceContext.js">
import { createContext, useContext } from 'react';

const AllianceContext = createContext();

export const useAlliance = () => useContext(AllianceContext);

export default AllianceContext;
</file>

<file path="src/contexts/AllianceProvider.js">
// src/contexts/AllianceProvider.js
import React, { useState, useEffect } from 'react';
import { doc, onSnapshot } from "firebase/firestore";
import { db } from '../firebase/config';
import { useGame } from './GameContext';
import AllianceContext from './AllianceContext';
import { useAllianceActions } from '../hooks/actions/useAllianceActions';
import { useAllianceBankActions } from '../hooks/actions/useAllianceBank';
import { useAllianceDiplomacyActions } from '../hooks/actions/useAllianceDiplomacy';
import { useAllianceManagementActions } from '../hooks/actions/useAllianceManagement';
import { useAllianceResearchActions } from '../hooks/actions/useAllianceResearch';
import { useAllianceWonderActions } from '../hooks/actions/useAllianceWonderActions'; // Import new hook

export const AllianceProvider = ({ children }) => {
    const { worldId, playerGameData } = useGame();
    const [playerAlliance, setPlayerAlliance] = useState(null);

    useEffect(() => {
        if (!worldId || !playerGameData || !playerGameData.alliance) {
            setPlayerAlliance(null);
            return;
        }

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerGameData.alliance);
        const unsubscribe = onSnapshot(allianceDocRef, (allianceSnap) => {
            if (allianceSnap.exists()) {
                setPlayerAlliance({ id: allianceSnap.id, ...allianceSnap.data() });
            } else {
                setPlayerAlliance(null);
            }
        });

        return () => unsubscribe();
    }, [worldId, playerGameData]);

    const allianceActions = useAllianceActions(playerAlliance);
    const bankActions = useAllianceBankActions(playerAlliance);
    const diplomacyActions = useAllianceDiplomacyActions(playerAlliance);
    const managementActions = useAllianceManagementActions(playerAlliance);
    const researchActions = useAllianceResearchActions(playerAlliance);
    const wonderActions = useAllianceWonderActions(playerAlliance);

    const value = {
        playerAlliance,
        ...allianceActions,
        ...bankActions,
        ...diplomacyActions,
        ...managementActions,
        ...researchActions,
        ...wonderActions
    };

    return (
        <AllianceContext.Provider value={value}>
            {children}
        </AllianceContext.Provider>
    );
};
</file>

<file path="src/contexts/AuthContext.js">
import React, { useState, useEffect, createContext, useContext } from 'react';
import { onAuthStateChanged } from "firebase/auth";
import { doc, onSnapshot, updateDoc, serverTimestamp } from "firebase/firestore";
import { auth, db } from '../firebase/config';

const AuthContext = createContext();

export const useAuth = () => useContext(AuthContext);

export const AuthProvider = ({ children }) => {
    const [currentUser, setCurrentUser] = useState(null);
    const [userProfile, setUserProfile] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        let unsubscribeProfile = () => {};

        const unsubscribeAuth = onAuthStateChanged(auth, user => {
            setCurrentUser(user);
            unsubscribeProfile(); 

            if (user) {
                const userDocRef = doc(db, "users", user.uid);
                
                // #comment Update lastLogin timestamp on authentication.
                updateDoc(userDocRef, { lastLogin: serverTimestamp() }).catch(err => {
                    // This might fail if the doc doesn't exist yet, which is fine.
                    if (err.code !== 'not-found') {
                        console.error("Failed to update last login time:", err);
                    }
                });

                setLoading(true);
                unsubscribeProfile = onSnapshot(userDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        setUserProfile(docSnap.data());
                    } else {
                        setUserProfile(null);
                    }
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching user profile:", error);
                    setUserProfile(null);
                    setLoading(false);
                });
            } else {
                setUserProfile(null);
                setLoading(false);
            }
        });

        return () => {
            unsubscribeAuth();
            unsubscribeProfile();
        };
    }, []);

    const updateUserProfile = async (profileData) => {
        if (currentUser) {
            const userDocRef = doc(db, "users", currentUser.uid);
            await updateDoc(userDocRef, profileData);
        }
    };

    const value = { currentUser, userProfile, loading, updateUserProfile };

    return <AuthContext.Provider value={value}>{!loading && children}</AuthContext.Provider>;
};
</file>

<file path="src/contexts/GameContext.js">
// src/contexts/GameContext.js
import React, { useState, useEffect, createContext, useContext, useCallback } from 'react';
import { doc, onSnapshot, collection, writeBatch, updateDoc, getDoc } from "firebase/firestore";
import { db } from '../firebase/config';
import { useAuth } from './AuthContext';
import { useNotification } from './NotificationContext';
import { calculateTotalPointsForCity } from '../hooks/useCityState';

const GameContext = createContext();

export const useGame = () => useContext(GameContext);

export const GameProvider = ({ children, worldId }) => {
    const { currentUser } = useAuth();
    const { addNotification } = useNotification();
    const [playerGameData, setPlayerGameData] = useState(null);
    const [playerCities, setPlayerCities] = useState({});
    const [activeCityId, setActiveCityId] = useState(null);
    const [worldState, setWorldState] = useState(null);
    const [playerHasCities, setPlayerHasCities] = useState(false);
    const [loading, setLoading] = useState(true);
    const [conqueredVillages, setConqueredVillages] = useState({});
    const [conqueredRuins, setConqueredRuins] = useState({});
    const [playerCityPoints, setPlayerCityPoints] = useState({}); // State for player's city points
    const [gameSettings, setGameSettings] = useState({
        animations: true,
        confirmActions: true,
        showGrid: true,
        showVisuals: true,
        hideReturningReports: false,
        hideCompletedQuestsIcon: false,
        workerPresets: {
            timber_camp: 0,
            quarry: 0,
            silver_mine: 0,
        }
    });
    const [isInstantBuild, setIsInstantBuild] = useState(() => {
        return localStorage.getItem("isInstantBuild") === "true" // restore on refresh
    });
    const [isInstantResearch, setIsInstantResearch] = useState(() => {
        return localStorage.getItem("isInstantResearch") === "true" // restore on refresh
    });
    const [isInstantUnits, setIsInstantUnits] = useState(() => {
        return localStorage.getItem("isInstantUnits") === "true" // restore on refresh
    });


    // Save to localStorage whenever it changes
    const toggleInstantBuild = (value) => {
        setIsInstantBuild(value);
        localStorage.setItem("isInstantBuild", value.toString());
    };
        const toggleisInstantResearch = (value) => {
        setIsInstantResearch(value);
        localStorage.setItem("isInstantResearch", value.toString());
    };
        const toggleisInstantUnits = (value) => {
        setIsInstantUnits(value);
        localStorage.setItem("isInstantUnits", value.toString());
    };
    
    useEffect(() => {
        if (!currentUser || !worldId) {
            setLoading(false);
            return;
        }

        setLoading(true);

        const worldDocRef = doc(db, 'worlds', worldId);
        const unsubscribeWorld = onSnapshot(worldDocRef, (docSnap) => {
            setWorldState(docSnap.exists() ? { id: docSnap.id, ...docSnap.data() } : null);
        });


        const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);
        const unsubscribeGameData = onSnapshot(gameDocRef, (docSnap) => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                setPlayerGameData(data);
            } else {
                setPlayerGameData(null);
            }
        });

        const citiesColRef = collection(db, `users/${currentUser.uid}/games`, worldId, 'cities');
        const unsubscribeCities = onSnapshot(citiesColRef, (snapshot) => {
            const citiesData = {};
            let firstCityId = null;
            snapshot.forEach(doc => {
                if (!firstCityId) firstCityId = doc.id;
                citiesData[doc.id] = { id: doc.id, ...doc.data() };
            });
            setPlayerCities(citiesData);
            const hasCities = !snapshot.empty;
            setPlayerHasCities(hasCities);

            setActiveCityId(currentId => {
                if (hasCities && (!currentId || !citiesData[currentId])) {
                    return firstCityId;
                }
                if (!hasCities) {
                    return null;
                }
                return currentId;
            });

            setLoading(false);
        });

        const conqueredVillagesRef = collection(db, `users/${currentUser.uid}/games`, worldId, 'conqueredVillages');
        const unsubscribeVillages = onSnapshot(conqueredVillagesRef, (snapshot) => {
            const villagesData = {};
            snapshot.docs.forEach(doc => {
                villagesData[doc.id] = { id: doc.id, ...doc.data() };
            });
            setConqueredVillages(villagesData);
        });

        const conqueredRuinsRef = collection(db, `users/${currentUser.uid}/games`, worldId, 'conqueredRuins');
        const unsubscribeRuins = onSnapshot(conqueredRuinsRef, (snapshot) => {
            const ruinsData = {};
            snapshot.docs.forEach(doc => {
                ruinsData[doc.id] = { id: doc.id, ...doc.data() };
            });
            setConqueredRuins(ruinsData);
        });

        return () => {
            unsubscribeWorld();
            unsubscribeGameData();
            unsubscribeCities();
            unsubscribeVillages();
            unsubscribeRuins();
        };
    }, [currentUser, worldId]);

    // #comment This effect recalculates the player's total points and points per city whenever their cities change.
    useEffect(() => {
        if (!currentUser || !worldId || !playerCities) {
            if (!playerCities || Object.keys(playerCities).length === 0) {
                setPlayerCityPoints({}); // Clear points if no cities
            }
            return;
        }

        const recalculateAndSaveTotalPoints = async () => {
            let playerAlliance = null;
            if (playerGameData?.alliance) {
                const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerGameData.alliance);
                const allianceSnap = await getDoc(allianceDocRef);
                if (allianceSnap.exists()) {
                    playerAlliance = { id: allianceSnap.id, ...allianceSnap.data() };
                }
            }

            let totalPoints = 0;
            const newCityPoints = {};
            for (const cityId in playerCities) {
                const cityData = playerCities[cityId];
                const points = calculateTotalPointsForCity(cityData, playerAlliance);
                totalPoints += points;
                if (cityData.slotId) {
                    newCityPoints[cityData.slotId] = points;
                }
            }
            setPlayerCityPoints(newCityPoints);

            const cityCount = Object.keys(playerCities).length;

            if (playerGameData?.totalPoints !== totalPoints || playerGameData?.cityCount !== cityCount) {
                const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);
                try {
                    const gameDocSnap = await getDoc(gameDocRef);
                    if (gameDocSnap.exists()) {
                        await updateDoc(gameDocRef, { totalPoints, cityCount });
                    }
                } catch (error) {
                    console.error("Error updating total points and city count:", error);
                }
            }
        };

        recalculateAndSaveTotalPoints();
    }, [playerCities, currentUser, worldId, playerGameData]);


    const activeCity = playerCities[activeCityId] || null;

    const gameState = activeCity;
    const playerCity = activeCity;



    const countCitiesOnIsland = useCallback((islandId) => {
        if (!islandId || !playerCities) return 0;
        return Object.values(playerCities).filter(city => city.islandId === islandId).length;
    }, [playerCities]);


    const renameCity = useCallback(async (cityId, newName) => {
        if (!currentUser || !worldId || !cityId || !newName.trim()) {
            throw new Error("Invalid parameters for renaming city.");
        }

        const cityToRename = playerCities[cityId];
        if (!cityToRename) {
            throw new Error("City not found.");
        }

        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', cityId);
        const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', cityToRename.slotId);

        const batch = writeBatch(db);

        batch.update(cityDocRef, { cityName: newName.trim() });
        batch.update(citySlotRef, { cityName: newName.trim() });

        await batch.commit();


    }, [currentUser, worldId, playerCities]);

    const value = {
        worldId,
        worldState,
        playerGameData,
        playerCities,
        activeCityId,
        setActiveCityId,
        activeCity,
        playerHasCities,
        loading,
        conqueredVillages,
        conqueredRuins,
        gameSettings,
        setGameSettings,
        countCitiesOnIsland,
        renameCity,
        addNotification,
        playerCityPoints,
        gameState,
        playerCity,
        setGameState: (newState) => {
            if (activeCityId) {
                setPlayerCities(prev => ({...prev, [activeCityId]: newState}));
            }
        }
    };

    return <GameContext.Provider value={{...value, isInstantBuild, setIsInstantBuild: toggleInstantBuild, isInstantResearch, setIsInstantResearch: toggleisInstantResearch, isInstantUnits, setIsInstantUnits: toggleisInstantUnits }}>{children}</GameContext.Provider>;
};
</file>

<file path="src/contexts/NotificationContext.js">
// src/contexts/NotificationContext.js
import { createContext, useContext } from 'react';

const NotificationContext = createContext();

export const useNotification = () => useContext(NotificationContext);

export default NotificationContext;
</file>

<file path="src/contexts/NotificationProvider.js">
import React, { useState, useCallback, useRef } from 'react';
import NotificationContext from './NotificationContext';
import Notification from '../components/shared/Notification';
import { v4 as uuidv4 } from 'uuid';

export const NotificationProvider = ({ children }) => {
    const [notifications, setNotifications] = useState([]);
    const recentNotifications = useRef(new Set());

    const addNotification = useCallback((message, iconType, iconId) => { // #comment Add iconType and iconId
        // #comment Prevent the same notification from appearing in rapid succession
        if (recentNotifications.current.has(message)) {
            return;
        }

        const id = uuidv4();
        // #comment Add icon details to the notification object
        setNotifications(prev => [...prev, { id, message, iconType, iconId }]);
        recentNotifications.current.add(message);

        // #comment Remove the message from the recent set after a short delay to allow it to be shown again later
        setTimeout(() => {
            recentNotifications.current.delete(message);
        }, 2000); // 2-second cooldown for the same message
    }, []);

    const removeNotification = useCallback((id) => {
        setNotifications(prev => prev.filter(n => n.id !== id));
    }, []);

    return (
        <NotificationContext.Provider value={{ addNotification }}>
            {children}
            <div className="fixed bottom-5 right-5 z-[100] flex flex-col items-end">
                {notifications.map(notification => (
                    <Notification
                        key={notification.id}
                        message={notification.message}
                        iconType={notification.iconType}
                        iconId={notification.iconId}
                        onClose={() => removeNotification(notification.id)}
                    />
                ))}
            </div>
        </NotificationContext.Provider>
    );
};
</file>

<file path="src/firebase/config.js">
// src/firebase/config.js
import { initializeApp } from "firebase/app";
import { getAuth, connectAuthEmulator } from "firebase/auth";
import { getFirestore, connectFirestoreEmulator } from "firebase/firestore";
import { getFunctions, connectFunctionsEmulator } from "firebase/functions";

const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY || "dummy-api-key",
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN || "dummy-auth-domain.firebaseapp.com",
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID || "grepollike",
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET || "dummy-storage-bucket.appspot.com",
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID || "dummy-sender-id",
  appId: process.env.REACT_APP_FIREBASE_APP_ID || "dummy-app-id",
  measurementId: process.env.REACT_APP_FIREBASE_MEASUREMENT_ID || "dummy-measurement-id"
};

const app = initializeApp(firebaseConfig);

export const auth = getAuth(app);
export const db = getFirestore(app);
export const functions = getFunctions(app);
export const appId = "default-grepolis-clone";
// #comment Reverted to checking hostname to reliably detect the local environment.
// This ensures the app connects to emulators when you run `npm start`.
if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
  console.log("Development environment detected. Connecting to Firebase emulators.");
  // #comment The Auth emulator requires the "http://" prefix, while others do not.
  connectAuthEmulator(auth, "http://127.0.0.1:9099");
  connectFirestoreEmulator(db, "127.0.0.1", 8090);
  connectFunctionsEmulator(functions, "127.0.0.1", 5001);
}

export default app;
</file>

<file path="src/gameData/agents.json">
{
  "architect": {
    "name": "Architect",
    "description": "A master builder who can found new cities on empty plots.",
    "image": "architect.png",
    "cost": {
      "wood": 1000,
      "stone": 1000,
      "silver": 2000
    },
    "abilities": [
      {
        "name": "Found City",
        "description": "Travels to an empty plot to start the construction of a new city. The founding time is reduced by the number of villagers sent with him."
      }
    ]
  }
}
</file>

<file path="src/gameData/alliance_wonders.json">
{
  "great_forum": {
    "name": "Great Forum",
    "description": "A magnificent forum that fosters intellectual debate and civic engagement, significantly increasing the research speed of all alliance members.",
    "bonus": {
      "type": "research_boost",
      "value": 0.20
    },
    "image": "great_forum.png"
  },
  "grand_arsenal": {
    "name": "Grand Arsenal",
    "description": "An enormous armory that provides the best weapons and armor, boosting the attack and defense of all alliance members' units.",
    "bonus": {
      "type": "unit_boost",
      "value": 0.15
    },
    "image": "grand_arsenal.png"
  },
  "the_great_market": {
    "name": "The Great Market",
    "description": "A bustling hub of commerce that makes trade more efficient, increasing the market capacity and speed for all alliance members.",
    "bonus": {
      "type": "trade_efficiency",
      "value": 0.25
    },
    "image": "the_great_market.png"
  },
  "shrine_of_the_ancestors": {
    "name": "Shrine of the Ancestors",
    "description": "A sacred shrine that inspires great loyalty, boosting city happiness and population growth across all alliance members' cities.",
    "bonus": {
      "type": "morale_boost",
      "value": 0.10
    },
    "image": "shrine_of_the_ancestors.png"
  },
  "fortress_of_the_gods": {
    "name": "Fortress of the Gods",
    "description": "An impenetrable citadel that provides powerful defensive bonuses to all cities on the island held by the alliance.",
    "bonus": {
      "type": "fortification_boost",
      "value": 0.20
    },
    "image": "fortress_of_the_gods.png"
  }
}
</file>

<file path="src/gameData/allianceResearch.json">
{
    "master_of_arms": {
        "name": "Master of Arms",
        "description": "Increases the attack power of all alliance members' troops.",
        "maxLevel": 10,
        "baseCost": { "wood": 100000, "stone": 100000, "silver": 50000 },
        "costMultiplier": 1.5,
        "effect": { "type": "attack_boost", "value": 0.01 }
    },
    "fortification_experts": {
        "name": "Fortification Experts",
        "description": "Increases the defensive power of all alliance members' troops.",
        "maxLevel": 10,
        "baseCost": { "wood": 100000, "stone": 150000, "silver": 25000 },
        "costMultiplier": 1.5,
        "effect": { "type": "defense_boost", "value": 0.01 }
    },
    "logistics_specialists": {
        "name": "Logistics Specialists",
        "description": "Increases the travel speed of all alliance members' troops.",
        "maxLevel": 5,
        "baseCost": { "wood": 120000, "stone": 80000, "silver": 80000 },
        "costMultiplier": 1.8,
        "effect": { "type": "speed_boost", "value": 0.02 }
    },
    "expanded_charter": {
        "name": "Expanded Charter",
        "description": "Increases the maximum number of members in the alliance.",
        "maxLevel": 5,
        "baseCost": { "wood": 250000, "stone": 250000, "silver": 100000 },
        "costMultiplier": 2,
        "effect": { "type": "max_members", "value": 5 }
    },
    "reinforced_vaults": {
        "name": "Reinforced Vaults",
        "description": "Increases the capacity of the alliance bank.",
        "maxLevel": 10,
        "baseCost": { "wood": 150000, "stone": 200000, "silver": 150000 },
        "costMultiplier": 1.6,
        "effect": { "type": "bank_capacity", "value": 50000 }
    }
}
</file>

<file path="src/gameData/BuildingLayout.json">
[
  { "id": "city_wall", "name": "City Wall", "position": { "x": 0, "y": 650 } },
  { "id": "senate", "name": "Senate", "position": { "x": 1105, "y": 360 } },
  { "id": "timber_camp", "name": "Lumber Mill", "position": { "x": 200, "y": 470 } },
  { "id": "quarry", "name": "Stone Quarry", "position": { "x":750, "y": 70 } },
  { "id": "barracks", "name": "Barracks", "position": { "x": 840, "y": 410 } },
  { "id": "silver_mine", "name": "Silver Mine", "position": { "x": 605, "y": 330 } },
  { "id": "market", "name": "Market", "position": { "x": 1500, "y": 400 } },
  { "id": "warehouse", "name": "Warehouse", "position": { "x":200, "y": 10 } },
  { "id": "farm", "name": "Farm", "position": { "x": 1400, "y": 90 } },
  { "id": "temple", "name": "Temple", "position": { "x": 500, "y": 100 } },
  { "id": "divine_temple", "name": "Divine Temple", "position": { "x": 450, "y": 400 } },
  { "id": "cave", "name": "Cave", "position": { "x": 1300, "y": 600 } },
  { "id": "academy", "name": "Academy", "position": { "x": 1100, "y":250 } },
  { "id": "hospital", "name": "Hospital", "position": { "x": 1050, "y": 100 } },
  { "id": "shipyard", "name": "Shipyard", "position": { "x": 1043, "y": 840 } },
  { "id": "special_building_plot", "name": "Special Building", "position": { "x": 1525, "y": 700 } },
  { "id": "heroes_altar", "name": "Heroes' Altar", "position": { "x": 1750, "y": 700 } },
  { "id": "prison", "name": "Prison", "position": { "x": 840, "y": 250 } }
]
</file>

<file path="src/gameData/buildings.json">
{
  "senate": {
    "name": "Senate",
    "description": "Manage your city and view building levels.",
    "baseCost": { "wood": 200, "stone": 250, "silver": 150, "population": 10, "time": 120 },
    "image": "senate.png",
    "maxLevel": 10,
    "points": 20
  },
  "timber_camp": {
    "name": "Timber Camp",
    "description": "Generates wood for your empire.",
    "baseCost": { "wood": 60, "stone": 80, "silver": 20, "population": 5, "time": 60 },
    "image": "lumber_mill.png",
    "maxLevel": 25,
    "points": 5,
    "requirements": { "senate": 1 }
  },
  "quarry": {
    "name": "Quarry",
    "description": "Mines stone for construction.",
    "baseCost": { "wood": 80, "stone": 60, "silver": 20, "population": 5, "time": 60 },
    "image": "stone_quarry.png",
    "maxLevel": 25,
    "points": 5,
    "requirements": { "senate": 1 }
  },
  "silver_mine": {
    "name": "Silver Mine",
    "description": "Mints silver coins.",
    "baseCost": { "wood": 100, "stone": 100, "silver": 50, "population": 8, "time": 90 },
    "image": "silver_mines.png",
    "maxLevel": 25,
    "points": 5,
    "requirements": { "senate": 1 }
  },
  "farm": {
    "name": "Farm",
    "description": "Increases your city's population capacity.",
    "baseCost": { "wood": 100, "stone": 50, "silver": 30, "population": 0, "time": 70 },
    "image": "farm.png",
    "maxLevel": 30,
    "points": 4,
    "requirements": { "senate": 1 }
  },
  "warehouse": {
    "name": "Warehouse",
    "description": "Stores your precious resources.",
    "baseCost": { "wood": 150, "stone": 200, "silver": 0, "population": 0, "time": 80 },
    "image": "warehouse.png",
    "maxLevel": 20,
    "points": 8,
    "requirements": { "senate": 1 }
  },
  "barracks": {
    "name": "Barracks",
    "description": "Train land units to attack and defend.",
    "baseCost": { "wood": 120, "stone": 100, "silver": 80, "population": 10, "time": 150 },
    "image": "barracks.png",
    "maxLevel": 15,
    "points": 12,
    "requirements": { "senate": 3 }
  },
  "shipyard": {
    "name": "Shipyard",
    "description": "Build ships for naval warfare.",
    "baseCost": { "wood": 150, "stone": 100, "silver": 100, "population": 10, "time": 180 },
    "image": "shipyard.png",
    "maxLevel": 15,
    "points": 12,
    "requirements": { "senate": 4, "timber_camp": 5 }
  },
  "academy": {
    "name": "Academy",
    "description": "Research new technologies and units.",
    "baseCost": { "wood": 220, "stone": 220, "silver": 180, "population": 15, "time": 240 },
    "image": "academy.png",
    "maxLevel": 10,
    "points": 15,
    "requirements": { "senate": 5, "warehouse": 2 }
  },
  "city_wall": {
    "name": "City Wall",
    "description": "Increases the defense of your city.",
    "baseCost": { "wood": 50, "stone": 250, "silver": 100, "population": 5, "time": 100 },
    "image": "city_wall.png",
    "maxLevel": 20,
    "points": 10,
    "requirements": { "senate": 2 }
  },
  "cave": {
    "name": "Cave",
    "description": "Train spies and store silver safely from raids.",
    "baseCost": { "wood": 100, "stone": 100, "silver": 20, "population": 5, "time": 120 },
    "image": "cave.png",
    "maxLevel": 10,
    "points": 8,
    "requirements": { "senate": 3 }
  },
  "market": {
    "name": "Market",
    "description": "Trade resources with other players.",
    "baseCost": { "wood": 180, "stone": 180, "silver": 180, "population": 10, "time": 200 },
    "image": "market.png",
    "maxLevel": 10,
    "points": 8,
    "requirements": { "warehouse": 3 }
  },
  "temple": {
    "name": "Temple",
    "description": "Worship the gods to gain their favor.",
    "baseCost": { "wood": 250, "stone": 250, "silver": 250, "population": 10, "time": 300 },
    "image": "temple.png",
    "maxLevel": 10,
    "points": 15,
    "requirements": { "academy": 2 }
  },
  "divine_temple": {
    "name": "Divine Temple",
    "description": "A sacred place to train mythical units blessed by your worshipped god.",
    "baseCost": { "wood": 500, "stone": 500, "silver": 500, "population": 20, "time": 1800 },
    "image": "divine_temple.png",
    "maxLevel": 5,
    "points": 25,
    "requirements": { "temple": 5 }
  },
  "hospital": {
    "name": "Hospital",
    "description": "Heal your wounded troops after battle.",
    "baseCost": { "wood": 200, "stone": 150, "silver": 100, "population": 8, "time": 180 },
    "image": "hospital.png",
    "maxLevel": 10,
    "points": 10,
    "requirements": { "barracks": 3 }
  },
  "special_building_plot": {
    "name": "Wonders",
    "description": "Construct a legendary building that provides a unique, city-wide bonus.",
    "image": "special_building_plot.png",
    "constructible": false,
    "points": 500
  },
  "heroes_altar": {
    "name": "Heroes' Altar",
    "description": "Recruit legendary heroes and activate their powerful skills.",
    "baseCost": { "wood": 1000, "stone": 1000, "silver": 1000, "population": 10, "time": 3600 },
    "image": "heroes_altar.png",
    "maxLevel": 1,
    "points": 100,
    "requirements": { "senate": 8, "temple": 3 }
  },
  "prison": {
    "name": "Prison",
    "description": "Holds captured enemy heroes. Heroes escape if the city is successfully conquered. Higher levels allow holding more heroes.",
    "baseCost": { "wood": 800, "stone": 1200, "silver": 1000, "population": 15, "time": 2500 },
    "image": "prison.png",
    "maxLevel": 25,
    "points": 30,
    "requirements": { "city_wall": 5 }
  }
}
</file>

<file path="src/gameData/gods.json">
{
    "greek": {
        "Zeus": {
            "name": "Zeus",
            "description": "King of the Gods, master of lightning and the sky.",
            "powers": [
                {
                    "name": "Divine Sign",
                    "description": "Instantly send 250 silver to a target city.",
                    "favorCost": 50,
                    "effect": { "type": "add_resources", "resource": "silver", "amount": 250, "target": "both" }
                },
                {
                    "name": "Lightning Bolt",
                    "description": "Destroy a random enemy building level in a target city.",
                    "favorCost": 200,
                    "effect": { "type": "damage_building", "amount": 1, "target": "other" }
                }
            ],
            "mythical_units": ["Minotaur", "Manticore"],
            "image": "zeus.png"
        },
        "Hera": {
            "name": "Hera",
            "description": "Queen of the Gods, protector of marriage and family.",
            "powers": [
                {
                    "name": "Wedding",
                    "description": "Instantly send 250 wood to a target city.",
                    "favorCost": 50,
                    "effect": { "type": "add_resources", "resource": "wood", "amount": 250, "target": "both" }
                },
                {
                    "name": "Satisfaction",
                    "description": "Increase resource production by 10% for 1 hour in a target city.",
                    "favorCost": 150,
                    "effect": { "type": "resource_boost", "multiplier": 1.1, "duration": 3600, "target": "both" }
                }
            ],
            "mythical_units": ["Harpy", "Medusa"],
            "image": "hera.png"
        },
        "Athena": {
            "name": "Athena",
            "description": "Goddess of wisdom, courage, and strategic warfare.",
            "powers": [
                {
                    "name": "City Protection",
                    "description": "Your city cannot be attacked for 1 hour.",
                    "favorCost": 300,
                    "effect": { "type": "protection", "duration": 3600, "target": "self" }
                },
                {
                    "name": "Wisdom",
                    "description": "All your troops gain +10% attack for their next battle.",
                    "favorCost": 180,
                    "effect": { "type": "attack_boost", "multiplier": 1.1, "target": "self" }
                }
            ],
            "mythical_units": ["Centaur", "Pegasus"],
            "image": "athena.png"
        }
    },
    "roman": {
        "Jupiter": {
            "name": "Jupiter",
            "description": "The Roman equivalent of Zeus, god of the sky and thunder.",
            "powers": [
                {
                    "name": "Divine Sign",
                    "description": "Instantly send 250 silver to a target city.",
                    "favorCost": 50,
                    "effect": { "type": "add_resources", "resource": "silver", "amount": 250, "target": "both" }
                },
                {
                    "name": "Lightning Bolt",
                    "description": "Destroy a random enemy building level in a target city.",
                    "favorCost": 200,
                    "effect": { "type": "damage_building", "amount": 1, "target": "other" }
                }
            ],
            "mythical_units": ["Minotaur", "Manticore"],
            "image": "jupiter.png"
        },
        "Juno": {
            "name": "Juno",
            "description": "The Roman equivalent of Hera, protector of the Roman people.",
            "powers": [
                {
                    "name": "Wedding",
                    "description": "Instantly send 250 wood to a target city.",
                    "favorCost": 50,
                    "effect": { "type": "add_resources", "resource": "wood", "amount": 250, "target": "both" }
                },
                {
                    "name": "Satisfaction",
                    "description": "Increase resource production by 10% for 1 hour in a target city.",
                    "favorCost": 150,
                    "effect": { "type": "resource_boost", "multiplier": 1.1, "duration": 3600, "target": "both" }
                }
            ],
            "mythical_units": ["Harpy", "Medusa"],
            "image": "juno.png"
        },
        "Minerva": {
            "name": "Minerva",
            "description": "The Roman equivalent of Athena, goddess of wisdom and strategic warfare.",
            "powers": [
                {
                    "name": "City Protection",
                    "description": "Your city cannot be attacked for 1 hour.",
                    "favorCost": 300,
                    "effect": { "type": "protection", "duration": 3600, "target": "self" }
                },
                {
                    "name": "Wisdom",
                    "description": "All your troops gain +10% attack for their next battle.",
                    "favorCost": 180,
                    "effect": { "type": "attack_boost", "multiplier": 1.1, "target": "self" }
                }
            ],
            "mythical_units": ["Centaur", "Pegasus"],
            "image": "minerva.png"
        }
    },
    "egyptian": {
        "Anubis": {
            "name": "Anubis",
            "description": "God of the dead and the embalming process, protector of tombs.",
            "powers": [
                {
                    "name": "Plague of Locusts",
                    "description": "Reduce a target city's resource production by 20% for 1 hour.",
                    "favorCost": 250,
                    "effect": { "type": "production_debuff", "multiplier": 0.8, "duration": 3600, "target": "other" }
                },
                {
                    "name": "Underworld's Favor",
                    "description": "Revive 10% of your troops lost in the next battle.",
                    "favorCost": 350,
                    "effect": { "type": "revive_troops", "percentage": 0.1, "target": "self" }
                }
            ],
            "mythical_units": ["Sphinx", "Scarab"],
            "image": "anubis.png"
        },
        "Horus": {
            "name": "Horus",
            "description": "God of the sky, kingship, and order.",
            "powers": [
                {
                    "name": "Favorable Winds",
                    "description": "Your naval units travel 20% faster for 1 hour.",
                    "favorCost": 120,
                    "effect": { "type": "naval_speed_boost", "multiplier": 1.2, "duration": 3600, "target": "self" }
                },
                {
                    "name": "Vision of the Sky",
                    "description": "Reveal the number of incoming attacks on your city.",
                    "favorCost": 80,
                    "effect": { "type": "reveal_attacks", "target": "self" }
                }
            ],
            "mythical_units": ["Griffin", "Phoenix"],
            "image": "horus.png"
        },
        "Osiris": {
            "name": "Osiris",
            "description": "God of the afterlife, the underworld, and rebirth.",
            "powers": [
                {
                    "name": "Resurrection",
                    "description": "Instantly revive 5 of your most powerful deceased units.",
                    "favorCost": 400,
                    "effect": { "type": "revive_specific_troops", "amount": 5, "target": "self" }
                },
                {
                    "name": "Bountiful Harvest",
                    "description": "Instantly send 250 wood and 250 stone to a target city.",
                    "favorCost": 100,
                    "effect": { "type": "add_multiple_resources", "resources": { "wood": 250, "stone": 250 }, "target": "both" }
                }
            ],
            "mythical_units": ["Mummy", "Serpopard"],
            "image": "osiris.png"
        }
    }
}
</file>

<file path="src/gameData/heroes.json">
{
  "achilles": {
    "name": "Achilles",
    "description": "A legendary warrior whose skill in battle is unmatched. He inspires troops to fight with greater ferocity.",
    "image": "achilles.png",
    "cost": { "silver": 5000, "favor": 100 },
    "maxLevel": 10,
    "xpPerLevel": [100, 250, 500, 1000, 2000, 4000, 8000, 16000, 32000],
    "levelUpCost": { "silver": 1000, "favor": 20 },
    "passive": {
        "name": "Warrior's Presence",
        "description": "Increases land unit attack by 5% (+1% per level) in this city.",
        "effect": { "type": "city_buff", "subtype": "land_attack", "baseValue": 0.05, "valuePerLevel": 0.01 }
    },
    "skills": [
      {
        "name": "Warcry",
        "type": "battle",
        "description": "Boosts the attack of all land units by 10% (+2% per level) for the next battle.",
        "cost": { "favor": { "base": 50, "perLevel": 5 } },
        "cooldown": 3600,
        "icon": "warcry.png",
        "effect": { "type": "troop_buff", "subtype": "attack", "baseValue": 0.10, "valuePerLevel": 0.02, "unit_type": "land" }
      },
      {
        "name": "Rapid Mobilization",
        "type": "city",
        "description": "Reduces recruitment time in the Barracks by 15% (+1% per level) for 1 hour.",
        "cost": { "favor": { "base": 30, "perLevel": 3 } },
        "cooldown": 7200,
        "icon": "rapid_mobilization.png",
        "effect": { "type": "city_buff", "subtype": "recruitment_speed", "baseValue": 0.15, "valuePerLevel": 0.01, "duration": 3600 }
      }
    ]
  },
  "odysseus": {
    "name": "Odysseus",
    "description": "A cunning strategist known for his intellect and trickery. He excels at espionage and naval tactics.",
    "image": "odysseus.png",
    "cost": { "silver": 4500, "favor": 120 },
    "maxLevel": 10,
    "xpPerLevel": [100, 250, 500, 1000, 2000, 4000, 8000, 16000, 32000],
    "levelUpCost": { "silver": 900, "favor": 25 },
    "passive": {
        "name": "Cunning Mind",
        "description": "Increases silver production by 10% (+1.5% per level) in this city.",
        "effect": { "type": "city_buff", "subtype": "silver_production", "baseValue": 0.10, "valuePerLevel": 0.015 }
    },
    "skills": [
      {
        "name": "Naval Superiority",
        "type": "battle",
        "description": "Boosts the speed of all naval units by 15% (+1% per level) for the next battle.",
        "cost": { "favor": { "base": 40, "perLevel": 4 } },
        "cooldown": 3600,
        "icon": "naval_superiority.png",
        "effect": { "type": "troop_buff", "subtype": "speed", "baseValue": 0.15, "valuePerLevel": 0.01, "unit_type": "naval" }
      },
      {
        "name": "Master Spy",
        "type": "city",
        "description": "Increases the effectiveness of spies by 20% (+2% per level) for 2 hours.",
        "cost": { "favor": { "base": 60, "perLevel": 6 } },
        "cooldown": 7200,
        "icon": "master_spy.png",
        "effect": { "type": "city_buff", "subtype": "spy_effectiveness", "baseValue": 0.20, "valuePerLevel": 0.02, "duration": 7200 }
      }
    ]
  }
}
</file>

<file path="src/gameData/puzzles.json">
{
  "puzzle_1": {
    "question": "I have cities, but no houses. I have mountains, but no trees. I have water, but no fish. What am I?",
    "answer": "A map"
  },
  "puzzle_2": {
    "question": "What has an eye, but cannot see?",
    "answer": "A needle"
  },
  "puzzle_3": {
    "question": "What is full of holes but still holds water?",
    "answer": "A sponge"
  }
}
</file>

<file path="src/gameData/quests.json">
{
  "build_timber_camp_2": {
    "title": "First Steps",
    "description": "Secure your wood supply by upgrading your Timber Camp.",
    "type": "building",
    "targetId": "timber_camp",
    "targetLevel": 2,
    "rewards": {
      "resources": { "wood": 100 }
    }
  },
  "build_timber_camp_5": {
    "title": "Woody",
    "description": "Get that wood.",
    "type": "building",
    "targetId": "timber_camp",
    "targetLevel": 5,
    "rewards": {
      "resources": { "wood": 200 }
    }
  }
}
</file>

<file path="src/gameData/research.json">
{
  "logistics": {
    "name": "Logistics",
    "description": "Increases the speed of your land units by 10%.",
    "cost": { "wood": 1000, "stone": 1200, "silver": 800, "time": 1800, "points": 5 },
    "requirements": { "academy": 1 },
    "effect": { "type": "unit_speed_land", "value": 1.1 }
  },
  "architecture": {
    "name": "Architecture",
    "description": "Reduces the construction time of buildings by 10%.",
    "cost": { "wood": 1500, "stone": 2000, "silver": 1000, "time": 3600, "points": 8 },
    "requirements": { "academy": 2 },
    "effect": { "type": "build_time", "value": 0.9 }
  },
  "ballistics": {
    "name": "Ballistics",
    "description": "Increases the attack power of archers and slingers by 10%.",
    "cost": { "wood": 2000, "stone": 1500, "silver": 2500, "time": 5400, "points": 12 },
    "requirements": { "academy": 3, "research": "logistics" },
    "effect": { "type": "unit_attack_ranged", "value": 1.1 }
  },
  "shipwright": {
    "name": "Shipwright",
    "description": "Increases the speed of your naval units by 10%.",
    "cost": { "wood": 2500, "stone": 1800, "silver": 2200, "time": 7200, "points": 15 },
    "requirements": { "academy": 4 },
    "effect": { "type": "unit_speed_naval", "value": 1.1 }
  },
  "phalanx": {
    "name": "Phalanx",
    "description": "Increases the defensive strength of hoplites by 15%.",
    "cost": { "wood": 3000, "stone": 4000, "silver": 3500, "time": 10800, "points": 20 },
    "requirements": { "academy": 5, "research": "architecture" },
    "effect": { "type": "unit_defense_hoplite", "value": 1.15 }
  }
}
</file>

<file path="src/gameData/ruinsResearch.json">
{
  "qol_research_0": {
    "name": "Advanced Cartography",
    "description": "Your troops travel 5% faster on the world map.",
    "effect": { "type": "speed_boost_all", "value": 0.05 }
  },
  "qol_research_1": {
    "name": "Efficient Logistics",
    "description": "Your transport ships can carry 10% more units.",
    "effect": { "type": "transport_capacity_boost", "value": 0.10 }
  },
  "qol_research_2": {
    "name": "Scouting Techniques",
    "description": "Your scouts are 10% more effective.",
    "effect": { "type": "scout_power_boost", "value": 0.10 }
  }
}
</file>

<file path="src/gameData/specialBuildings.json">
{
  "great_lighthouse": {
    "name": "Great Lighthouse",
    "description": "A beacon of hope for your navy, increasing the speed and attack power of all ships.",
    "bonus": {
      "type": "naval_boost",
      "value": 0.10
    },
    "image": "great_lighthouse.png"
  },
  "colossus": {
    "name": "Colossus",
    "description": "A towering statue that inspires your armies, increasing the attack power of all land troops.",
    "bonus": {
      "type": "land_boost",
      "value": 0.10
    },
    "image": "colossus.png"
  },
  "oracle": {
    "name": "Oracle",
    "description": "A mystical site that attracts powerful mythical creatures to your cause.",
    "bonus": {
      "type": "mythic_boost",
      "value": 0.10
    },
    "image": "oracle.png"
  },
  "hanging_gardens": {
    "name": "Hanging Gardens",
    "description": "Lush gardens that boost population growth and city happiness.",
    "bonus": {
      "type": "population_boost",
      "value": 0.10
    },
    "image": "hanging_gardens.png"
  },
  "merchant_guild": {
    "name": "Merchant Guild",
    "description": "Establishes powerful trade routes, increasing the speed and capacity of your trades.",
    "bonus": {
      "type": "trade_boost",
      "value": 0.10
    },
    "image": "merchant_guild.png"
  },
  "library_of_alexandria": {
    "name": "Library of Alexandria",
    "description": "A center of knowledge that accelerates your research capabilities.",
    "bonus": {
      "type": "research_boost",
      "value": 0.10
    },
    "image": "library_of_alexandria.png"
  },
  "alliance_wonders": {
    "name": "Alliance Wonders",
    "description": "A special building only available to alliances that control an entire island.",
    "image": "alliance_wonders.png"
  }
}
</file>

<file path="src/gameData/units.json">
{
   "swordsman": {
    "name": "Swordsman",
    "description": "A basic melee unit, effective in close combat.",
    "cost": {
      "wood": 50,
      "stone": 30,
      "silver": 20,
      "population": 1,
      "time": 30
    },
    "heal_cost": { "wood": 15, "stone": 10, "silver": 6 },
"heal_time": 10,
    "attack": 10,
    "defense": 15,
    "speed": 5,
    "type": "land",
    "counters": ["archer"],
    "image": "swordman.png"
  },
  "archer": {
    "name": "Archer",
    "description": "A ranged unit that can attack from a distance.",
    "cost": {"wood": 30,"stone": 40,"silver": 35,"population": 1,"time": 45},
    "heal_cost": { "wood": 9, "stone": 12, "silver": 10 },"heal_time": 15,
    "attack": 12,"defense": 8,"speed": 6,"type": "land", "counters": ["swordsman"],"image": "archers.png"
  },
  "hoplite": {
    "name": "Hoplite",
    "description": "Heavily armored infantry, strong defensive unit.",
    "cost": {
      "wood": 70,
      "stone": 60,
      "silver": 40,
      "population": 2,
      "time": 60
    },
    "heal_cost": { "wood": 21, "stone": 18, "silver": 12 },
    "heal_time": 20,
    "attack": 15,
    "defense": 25,
    "speed": 4,
    "type": "land",
    "counters": ["cavalry"],
    "image": "hospite.png"
  },
  "cavalry": {
    "name": "Cavalry",
    "description": "Fast and powerful mounted units, good for flanking.",
    "cost": {
      "wood": 80,
      "stone": 50,
      "silver": 70,
      "population": 3,
      "time": 90
    },
    "heal_cost": { "wood": 24, "stone": 15, "silver": 21 },
    "heal_time": 30,
    "attack": 20,
    "defense": 18,
    "speed": 10,
    "type": "land",
    "counters": ["archer", "slinger"],
    "image": "cavalry.png"
  },
  "swordsman_athenian": {
    "name": "Athenian Swordsman",
    "description": "A versatile melee unit from Athens, balanced in attack and defense.",
    "cost": { "wood": 50, "stone": 30, "silver": 20, "population": 1, "time": 30 },
    "heal_cost": { "wood": 15, "stone": 10, "silver": 6 }, "heal_time": 10,
    "attack": 10, "defense": 15, "speed": 5, "type": "land", "nation": "Athenian",
    "image": "athenian_swordsman.png"
  },
  "archer_athenian": {
    "name": "Athenian Archer",
    "description": "A skilled archer from Athens, known for precision.",
    "cost": { "wood": 30, "stone": 40, "silver": 35, "population": 1, "time": 45 },
    "heal_cost": { "wood": 9, "stone": 12, "silver": 10 }, "heal_time": 15,
    "attack": 12, "defense": 8, "speed": 6, "type": "land", "nation": "Athenian",
    "image": "athenian_archer.png"
  },
  "hoplite_athenian": {
    "name": "Athenian Hoplite",
    "description": "The backbone of the Athenian army, well-armored and reliable.",
    "cost": { "wood": 70, "stone": 60, "silver": 40, "population": 2, "time": 60 },
    "heal_cost": { "wood": 21, "stone": 18, "silver": 12 }, "heal_time": 20,
    "attack": 15, "defense": 25, "speed": 4, "type": "land", "nation": "Athenian",
    "image": "athenian_hoplite.png"
  },
  "cavalry_athenian": {
    "name": "Athenian Cavalry",
    "description": "Noble horsemen of Athens, effective for flanking maneuvers.",
    "cost": { "wood": 80, "stone": 50, "silver": 70, "population": 3, "time": 90 },
    "heal_cost": { "wood": 24, "stone": 15, "silver": 21 }, "heal_time": 30,
    "attack": 20, "defense": 18, "speed": 10, "type": "land", "nation": "Athenian",
    "image": "athenian_cavalry.png"
  },
  "trireme_athenian": {
    "name": "Athenian Trireme",
    "description": "A powerful and versatile warship from the Athenian navy.",
    "cost": { "wood": 300, "stone": 150, "silver": 200, "population": 8, "time": 300 },
    "attack": 25, "defense": 30, "speed": 8, "type": "naval", "nation": "Athenian",
    "image": "athenian_trireme.png"
  },
  "swordsman_spartan": {
    "name": "Royal Spartan Guard",
    "description": "A disciplined and heavily armored warrior from Sparta, excelling in defense.",
    "cost": { "wood": 60, "stone": 40, "silver": 25, "population": 1, "time": 35 },
    "heal_cost": { "wood": 18, "stone": 12, "silver": 7 }, "heal_time": 12,
    "attack": 8, "defense": 20, "speed": 4, "type": "land", "nation": "Spartan",
    "image": "spartan_swordsman.png"
  },
  "archer_spartan": {
    "name": "Spartan Helot Archer",
    "description": "A lightly armored but disciplined archer serving the Spartan army.",
    "cost": { "wood": 35, "stone": 45, "silver": 30, "population": 1, "time": 50 },
    "heal_cost": { "wood": 10, "stone": 13, "silver": 9 }, "heal_time": 17,
    "attack": 10, "defense": 10, "speed": 5, "type": "land", "nation": "Spartan",
    "image": "spartan_archer.png"
  },
  "hoplite_spartan": {
    "name": "Spartan Hoplite",
    "description": "The elite of the Spartan phalanx, nearly unbreakable in defense.",
    "cost": { "wood": 80, "stone": 70, "silver": 50, "population": 2, "time": 70 },
    "heal_cost": { "wood": 24, "stone": 21, "silver": 15 }, "heal_time": 23,
    "attack": 16, "defense": 30, "speed": 3, "type": "land", "nation": "Spartan",
    "image": "spartan_hoplite.png"
  },
  "cavalry_spartan": {
    "name": "Spartan Rider",
    "description": "A heavy cavalry unit focused on breaking enemy lines.",
    "cost": { "wood": 90, "stone": 60, "silver": 80, "population": 3, "time": 100 },
    "heal_cost": { "wood": 27, "stone": 18, "silver": 24 }, "heal_time": 33,
    "attack": 22, "defense": 22, "speed": 9, "type": "land", "nation": "Spartan",
    "image": "spartan_cavalry.png"
  },
  "trireme_spartan": {
    "name": "Spartan Diekplous",
    "description": "A sturdy warship designed for ramming and boarding actions.",
    "cost": { "wood": 320, "stone": 180, "silver": 200, "population": 8, "time": 320 },
    "attack": 28, "defense": 35, "speed": 7, "type": "naval", "nation": "Spartan",
    "image": "spartan_trireme.png"
  },
  "swordsman_corinthian": {
    "name": "Corinthian Marine",
    "description": "A swift and aggressive fighter from Corinth, trained for rapid assaults.",
    "cost": { "wood": 45, "stone": 25, "silver": 30, "population": 1, "time": 28 },
    "heal_cost": { "wood": 13, "stone": 7, "silver": 9 }, "heal_time": 9,
    "attack": 12, "defense": 12, "speed": 6, "type": "land", "nation": "Corinthian",
    "image": "corinthian_marine.png"
  },
  "archer_corinthian": {
    "name": "Corinthian Skirmisher",
    "description": "A fast-moving archer that excels at harassing enemy forces.",
    "cost": { "wood": 28, "stone": 38, "silver": 40, "population": 1, "time": 42 },
    "heal_cost": { "wood": 8, "stone": 11, "silver": 12 }, "heal_time": 14,
    "attack": 13, "defense": 7, "speed": 7, "type": "land", "nation": "Corinthian",
    "image": "corinthian_archer.png"
  },
  "hoplite_corinthian": {
    "name": "Corinthian Phalanx",
    "description": "A well-equipped hoplite, more mobile than its counterparts.",
    "cost": { "wood": 65, "stone": 55, "silver": 45, "population": 2, "time": 55 },
    "heal_cost": { "wood": 19, "stone": 16, "silver": 13 }, "heal_time": 18,
    "attack": 16, "defense": 22, "speed": 5, "type": "land", "nation": "Corinthian",
    "image": "corinthian_hoplite.png"
  },
  "cavalry_corinthian": {
    "name": "Corinthian Hippeus",
    "description": "Light and swift cavalry, perfect for raiding and quick strikes.",
    "cost": { "wood": 75, "stone": 45, "silver": 75, "population": 3, "time": 85 },
    "heal_cost": { "wood": 22, "stone": 13, "silver": 22 }, "heal_time": 28,
    "attack": 21, "defense": 16, "speed": 12, "type": "land", "nation": "Corinthian",
    "image": "corinthian_cavalry.png"
  },
  "trireme_corinthian": {
    "name": "Corinthian Bireme",
    "description": "A fast and maneuverable warship, ideal for controlling the seas.",
    "cost": { "wood": 280, "stone": 140, "silver": 220, "population": 8, "time": 280 },
    "attack": 26, "defense": 28, "speed": 10, "type": "naval", "nation": "Corinthian",
    "image": "corinthian_trireme.png"
  },
  "swordsman_roman": {
    "name": "Legionary",
    "description": "A disciplined soldier of the Roman legions, balanced and effective.",
    "cost": { "wood": 50, "stone": 30, "silver": 20, "population": 1, "time": 30 },
    "heal_cost": { "wood": 15, "stone": 10, "silver": 6 }, "heal_time": 10,
    "attack": 10, "defense": 15, "speed": 5, "type": "land", "nation": "Julian",
    "image": "legionary.png"
  },
  "archer_roman": {
    "name": "Roman Archer",
    "description": "A disciplined archer providing ranged support for the legions.",
    "cost": { "wood": 30, "stone": 40, "silver": 35, "population": 1, "time": 45 },
    "heal_cost": { "wood": 9, "stone": 12, "silver": 10 }, "heal_time": 15,
    "attack": 12, "defense": 8, "speed": 6, "type": "land", "nation": "Julian",
    "image": "roman_archer.png"
  },
  "hoplite_roman": {
    "name": "Praetorian Guard",
    "description": "An elite unit of the Roman Army, formidable in both attack and defense.",
    "cost": { "wood": 70, "stone": 60, "silver": 40, "population": 2, "time": 60 },
    "heal_cost": { "wood": 21, "stone": 18, "silver": 12 }, "heal_time": 20,
    "attack": 18, "defense": 26, "speed": 4, "type": "land", "nation": "Julian",
    "image": "praetorian_guard.png"
  },
  "cavalry_roman": {
    "name": "Equites",
    "description": "Roman cavalry, effective at charging and disrupting enemy formations.",
    "cost": { "wood": 80, "stone": 50, "silver": 70, "population": 3, "time": 90 },
    "heal_cost": { "wood": 24, "stone": 15, "silver": 21 }, "heal_time": 30,
    "attack": 20, "defense": 18, "speed": 10, "type": "land", "nation": "Julian",
    "image": "equites.png"
  },
  "trireme_roman": {
    "name": "Roman Quinquereme",
    "description": "A large and powerful Roman warship, built for dominating naval battles.",
    "cost": { "wood": 300, "stone": 150, "silver": 200, "population": 8, "time": 300 },
    "attack": 30, "defense": 32, "speed": 8, "type": "naval", "nation": "Julian",
    "image": "roman_quinquereme.png"
  },
  "slinger": {
    "name": "Slinger",
    "description": "Light ranged unit, good against unarmored foes.",
    "cost": { "wood": 25, "stone": 20, "silver": 15, "population": 1, "time": 25 },
    "heal_cost": { "wood": 8, "stone": 6, "silver": 5 }, "heal_time": 8,
    "attack": 8, "defense": 10, "speed": 7, "type": "land",
    "image": "slinger.png"
  },
  "transport_ship": {
    "name": "Transport Ship",
    "description": "Standard transport for land units across seas. Slower but higher capacity.",
    "cost": { "wood": 200, "stone": 100, "silver": 150, "population": 5, "time": 180 },
    "attack": 0, "defense": 20, "speed": 10, "type": "naval", "capacity": 16,
    "image": "transport_ship.png"
  },
  "fast_transport_ship": {
    "name": "Fast Transport Ship",
    "description": "Faster transport for land units, but with less capacity.",
    "cost": { "wood": 250, "stone": 120, "silver": 180, "population": 6, "time": 240 },
    "attack": 0, "defense": 15, "speed": 15, "type": "naval", "capacity": 10,
    "image": "fast_transport_ship.png"
  },
  "minotaur": {
    "name": "Minotaur",
    "description": "A fearsome beast with the body of a man and the head of a bull.",
    "cost": { "wood": 300, "stone": 250, "silver": 400, "population": 10, "time": 600, "favor": 50 },
    "heal_cost": { "wood": 90, "stone": 75, "silver": 120 }, "heal_time": 200,
    "attack": 50, "defense": 40, "speed": 4, "type": "land", "mythical": true, "god": "Zeus",
    "image": "minotaur.png"
  },
   "manticore": {
    "name": "Manticore",
    "description": "A terrifying creature with the body of a lion, a human head, and a tail of venomous spines.",
    "cost": { "wood": 450, "stone": 150, "silver": 350, "population": 12, "time": 750, "favor": 65 },
    "heal_cost": { "wood": 135, "stone": 45, "silver": 105 }, "heal_time": 250,
    "attack": 60, "defense": 30, "speed": 7, "type": "land", "flying": true,"mythical": true, "god": "Zeus",
    "image": "manticore.png"
  },
  "harpy": {
    "name": "Harpy",
    "description": "A winged spirit of sharp claws and sharper temper.",
    "cost": { "wood": 150, "stone": 300, "silver": 200, "population": 8, "time": 450, "favor": 40 },
     "heal_cost": { "wood": 45, "stone": 90, "silver": 60 }, "heal_time": 150,
    "attack": 35, "defense": 25, "speed": 14, "type": "land", "flying": true, "mythical": true, "god": "Hera",
    "image": "harpy.png"
  },
  "medusa": {
    "name": "Medusa",
    "description": "A creature whose gaze can turn warriors to stone.",
    "cost": { "wood": 200, "stone": 400, "silver": 350, "population": 12, "time": 700, "favor": 60 },
     "heal_cost": { "wood": 60, "stone": 120, "silver": 105 }, "heal_time": 230,
    "attack": 40, "defense": 60, "speed": 3, "type": "land", "mythical": true, "god": "Hera",
    "image": "medusa.png"
  },
  "centaur": {
    "name": "Centaur",
    "description": "A skilled archer with the body of a horse, swift and deadly.",
    "cost": { "wood": 250, "stone": 150, "silver": 300, "population": 9, "time": 500, "favor": 45 },
    "heal_cost": { "wood": 75, "stone": 45, "silver": 90 }, "heal_time": 170,
    "attack": 45, "defense": 30, "speed": 9, "type": "land", "mythical": true, "god": "Athena",
    "image": "centaur.png"
  },
  "pegasus": {
    "name": "Pegasus",
    "description": "A divine winged stallion, the fastest scout in the land.",
    "cost": { "wood": 100, "stone": 100, "silver": 500, "population": 15, "time": 800, "favor": 70 },
    "heal_cost": { "wood": 30, "stone": 30, "silver": 150 }, "heal_time": 270,
    "attack": 10, "defense": 50, "speed": 25, "type": "land", "flying": true, "mythical": true, "god": "Athena",
    "image": "pegasus.png"
  },
  "sphinx": {
    "name": "Sphinx",
    "description": "A mythical creature with the head of a human, the body of a lion, and the wings of a falcon.",
    "cost": { "wood": 350, "stone": 200, "silver": 300, "population": 11, "time": 650, "favor": 55 },
    "heal_cost": { "wood": 105, "stone": 60, "silver": 90 }, "heal_time": 220,
    "attack": 55, "defense": 45, "speed": 16, "type": "land", "flying": true, "mythical": true, "god": "Anubis",
    "image": "sphinx.png"
  },
  "scarab": {
    "name": "Scarab",
    "description": "A large, heavily armored beetle that moves slowly but is incredibly resilient.",
    "cost": { "wood": 100, "stone": 500, "silver": 150, "population": 7, "time": 400, "favor": 35 },
    "heal_cost": { "wood": 30, "stone": 150, "silver": 45 }, "heal_time": 130,
    "attack": 20, "defense": 70, "speed": 2, "type": "land", "mythical": true, "god": "Anubis",
    "image": "scarab.png"
  },
  "griffin": {
    "name": "Griffin",
    "description": "A legendary creature with the body, tail, and back legs of a lion; the head and wings of an eagle.",
    "cost": { "wood": 400, "stone": 200, "silver": 250, "population": 13, "time": 720, "favor": 62 },
    "heal_cost": { "wood": 120, "stone": 60, "silver": 75 }, "heal_time": 240,
    "attack": 65, "defense": 35, "speed": 18, "type": "land", "flying": true, "mythical": true, "god": "Horus",
    "image": "griffin.png"
  },
  "phoenix": {
    "name": "Phoenix",
    "description": "A long-lived bird that cyclically regenerates or is otherwise born again.",
    "cost": { "wood": 100, "stone": 100, "silver": 600, "population": 18, "time": 900, "favor": 80 },
    "heal_cost": { "wood": 30, "stone": 30, "silver": 180 }, "heal_time": 300,
    "attack": 30, "defense": 60, "speed": 22, "type": "land", "flying": true, "mythical": true, "god": "Horus",
    "image": "phoenix.png"
  },
  "mummy": {
    "name": "Mummy",
    "description": "An undead creature wrapped in bandages, cursed to serve its master.",
    "cost": { "wood": 50, "stone": 350, "silver": 250, "population": 6, "time": 350, "favor": 30 },
    "heal_cost": { "wood": 15, "stone": 105, "silver": 75 }, "heal_time": 120,
    "attack": 25, "defense": 55, "speed": 3, "type": "land", "mythical": true, "god": "Osiris",
    "image": "mummy.png"
  },
  "serpopard": {
    "name": "Serpopard",
    "description": "A mythical animal with the body of a leopard and the long neck of a serpent.",
    "cost": { "wood": 300, "stone": 150, "silver": 400, "population": 10, "time": 620, "favor": 58 },
    "heal_cost": { "wood": 90, "stone": 45, "silver": 120 }, "heal_time": 210,
    "attack": 58, "defense": 42, "speed": 8, "type": "land", "mythical": true, "god": "Osiris",
    "image": "serpopard.png"
  },
      "villager": {
    "name": "Villager",
    "description": "A passive troop that helps in founding new cities faster.",
    "cost": {
      "wood": 40,
      "stone": 40,
      "silver": 40,
      "population": 1,
      "time": 20
    },
    "attack": 0,
    "defense": 5,
    "speed": 5,
    "type": "land",
    "passive": true,
    "image": "villager.png"
  }
}
</file>

<file path="src/hooks/actions/useAdminActions.js">
import { collection, doc, query, where, limit, getDocs, setDoc as firestoreSetDoc, runTransaction } from 'firebase/firestore';
import { db } from '../../firebase/config';
import { useGame } from '../../contexts/GameContext';
import { generateGodTowns } from '../../utils/worldGeneration';
import researchConfig from '../../gameData/research.json';
import buildingConfig from '../../gameData/buildings.json';
import { clearProfileCache } from '../../components/profile/ProfileView';
import { clearMemberCache } from '../../components/alliance/AllianceMembers';
import { clearLeaderboardCache } from '../../components/leaderboard/Leaderboard';

export const useAdminActions = ({
    userProfile, worldId, cityGameState, currentUser,
    setIsInstantBuild, setIsInstantResearch, setIsInstantUnits,
    saveGameState, setMessage
}) => {
    const { worldState, playerCities } = useGame();

    const handleSpawnGodTown = async () => {
        if (!userProfile?.is_admin || !worldState) {
            setMessage("You are not authorized or world data is not loaded.");
            return;
        }

        setMessage("Spawning a God Town...");
        try {
            const newTowns = generateGodTowns(worldState.islands, worldState.width, worldState.height, 1);
            if (Object.keys(newTowns).length === 0) {
                throw new Error("Failed to find a suitable location in the sea. Try again.");
            }
            const [townId, townData] = Object.entries(newTowns)[0];

            const townDocRef = doc(db, 'worlds', worldId, 'godTowns', townId);
            await firestoreSetDoc(townDocRef, townData);

            setMessage(`God Town spawned as "Strange Ruins" at (${townData.x}, ${townData.y})!`);
        } catch (error) {
            console.error("Error spawning God Town:", error);
            setMessage(`Failed to spawn God Town: ${error.message}`);
        }
    };

    const handleCheat = async (amounts, troop, farmLevels, warehouseLevels, isInstantBuild, unresearchId, isInstantResearch, isInstantUnits, favorAmount, foundSecondCity, forceRefresh) => {
        if (!cityGameState || !userProfile?.is_admin) return;

        // #comment Handle the new force refresh action
        if (forceRefresh) {
            clearProfileCache();
            clearMemberCache();
            clearLeaderboardCache();
            setMessage("All data caches have been cleared successfully!");
            return;
        }

        if (foundSecondCity) {
            if (!worldId) {
                setMessage("Cannot found city: World ID is missing.");
                console.error("worldId is missing in handleCheat");
                return;
            }
            setMessage('Finding a suitable location for your new city...');

            const citySlotsRef = collection(db, 'worlds', worldId, 'citySlots');
            const q = query(citySlotsRef, where('ownerId', '==', null), limit(10));
            let selectedSlot = null;
            try {
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    const randomDoc = querySnapshot.docs[Math.floor(Math.random() * querySnapshot.docs.length)];
                    selectedSlot = { id: randomDoc.id, ...randomDoc.data() };
                }
            } catch (error) {
                console.error("Error finding an empty slot:", error);
                setMessage('Error finding a location.');
                return;
            }

            if (!selectedSlot) {
                setMessage('Could not find an available city slot. This world might be full.');
                return;
            }

            setMessage(`Location found at (${selectedSlot.x}, ${selectedSlot.y}). Founding city...`);

            const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', selectedSlot.id);
            const newCityDocRef = doc(collection(db, 'users', currentUser.uid, 'games', worldId, 'cities'));

            try {
                await runTransaction(db, async (transaction) => {
                    const slotSnap = await transaction.get(citySlotRef);
                    if (!slotSnap.exists() || slotSnap.data().ownerId !== null) {
                        throw new Error("This location was taken while processing. Please try again.");
                    }

                    const existingCityNames = Object.values(playerCities).map(c => c.cityName);

                    const baseName = `${userProfile.username}'s Colony`;
                    let finalCityName = baseName;

                    if (existingCityNames.includes(finalCityName)) {
                        let count = 2;
                        let newName;
                        do {
                            newName = `${baseName} ${count}`;
                            count++;
                        } while (existingCityNames.includes(newName));
                        finalCityName = newName;
                    }

                    transaction.update(citySlotRef, {
                        ownerId: currentUser.uid,
                        ownerUsername: userProfile.username,
                        cityName: finalCityName
                    });

                    const initialBuildings = {};
                    Object.keys(buildingConfig).forEach(id => {
                        initialBuildings[id] = { level: 0 };
                    });
                    ['senate', 'farm', 'warehouse', 'timber_camp', 'quarry', 'silver_mine', 'cave'].forEach(id => {
                        initialBuildings[id] = { level: 1 };
                    });

                    const newCityData = {
                        id: newCityDocRef.id,
                        slotId: selectedSlot.id,
                        x: selectedSlot.x,
                        y: selectedSlot.y,
                        islandId: selectedSlot.islandId,
                        cityName: finalCityName,
                        playerInfo: cityGameState.playerInfo,
                        resources: { wood: 1000, stone: 1000, silver: 500 },
                        buildings: initialBuildings,
                        units: {},
                        wounded: {},
                        research: {},
                        worship: {},
                        cave: { silver: 0 },
                        buildQueue: [],
                        barracksQueue: [],
                        shipyardQueue: [],
                        divineTempleQueue: [],
                        healQueue: [],
                        lastUpdated: Date.now(),
                    };

                    transaction.set(newCityDocRef, newCityData);
                });
                setMessage(`New city founded successfully!`);
            } catch (error) {
                console.error("Error founding city with cheat: ", error);
                setMessage(`Failed to found city: ${error.message}`);
            }
            return;
        }

        setIsInstantBuild(isInstantBuild);
        setIsInstantResearch(isInstantResearch);
        setIsInstantUnits(isInstantUnits);

        const newGameState = { ...cityGameState };
        newGameState.resources.wood += amounts.wood;
        newGameState.resources.stone += amounts.stone;
        newGameState.resources.silver += amounts.silver;

        if (farmLevels > 0) {
            newGameState.buildings.farm.level = farmLevels;
        }
        if (troop.amount > 0) {
            newGameState.units[troop.unit] = (newGameState.units[troop.unit] || 0) + troop.amount;
        }
        if (warehouseLevels > 0) {
            newGameState.buildings.warehouse.level = warehouseLevels;
        }
        if (unresearchId && newGameState.research[unresearchId]) {
            delete newGameState.research[unresearchId];
            setMessage(`Research "${researchConfig[unresearchId]?.name}" unreasearched!`);
        } else if (unresearchId) {
            setMessage(`Research "${researchConfig[unresearchId]?.name}" is not researched.`);
        }
        if (favorAmount > 0 && newGameState.god) {
            const currentFavor = newGameState.worship[newGameState.god] || 0;
            const templeLevel = newGameState.buildings.temple?.level || 0;
            const maxFavor = templeLevel > 0 ? 100 + (templeLevel * 20) : 0;
            newGameState.worship[newGameState.god] = Math.min(maxFavor, currentFavor + favorAmount);
            setMessage(`Added ${favorAmount} favor to ${newGameState.god}!`);
        } else if (favorAmount > 0 && !newGameState.god) {
            setMessage("No god is currently worshipped to add favor.");
        }

        await saveGameState(newGameState);
        setMessage("Admin cheat applied!");
    };

    return { handleSpawnGodTown, handleCheat };
};
</file>

<file path="src/hooks/actions/useAgentActions.js">
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { db } from '../../firebase/config';
import { doc, runTransaction } from 'firebase/firestore';
import agentsConfig from '../../gameData/agents.json';

// #comment Handles actions related to agents like recruiting.
export const useAgentActions = (cityGameState, saveGameState, setMessage) => {
    const { currentUser } = useAuth();
    const { worldId, activeCityId } = useGame();

    // #comment Logic to recruit a new agent.
    const onRecruitAgent = async (agentId) => {
        const agent = agentsConfig[agentId];
        if (!agent) return;

        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', activeCityId);
        try {
            await runTransaction(db, async (transaction) => {
                const cityDoc = await transaction.get(cityDocRef);
                if (!cityDoc.exists()) throw new Error("City data not found.");
                const cityData = cityDoc.data();

                if (cityData.resources.wood < agent.cost.wood) throw new Error("Not enough wood.");
                if (cityData.resources.stone < agent.cost.stone) throw new Error("Not enough stone.");
                if (cityData.resources.silver < agent.cost.silver) throw new Error("Not enough silver.");

                const newResources = {
                    ...cityData.resources,
                    wood: cityData.resources.wood - agent.cost.wood,
                    stone: cityData.resources.stone - agent.cost.stone,
                    silver: cityData.resources.silver - agent.cost.silver
                };

                const newAgents = {
                    ...cityData.agents,
                    [agentId]: (cityData.agents?.[agentId] || 0) + 1
                };

                transaction.update(cityDocRef, { resources: newResources, agents: newAgents });
            });
            setMessage(`${agent.name} has been recruited!`);
        } catch (error) {
            setMessage(`Failed to recruit agent: ${error.message}`);
        }
    };

    // #comment Placeholder for assigning an agent.
    const onAssignAgent = async (agentId) => {
        setMessage(`${agentsConfig[agentId].name} is ready for duty.`);
    };

    return { onRecruitAgent, onAssignAgent };
};
</file>

<file path="src/hooks/actions/useAllianceActions.js">
// src/hooks/actions/useAllianceActions.js
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { db } from '../../firebase/config';
import { doc, runTransaction, collection, getDocs, updateDoc, arrayUnion, writeBatch, getDoc, arrayRemove, addDoc, serverTimestamp } from "firebase/firestore";
import { sendSystemMessage } from '../../utils/sendSystemMessage';
import allianceResearch from '../../gameData/allianceResearch.json';
import { clearMemberCache } from '../../components/alliance/AllianceMembers';

const calculateMaxMembers = (alliance) => {
    const baseMax = 20;
    const researchLevel = alliance.research?.expanded_charter?.level || 0;
    const researchBonus = allianceResearch.expanded_charter.effect.value * researchLevel;
    return baseMax + researchBonus;
};

export const useAllianceActions = (playerAlliance) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId} = useGame();

    const createAlliance = async (name, tag) => {
        if (!currentUser || !worldId || !userProfile) return;

        const citiesRef = collection(db, `users/${currentUser.uid}/games`, worldId, 'cities');
        const citiesSnap = await getDocs(citiesRef);
        const userCitySlotIds = citiesSnap.docs.map(doc => doc.data().slotId);

        if (userCitySlotIds.length === 0) {
            throw new Error("You must have a city to create an alliance.");
        }

        const allianceId = tag.toUpperCase();
        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', allianceId);
        const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);
        const eventsRef = collection(db, 'worlds', worldId, 'alliances', allianceId, 'events');

        try {
            await runTransaction(db, async (transaction) => {
                const allianceDoc = await transaction.get(allianceDocRef);
                if (allianceDoc.exists()) {
                    throw new Error("An alliance with this tag already exists.");
                }

                const gameDoc = await transaction.get(gameDocRef);
                if (!gameDoc.exists()) {
                    throw new Error("Player game data not found.");
                }

                const playerData = gameDoc.data();
                if (playerData.alliance) {
                    throw new Error("You are already in an alliance.");
                }

                const newAlliance = {
                    name,
                    tag: allianceId,
                    leader: { uid: currentUser.uid, username: userProfile.username },
                    members: [{ uid: currentUser.uid, username: userProfile.username, rank: 'Leader' }],
                    research: {},
                    bank: { wood: 0, stone: 0, silver: 0, capacity: 100000 },
                    diplomacy: { allies: [], enemies: [], requests: [] },
                    settings: {
                        status: 'open',
                        description: `A new alliance, '${name}', has been formed!`,
                        privateDescription: '',
                    },
                    ranks: [
                        { id: 'Leader', name: 'Leader', permissions: {
                            manageRanks: true, manageSettings: true, manageDiplomacy: true, inviteMembers: true, kickMembers: true, banMembers: true, recommendResearch: true, viewSecretForums: true, manageBank: true, withdrawFromBank: true, proposeTreaties: true, viewMemberActivity: true
                        }},
                        { id: 'Member', name: 'Member', permissions: {
                            manageRanks: false, manageSettings: false, manageDiplomacy: false, inviteMembers: false, kickMembers: false, banMembers: false, recommendResearch: false, viewSecretForums: false, manageBank: false, withdrawFromBank: false, proposeTreaties: false, viewMemberActivity: false
                        }}
                    ],
                    banned: [],
                    applications: [],
                };

                transaction.set(allianceDocRef, newAlliance);
                transaction.update(gameDocRef, { alliance: allianceId });


                for (const slotId of userCitySlotIds) {
                    const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', slotId);
                    transaction.update(citySlotRef, { alliance: allianceId, allianceName: name });
                }
                
                transaction.set(doc(eventsRef), {
                    type: 'alliance_created',
                    text: `The alliance '${name}' [${tag.toUpperCase()}] was founded by ${userProfile.username}.`,
                    timestamp: serverTimestamp(),
                });
            });
        } catch (error) {
            console.error("Error creating alliance: ", error);
            throw error;
        }
    };

    const updateAllianceSettings = async (settings) => {
        if (!playerAlliance) return;
        const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
        const rank = playerAlliance.ranks.find(r => r.id === member?.rank);
        if (!rank?.permissions?.manageSettings) return;

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        await updateDoc(allianceDocRef, { settings });

        const eventsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'events');
        await addDoc(eventsRef, {
            type: 'settings_updated',
            text: `${userProfile.username} updated the alliance settings.`,
            timestamp: serverTimestamp(),
        });
    };

    const applyToAlliance = async (allianceId) => {
        if (!currentUser || !worldId || !userProfile) {
            throw new Error("User or world not identified.");
        }
        if (playerAlliance) {
            throw new Error("You are already in an alliance.");
        }

        const allianceRef = doc(db, 'worlds', worldId, 'alliances', allianceId);

        const allianceSnap = await getDoc(allianceRef);
        if (allianceSnap.exists()) {
            const allianceData = allianceSnap.data();
            if (allianceData.banned?.some(b => b.uid === currentUser.uid)) {
                throw new Error("You are banned from this alliance.");
            }
            const existingApplication = allianceData.applications?.find(app => app.userId === currentUser.uid);
            if (existingApplication) {
                throw new Error("You have already applied to this alliance.");
            }

            await updateDoc(allianceRef, {
                applications: arrayUnion({
                    userId: currentUser.uid,
                    username: userProfile.username,
                    timestamp: new Date()
                })
            });

            const leaderId = allianceData.leader.uid;
            const leaderUsername = allianceData.leader.username;
            const messageText = `You have a new application for [alliance id=${allianceId}]${allianceData.name}[/alliance] from [player id=${currentUser.uid}]${userProfile.username}[/player].`;
            await sendSystemMessage(leaderId, leaderUsername, messageText, worldId);

        } else {
            throw new Error("Alliance not found.");
        }
    };

    const leaveAlliance = async () => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        if (playerAlliance.leader.uid === currentUser.uid && playerAlliance.members.length > 1) {
            throw new Error("Leaders must pass leadership before leaving.");
        }

        const citiesRef = collection(db, `users/${currentUser.uid}/games`, worldId, 'cities');
        const citiesSnap = await getDocs(citiesRef);
        const userCitySlotIds = citiesSnap.docs.map(doc => doc.data().slotId);

        const allianceRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const gameRef = doc(db, `users/${currentUser.uid}/games`, worldId);
        const eventsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'events');

        await runTransaction(db, async (transaction) => {
            if (playerAlliance.members.length === 1) {
                transaction.delete(allianceRef);
            } else {
                const memberToRemove = playerAlliance.members.find(m => m.uid === currentUser.uid);
                if (memberToRemove) {
                    transaction.update(allianceRef, {
                        members: arrayRemove(memberToRemove)
                    });
                }
            }
            transaction.update(gameRef, { alliance: null });
            for (const slotId of userCitySlotIds) {
                const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', slotId);
                transaction.update(citySlotRef, { alliance: null, allianceName: null });
            }
            transaction.set(doc(eventsRef), {
                type: 'member_left',
                text: `${userProfile.username} has left the alliance.`,
                timestamp: serverTimestamp(),
            });
        });
        
        clearMemberCache();
    };

    const disbandAlliance = async () => {
        if (!playerAlliance || playerAlliance.leader.uid !== currentUser.uid) {
            throw new Error("You are not the leader of this alliance.");
        }

        const allianceRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const batch = writeBatch(db);

        for (const member of playerAlliance.members) {
            const gameRef = doc(db, `users/${member.uid}/games`, worldId);
            batch.update(gameRef, { alliance: null });

            const citiesRef = collection(db, `users/${member.uid}/games`, worldId, 'cities');
            const citiesSnap = await getDocs(citiesRef);
            citiesSnap.forEach(cityDoc => {
                const cityData = cityDoc.data();
                if (cityData.slotId) {
                    const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', cityData.slotId);
                    batch.update(citySlotRef, { alliance: null, allianceName: null });
                }
            });
        }
        batch.delete(allianceRef);
        await batch.commit();
    };

    const joinOpenAlliance = async (allianceId) => {
        if (!currentUser || !worldId || !userProfile) throw new Error("User or world not identified.");
        if (playerAlliance) throw new Error("You are already in an alliance.");

        const citiesRef = collection(db, `users/${currentUser.uid}/games`, worldId, 'cities');
        const citiesSnap = await getDocs(citiesRef);
        const userCitySlotIds = citiesSnap.docs.map(doc => doc.data().slotId);

        const allianceRef = doc(db, 'worlds', worldId, 'alliances', allianceId);
        const gameRef = doc(db, `users/${currentUser.uid}/games`, worldId);
        const eventsRef = collection(db, 'worlds', worldId, 'alliances', allianceId, 'events');

        await runTransaction(db, async (transaction) => {
            const allianceDoc = await transaction.get(allianceRef);
            if (!allianceDoc.exists()) throw new Error("Alliance not found.");

            const allianceData = allianceDoc.data();
            if (allianceData.banned?.some(b => b.uid === currentUser.uid)) {
                throw new Error("You are banned from this alliance.");
            }
            if (allianceData.settings.status !== 'open') throw new Error("This alliance is not open for joining.");


            const maxMembers = calculateMaxMembers(allianceData);
            if (allianceData.members.length >= maxMembers) {
                throw new Error("This alliance is full.");
            }

            transaction.update(allianceRef, {
                members: arrayUnion({ uid: currentUser.uid, username: userProfile.username, rank: 'Member' })
            });
            transaction.update(gameRef, { alliance: allianceId });

            for (const slotId of userCitySlotIds) {
                const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', slotId);
                transaction.update(citySlotRef, { alliance: allianceId, allianceName: allianceData.name });
            }
            transaction.set(doc(eventsRef), {
                type: 'member_joined',
                text: `${userProfile.username} has joined the alliance.`,
                timestamp: serverTimestamp(),
            });
        });
        clearMemberCache();
    };

    return { createAlliance, updateAllianceSettings, applyToAlliance, leaveAlliance, disbandAlliance, joinOpenAlliance };
};
</file>

<file path="src/hooks/actions/useAllianceBank.js">
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { db } from '../../firebase/config';
import { doc, runTransaction, collection, serverTimestamp, getDocs, query, limit } from "firebase/firestore";
import allianceResearch from '../../gameData/allianceResearch.json';

const calculateBankCapacity = (alliance) => {
    if (!alliance) return 0;
    const baseCapacity = 100000;
    const researchLevel = alliance.research?.reinforced_vaults?.level || 0;
    const researchBonus = allianceResearch.reinforced_vaults.effect.value * researchLevel;
    return baseCapacity + researchBonus;
};

export const useAllianceBankActions = (playerAlliance) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId, activeCityId } = useGame();

    const donateToBank = async (donation) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        if (Object.values(donation).every(v => v === 0)) throw new Error("Donation amount cannot be zero.");

        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', activeCityId);
        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const logRef = doc(collection(allianceDocRef, 'bank_logs'));
        const eventRef = doc(collection(allianceDocRef, 'events'));
        const userBankActivityRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'bankActivity', 'activity');

        await runTransaction(db, async (transaction) => {
            const cityDoc = await transaction.get(cityDocRef);
            const allianceDoc = await transaction.get(allianceDocRef);
            const userActivityDoc = await transaction.get(userBankActivityRef);

            if (!cityDoc.exists() || !allianceDoc.exists()) throw new Error("City or Alliance data not found.");

            const cityData = cityDoc.data();
            const allianceData = allianceDoc.data();
            const bankCapacity = calculateBankCapacity(allianceData);

            const userActivityData = userActivityDoc.exists() ? userActivityDoc.data() : { lastDonation: 0, dailyDonationTotal: 0, lastDonationDate: new Date(0).toISOString().split('T')[0] };
            const now = new Date();
            const today = now.toISOString().split('T')[0];

            const cooldownReductionLevel = allianceData.research?.rapid_donations?.level || 0;
            const donationCooldown = (5 * 60 * 1000) - (cooldownReductionLevel * 15 * 1000);

            if (now.getTime() - (userActivityData.lastDonation || 0) < donationCooldown) {
                const waitTime = Math.ceil((donationCooldown - (now.getTime() - userActivityData.lastDonation)) / 1000);
                throw new Error(`You must wait ${waitTime} seconds between donations.`);
            }

            let dailyTotal = userActivityData.dailyDonationTotal || 0;
            if(userActivityData.lastDonationDate !== today) {
                dailyTotal = 0;
            }

            const limitIncreaseLevel = allianceData.research?.generous_contributions?.level || 0;
            const dailyDonationLimit = 50000 + (limitIncreaseLevel * 10000);

            const totalDonation = Object.values(donation).reduce((a, b) => a + b, 0);
            if (dailyTotal + totalDonation > dailyDonationLimit) {
                throw new Error(`You have reached your daily donation limit of ${dailyDonationLimit.toLocaleString()}. You have ${dailyDonationLimit - dailyTotal} left to donate today.`);
            }

            const newCityResources = { ...cityData.resources };
            const newBank = { ...(allianceData.bank || { wood: 0, stone: 0, silver: 0 }) };

            for (const resource in donation) {
                if ((newCityResources[resource] || 0) < donation[resource]) throw new Error(`Not enough ${resource}.`);
                if ((newBank[resource] || 0) + donation[resource] > bankCapacity) throw new Error(`Bank is full for ${resource}. Capacity: ${bankCapacity.toLocaleString()}`);
                newCityResources[resource] -= donation[resource];
                newBank[resource] = (newBank[resource] || 0) + donation[resource];
            }

            transaction.update(cityDocRef, { resources: newCityResources });
            transaction.update(allianceDocRef, { bank: newBank });
            transaction.set(userBankActivityRef, {
                lastDonation: now.getTime(),
                dailyDonationTotal: dailyTotal + totalDonation,
                lastDonationDate: today
            }, { merge: true });

            transaction.set(logRef, {
                type: 'donation',
                user: userProfile.username,
                resources: donation,
                timestamp: serverTimestamp()
            });

            const donationAmounts = Object.entries(donation).filter(([,a]) => a > 0).map(([r,a]) => `${a.toLocaleString()} ${r}`).join(', ');
            transaction.set(eventRef, {
                type: 'bank_donation',
                text: `${userProfile.username} donated ${donationAmounts} to the bank.`,
                timestamp: serverTimestamp()
            });
        });
    };

    const distributeFromBank = async (targetMemberUid, distribution) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        if (Object.values(distribution).every(v => v === 0)) throw new Error("Distribution amount cannot be zero.");

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const logRef = doc(collection(allianceDocRef, 'bank_logs'));
        const eventRef = doc(collection(allianceDocRef, 'events'));

        const targetCitiesRef = collection(db, `users/${targetMemberUid}/games`, worldId, 'cities');
        const q = query(targetCitiesRef, limit(1));
        const targetCitiesSnap = await getDocs(q);
        if (targetCitiesSnap.empty) throw new Error("Target member has no cities in this world.");
        const targetCityDoc = targetCitiesSnap.docs[0];
        const targetCityRef = targetCityDoc.ref;

        await runTransaction(db, async (transaction) => {
            const allianceDoc = await transaction.get(allianceDocRef);
            const targetCitySnap = await transaction.get(targetCityRef);
            if (!allianceDoc.exists() || !targetCitySnap.exists()) throw new Error("Alliance or target city data not found.");

            const allianceData = allianceDoc.data();
            const targetCityData = targetCitySnap.data();
            const newBank = { ...(allianceData.bank || { wood: 0, stone: 0, silver: 0 }) };
            const newCityResources = { ...targetCityData.resources };

            for (const resource in distribution) {
                if ((newBank[resource] || 0) < distribution[resource]) throw new Error(`Not enough ${resource} in the bank.`);
                newBank[resource] -= distribution[resource];
                newCityResources[resource] = (newCityResources[resource] || 0) + distribution[resource];
            }

            transaction.update(allianceDocRef, { bank: newBank });
            transaction.update(targetCityRef, { resources: newCityResources });

            const targetUsername = allianceData.members.find(m => m.uid === targetMemberUid)?.username || 'Unknown';
            transaction.set(logRef, {
                type: 'distribution',
                from: userProfile.username,
                to: targetUsername,
                resources: distribution,
                timestamp: serverTimestamp()
            });

            const distributionAmounts = Object.entries(distribution).filter(([,a]) => a > 0).map(([r,a]) => `${a.toLocaleString()} ${r}`).join(', ');
            transaction.set(eventRef, {
                type: 'bank_distribution',
                text: `${userProfile.username} distributed ${distributionAmounts} to ${targetUsername}.`,
                timestamp: serverTimestamp()
            });
        });
    };

    const withdrawFromBank = async (withdrawal) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        if (Object.values(withdrawal).every(v => v === 0)) throw new Error("Withdrawal amount cannot be zero.");

        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', activeCityId);
        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const logRef = doc(collection(allianceDocRef, 'bank_logs'));

        await runTransaction(db, async (transaction) => {
            const cityDoc = await transaction.get(cityDocRef);
            const allianceDoc = await transaction.get(allianceDocRef);
            if (!cityDoc.exists() || !allianceDoc.exists()) throw new Error("City or Alliance data not found.");

            const cityData = cityDoc.data();
            const allianceData = allianceDoc.data();
            const newCityResources = { ...cityData.resources };
            const newBank = { ...allianceData.bank };

            for (const resource in withdrawal) {
                if (newBank[resource] < withdrawal[resource]) throw new Error(`Not enough ${resource} in the bank.`);
                newBank[resource] -= withdrawal[resource];
                newCityResources[resource] = (newCityResources[resource] || 0) + withdrawal[resource];
            }

            transaction.update(cityDocRef, { resources: newCityResources });
            transaction.update(allianceDocRef, { bank: newBank });
            transaction.set(logRef, {
                type: 'withdrawal',
                user: userProfile.username,
                resources: withdrawal,
                timestamp: serverTimestamp()
            });
        });
    };

    return { donateToBank, distributeFromBank, withdrawFromBank };
};
</file>

<file path="src/hooks/actions/useAllianceDiplomacy.js">
// src/hooks/actions/useAllianceDiplomacy.js
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { db } from '../../firebase/config';
import { doc, runTransaction, collection, getDocs, query, where, addDoc, updateDoc, serverTimestamp, arrayUnion, arrayRemove, getDoc } from "firebase/firestore";
import { sendSystemMessage } from '../../utils/sendSystemMessage';

export const useAllianceDiplomacyActions = (playerAlliance) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId } = useGame();

    const sendAllyRequest = async (targetAllianceTag) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
        const rank = playerAlliance.ranks.find(r => r.id === member?.rank);
        if (!rank?.permissions?.manageDiplomacy) throw new Error("You don't have permission to do this.");

        const alliancesRef = collection(db, 'worlds', worldId, 'alliances');
        const q = query(alliancesRef, where("tag", "==", targetAllianceTag.toUpperCase()));
        const targetAllianceSnap = await getDocs(q);
        if (targetAllianceSnap.empty) {
            throw new Error("Alliance with that tag not found.");
        }
        const targetAllianceDoc = targetAllianceSnap.docs[0];
        const targetAllianceData = targetAllianceDoc.data();
        const targetAllianceId = targetAllianceDoc.id;

        if (playerAlliance.id === targetAllianceId) {
            throw new Error("You cannot send an ally request to your own alliance.");
        }
        if (playerAlliance.diplomacy?.allies?.some(a => a.id === targetAllianceId)) {
            throw new Error("You are already allied with this alliance.");
        }
        if (playerAlliance.diplomacy?.enemies?.some(e => e.id === targetAllianceId)) {
            throw new Error("You cannot send an ally request to an enemy. Remove them from your enemies first.");
        }

        const targetAllianceRef = doc(db, 'worlds', worldId, 'alliances', targetAllianceId);
        await updateDoc(targetAllianceRef, {
            'diplomacy.requests': arrayUnion({
                id: playerAlliance.id,
                name: playerAlliance.name,
                tag: playerAlliance.tag
            })
        });

        const allianceEventsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'events');
        await addDoc(allianceEventsRef, {
            type: 'diplomacy',
            text: `${userProfile.username} sent an ally request to [${targetAllianceTag}].`,
            timestamp: serverTimestamp(),
        });


        const targetLeaderId = targetAllianceData.leader.uid;
        const targetLeaderUsername = targetAllianceData.leader.username;
        const messageText = `Your alliance has received an ally request from [alliance id=${playerAlliance.id}]${playerAlliance.name}[/alliance]. You can accept or reject it in your alliance's diplomacy tab.`;
        await sendSystemMessage(targetLeaderId, targetLeaderUsername, messageText, worldId);
    };

    const declareEnemy = async (targetAllianceId) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
        const rank = playerAlliance.ranks.find(r => r.id === member?.rank);
        if (!rank?.permissions?.manageDiplomacy) throw new Error("You don't have permission to do this.");

        if (playerAlliance.diplomacy?.allies?.some(a => a.id === targetAllianceId)) {
            throw new Error("You cannot declare an ally as an enemy.");
        }
        if (playerAlliance.diplomacy?.enemies?.some(e => e.id === targetAllianceId)) {
            throw new Error("This alliance is already an enemy.");
        }
        const ownAllianceRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const targetAllianceDoc = await getDoc(doc(db, 'worlds', worldId, 'alliances', targetAllianceId));
        if (!targetAllianceDoc.exists()) {
            throw new Error("Target alliance not found.");
        }
        const targetData = targetAllianceDoc.data();
        await updateDoc(ownAllianceRef, {
            'diplomacy.enemies': arrayUnion({
                id: targetAllianceId,
                name: targetData.name,
                tag: targetData.tag
            })
        });
        const allianceEventsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'events');
        await addDoc(allianceEventsRef, {
            type: 'diplomacy',
            text: `${userProfile.username} declared [${targetAllianceId}] as an enemy.`,
            timestamp: serverTimestamp(),
        });
    };

    const handleDiplomacyResponse = async (targetAllianceId, action) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
        const rank = playerAlliance.ranks.find(r => r.id === member?.rank);
        if (!rank?.permissions?.manageDiplomacy) throw new Error("You don't have permission to do this.");

        const ownAllianceRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const targetAllianceRef = doc(db, 'worlds', worldId, 'alliances', targetAllianceId);

        const ownEventsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'events');
        const targetEventsRef = collection(db, 'worlds', worldId, 'alliances', targetAllianceId, 'events');

        await runTransaction(db, async (transaction) => {
            const ownAllianceDoc = await transaction.get(ownAllianceRef);
            const targetAllianceDoc = await transaction.get(targetAllianceRef);

            if (!ownAllianceDoc.exists()) throw new Error("Your alliance data not found.");
            if (!targetAllianceDoc.exists()) throw new Error("Target alliance not found.");

            const ownData = ownAllianceDoc.data();
            const targetData = targetAllianceDoc.data();

            const targetInfo = { id: targetAllianceId, name: targetData.name, tag: targetData.tag };
            const ownInfo = { id: playerAlliance.id, name: ownData.name, tag: ownData.tag };

            const ownDiplomacy = ownData.diplomacy || { allies: [], enemies: [], requests: [] };
            const targetDiplomacy = targetData.diplomacy || { allies: [], enemies: [], requests: [] };

            switch(action) {
                case 'accept':
                    if (ownDiplomacy.enemies?.some(e => e.id === targetAllianceId)) {
                        throw new Error("You cannot ally with an enemy. Remove them from your enemies list first.");
                    }
                    transaction.update(ownAllianceRef, { 'diplomacy.requests': arrayRemove(targetInfo), 'diplomacy.allies': arrayUnion(targetInfo) });
                    transaction.update(targetAllianceRef, { 'diplomacy.allies': arrayUnion(ownInfo) });
                    addDoc(ownEventsRef, { type: 'diplomacy', text: `${userProfile.username} accepted the ally request from [${targetInfo.tag}].`, timestamp: serverTimestamp() });
                    addDoc(targetEventsRef, { type: 'diplomacy', text: `[${ownInfo.tag}] has accepted your ally request.`, timestamp: serverTimestamp() });
                    break;
                case 'reject':
                    transaction.update(ownAllianceRef, { 'diplomacy.requests': arrayRemove(targetInfo) });
                    addDoc(ownEventsRef, { type: 'diplomacy', text: `${userProfile.username} rejected the ally request from [${targetInfo.tag}].`, timestamp: serverTimestamp() });
                    break;
                case 'removeAlly':
                    const allyInOwnList = ownDiplomacy.allies.find(a => a.id === targetAllianceId);
                    const allyInTargetList = targetDiplomacy.allies.find(a => a.id === playerAlliance.id);

                    if (allyInOwnList) {
                        transaction.update(ownAllianceRef, { 'diplomacy.allies': arrayRemove(allyInOwnList) });
                    }
                    if (allyInTargetList) {
                        transaction.update(targetAllianceRef, { 'diplomacy.allies': arrayRemove(allyInTargetList) });
                    }

                    addDoc(ownEventsRef, { type: 'diplomacy', text: `${userProfile.username} terminated the alliance with [${targetInfo.tag}].`, timestamp: serverTimestamp() });
                    addDoc(targetEventsRef, { type: 'diplomacy', text: `The alliance with [${ownInfo.tag}] has been terminated.`, timestamp: serverTimestamp() });
                    break;
                case 'removeEnemy':
                    const enemyInOwnList = ownDiplomacy.enemies.find(e => e.id === targetAllianceId);
                    if (enemyInOwnList) {
                        transaction.update(ownAllianceRef, { 'diplomacy.enemies': arrayRemove(enemyInOwnList) });
                    }
                    addDoc(ownEventsRef, { type: 'diplomacy', text: `${userProfile.username} removed [${targetInfo.tag}] from the enemies list.`, timestamp: serverTimestamp() });
                    break;
                default:
                    throw new Error("Invalid diplomacy action.");
            }
        });
    };

    const proposeTreaty = async (targetAllianceTag, treatyDetails) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
        const rank = playerAlliance.ranks.find(r => r.id === member?.rank);
        if (!rank?.permissions?.proposeTreaties) throw new Error("You don't have permission to do this.");

        const alliancesRef = collection(db, 'worlds', worldId, 'alliances');
        const q = query(alliancesRef, where("tag", "==", targetAllianceTag.toUpperCase()));
        const targetAllianceSnap = await getDocs(q);
        if (targetAllianceSnap.empty) throw new Error("Alliance with that tag not found.");
        const targetAlliance = { id: targetAllianceSnap.docs[0].id, ...targetAllianceSnap.docs[0].data() };
        const targetLeaderId = targetAlliance.leader.uid;
        const targetLeaderUsername = targetAlliance.leader.username;

        const treatyMessage = `Alliance ${playerAlliance.name} [${playerAlliance.tag}] has proposed a treaty to you.\n\nDetails:\n${treatyDetails.message}\n\n[action=view_treaty,treatyId=TEMP]View Treaty[/action]`;

        await sendSystemMessage(targetLeaderId, targetLeaderUsername, treatyMessage, worldId);

        const eventsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'events');
        await addDoc(eventsRef, {
            type: 'treaty_proposed',
            text: `${userProfile.username} proposed a treaty to [${targetAllianceTag}].`,
            timestamp: serverTimestamp(),
        });
    };

    return { sendAllyRequest, declareEnemy, handleDiplomacyResponse, proposeTreaty };
};
</file>

<file path="src/hooks/actions/useAllianceManagement.js">
// src/hooks/actions/useAllianceManagement.js
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { db } from '../../firebase/config';
import { doc, runTransaction, collection, getDocs, query, where, addDoc, updateDoc, serverTimestamp, arrayUnion, arrayRemove, deleteDoc, getDoc } from "firebase/firestore";
import { sendSystemMessage } from '../../utils/sendSystemMessage';
import allianceResearch from '../../gameData/allianceResearch.json';
import { clearMemberCache } from '../../components/alliance/AllianceMembers';

const calculateMaxMembers = (alliance) => {
    const baseMax = 20;
    const researchLevel = alliance.research?.expanded_charter?.level || 0;
    const researchBonus = allianceResearch.expanded_charter.effect.value * researchLevel;
    return baseMax + researchBonus;
};

export const useAllianceManagementActions = (playerAlliance) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId } = useGame();

    const sendAllianceInvitation = async (targetUserId) => {
        if (!playerAlliance) {
            throw new Error("You do not have permission to send invitations.");
        }
        const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
        const rank = playerAlliance.ranks.find(r => r.id === member?.rank);
        if (!rank?.permissions?.inviteMembers) {
            throw new Error("You do not have permission to send invitations.");
        }
        if (!targetUserId) {
            throw new Error("Target user ID is not specified.");
        }

        try {
            const targetUserDoc = await getDoc(doc(db, 'users', targetUserId));
            if (!targetUserDoc.exists()) {
                throw new Error("Target user not found.");
            }
            const targetUsername = targetUserDoc.data().username;


            const invitesRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'invitations');
            await addDoc(invitesRef, {
                invitedUserId: targetUserId,
                invitedUsername: targetUsername,
                sentAt: serverTimestamp(),
                sentBy: userProfile.username
            });


            const allianceEventsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'events');
            await addDoc(allianceEventsRef, {
                type: 'invitation_sent',
                text: `${userProfile.username} invited ${targetUsername} to the alliance.`,
                timestamp: serverTimestamp(),
            });


            const messageText = `You have been invited to join the alliance "${playerAlliance.name}".\n\n[action=accept_invite,allianceId=${playerAlliance.id}]Accept Invitation[/action]\n[action=decline_invite,allianceId=${playerAlliance.id}]Decline Invitation[/action]`;
            await sendSystemMessage(targetUserId, targetUsername, messageText, worldId);

        } catch (error) {
            console.error("Error sending invitation:", error);

            throw error;
        }
    };

    const revokeAllianceInvitation = async (invitedUserId) => {
        if (!playerAlliance) return;
        const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
        const rank = playerAlliance.ranks.find(r => r.id === member?.rank);
        if (!rank?.permissions?.inviteMembers) return;

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const invitesRef = collection(allianceDocRef, 'invitations');
        const q = query(invitesRef, where('invitedUserId', '==', invitedUserId));

        try {
            const snapshot = await getDocs(q);
            if (!snapshot.empty) {
                const inviteDoc = snapshot.docs[0];
                const inviteData = inviteDoc.data();
                const invitedUsername = inviteData.invitedUsername || 'a player';


                const allianceEventsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'events');
                await addDoc(allianceEventsRef, {
                    type: 'invitation_revoked',
                    text: `${userProfile.username} has revoked the invitation for ${invitedUsername}.`,
                    timestamp: serverTimestamp(),
                });


                await deleteDoc(inviteDoc.ref);
            }
        } catch (error) {
            console.error("Error revoking invitation:", error);
            throw error;
        }
    };

    const declineAllianceInvitation = async (allianceId) => {
        if (!currentUser || !worldId) throw new Error("User or world not identified.");

        const invitesRef = collection(db, 'worlds', worldId, 'alliances', allianceId, 'invitations');
        const q = query(invitesRef, where('invitedUserId', '==', currentUser.uid));
        const snapshot = await getDocs(q);

        if (snapshot.empty) {
            throw new Error("Invitation not found. It may have been revoked or already handled.");
        }

        const inviteDocRef = snapshot.docs[0].ref;
        await deleteDoc(inviteDocRef);
    };

    const acceptAllianceInvitation = async (allianceId) => {
        if (!currentUser || !worldId) return;

        const citiesRef = collection(db, `users/${currentUser.uid}/games`, worldId, 'cities');
        const citiesSnap = await getDocs(citiesRef);
        const userCitySlotIds = citiesSnap.docs.map(doc => doc.data().slotId);

        const newAllianceDocRef = doc(db, 'worlds', worldId, 'alliances', allianceId);
        const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);

        const invitesRef = collection(db, 'worlds', worldId, 'alliances', allianceId, 'invitations');
        const q = query(invitesRef, where('invitedUserId', '==', currentUser.uid));
        const snapshot = await getDocs(q);

        if (snapshot.empty) {
            throw new Error("Invitation not found. It may have been revoked or already handled.");
        }
        const inviteDocRef = snapshot.docs[0].ref;

        try {
            await runTransaction(db, async (transaction) => {
                const inviteDoc = await transaction.get(inviteDocRef);
                if (!inviteDoc.exists()) {
                    throw new Error("Invitation was handled by another action.");
                }

                const newAllianceDoc = await transaction.get(newAllianceDocRef);
                const gameDoc = await transaction.get(gameDocRef);

                if (!newAllianceDoc.exists()) throw new Error("Alliance no longer exists.");
                if (!gameDoc.exists()) throw new Error("Your game data was not found.");

                const newAllianceData = newAllianceDoc.data();
                if (newAllianceData.banned?.some(b => b.uid === currentUser.uid)) {
                    transaction.delete(inviteDocRef);
                    throw new Error("You are banned from this alliance.");
                }
                const gameData = gameDoc.data();
                const oldAllianceId = gameData.alliance;

                if (oldAllianceId === allianceId) throw new Error("You are already in this alliance.");

                const maxMembers = calculateMaxMembers(newAllianceData);
                if (newAllianceData.members.length >= maxMembers) {
                    throw new Error("This alliance is full.");
                }

                if (oldAllianceId) {
                    const oldAllianceDocRef = doc(db, 'worlds', worldId, 'alliances', oldAllianceId);
                    const oldAllianceDoc = await transaction.get(oldAllianceDocRef);
                    if (oldAllianceDoc.exists()) {
                        const oldAllianceData = oldAllianceDoc.data();
                        const updatedMembers = oldAllianceData.members.filter(m => m.uid !== currentUser.uid);
                        transaction.update(oldAllianceDocRef, { members: updatedMembers });

                        const oldAllianceEventsRef = doc(collection(db, 'worlds', worldId, 'alliances', oldAllianceId, 'events'));
                        transaction.set(oldAllianceEventsRef, {
                            type: 'member_left',
                            text: `${userProfile.username} has left the alliance to join ${newAllianceData.name}.`,
                            timestamp: serverTimestamp(),
                        });
                    }
                }

                const newMembers = [...newAllianceData.members, { uid: currentUser.uid, username: userProfile.username, rank: 'Member' }];
                transaction.update(newAllianceDocRef, { members: newMembers });
                transaction.update(gameDocRef, { alliance: allianceId });

                const newAllianceEventsRef = doc(collection(db, 'worlds', worldId, 'alliances', allianceId, 'events'));
                transaction.set(newAllianceEventsRef, {
                    type: 'member_joined',
                    text: `${userProfile.username} has joined the alliance.`,
                    timestamp: serverTimestamp(),
                });

                for (const slotId of userCitySlotIds) {
                    const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', slotId);
                    transaction.update(citySlotRef, { alliance: allianceId, allianceName: newAllianceData.name });
                }

                transaction.delete(inviteDocRef);
            });
            clearMemberCache();
        } catch (error) {
            console.error("Error accepting invitation:", error);
            alert(`Failed to join alliance: ${error.message}`);
        }
    };

    const handleApplication = async (application, allianceId, action) => {
        if (!playerAlliance) throw new Error("You don't have permission to do this.");
        const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
        const rank = playerAlliance.ranks.find(r => r.id === member?.rank);
        if (!rank?.permissions?.inviteMembers) {
            throw new Error("You don't have permission to do this.");
        }

        const allianceRef = doc(db, 'worlds', worldId, 'alliances', allianceId);
        const applicantGameRef = doc(db, `users/${application.userId}/games`, worldId);

        const citiesRef = collection(db, `users/${application.userId}/games`, worldId, 'cities');
        const citiesSnap = await getDocs(citiesRef);
        const userCitySlotIds = citiesSnap.docs.map(doc => doc.data().slotId);

        await runTransaction(db, async (transaction) => {
            const allianceDoc = await transaction.get(allianceRef);
            const applicantGameDoc = await transaction.get(applicantGameRef);

            if (!allianceDoc.exists()) throw new Error("Alliance data not found.");

            const allianceData = allianceDoc.data();

            const appToRemove = allianceData.applications?.find(app => app.userId === application.userId);
            if (appToRemove) {
                transaction.update(allianceRef, { applications: arrayRemove(appToRemove) });
            } else {
                return;
            }

            if (action === 'accept') {
                if (allianceData.banned?.some(b => b.uid === application.userId)) {
                    throw new Error("This player is banned from your alliance.");
                }
                if (!applicantGameDoc.exists()) throw new Error("Applicant's game data not found.");
                const applicantGameData = applicantGameDoc.data();
                if (applicantGameData.alliance) {
                    throw new Error("This player has already joined another alliance.");
                }

                const maxMembers = calculateMaxMembers(allianceData);
                if (allianceData.members.length >= maxMembers) {
                    throw new Error("This alliance is full and cannot accept new members.");
                }

                transaction.update(allianceRef, {
                    members: arrayUnion({ uid: application.userId, username: application.username, rank: 'Member' })
                });
                transaction.update(applicantGameRef, { alliance: allianceId });

                for (const slotId of userCitySlotIds) {
                    const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', slotId);
                    transaction.update(citySlotRef, { alliance: allianceId, allianceName: allianceData.name });
                }
            }
        });

        if (action === 'accept') {
            clearMemberCache();
        }
    };

    const kickAllianceMember = async (memberId) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        const memberToKick = playerAlliance.members.find(m => m.uid === memberId);
        if (!memberToKick) throw new Error("Member not found.");

        if (memberId === currentUser.uid) throw new Error("You cannot kick yourself.");
        if (memberId === playerAlliance.leader.uid) throw new Error("You cannot kick the leader.");

        const allianceRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const gameRef = doc(db, `users/${memberId}/games`, worldId);
        const citiesRef = collection(db, `users/${memberId}/games`, worldId, 'cities');
        const citiesSnap = await getDocs(citiesRef);
        const userCitySlotIds = citiesSnap.docs.map(doc => doc.data().slotId);

        await runTransaction(db, async (transaction) => {
            transaction.update(allianceRef, { members: arrayRemove(memberToKick) });
            transaction.update(gameRef, { alliance: null });
            for (const slotId of userCitySlotIds) {
                const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', slotId);
                transaction.update(citySlotRef, { alliance: null, allianceName: null });
            }
        });

        const allianceEventsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'events');
        await addDoc(allianceEventsRef, {
            type: 'member_kicked',
            text: `${userProfile.username} has kicked ${memberToKick.username} from the alliance.`,
            timestamp: serverTimestamp(),
        });

        const messageText = `You have been kicked from the alliance "${playerAlliance.name}" by ${userProfile.username}.`;
        await sendSystemMessage(memberId, memberToKick.username, messageText, worldId);

        clearMemberCache();
    };

    const banAllianceMember = async (memberId) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        const memberToBan = playerAlliance.members.find(m => m.uid === memberId);
        if (!memberToBan) throw new Error("Member not found.");

        if (memberId === currentUser.uid) throw new Error("You cannot ban yourself.");
        if (memberId === playerAlliance.leader.uid) throw new Error("You cannot ban the leader.");

        const allianceRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const gameRef = doc(db, `users/${memberId}/games`, worldId);
        const citiesRef = collection(db, `users/${memberId}/games`, worldId, 'cities');
        const citiesSnap = await getDocs(citiesRef);
        const userCitySlotIds = citiesSnap.docs.map(doc => doc.data().slotId);

        await runTransaction(db, async (transaction) => {
            transaction.update(allianceRef, {
                members: arrayRemove(memberToBan),
                banned: arrayUnion({ uid: memberToBan.uid, username: memberToBan.username })
            });
            transaction.update(gameRef, { alliance: null });
            for (const slotId of userCitySlotIds) {
                const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', slotId);
                transaction.update(citySlotRef, { alliance: null, allianceName: null });
            }
        });

        const allianceEventsRef = collection(db, 'worlds', worldId, 'alliances', playerAlliance.id, 'events');
        await addDoc(allianceEventsRef, {
            type: 'member_banned',
            text: `${userProfile.username} has banned ${memberToBan.username} from the alliance.`,
            timestamp: serverTimestamp(),
        });

        const messageText = `You have been banned from the alliance "${playerAlliance.name}" by ${userProfile.username}.`;
        await sendSystemMessage(memberId, memberToBan.username, messageText, worldId);

        clearMemberCache();
    };


    const createAllianceRank = async (rank) => {
        if (!playerAlliance || playerAlliance.leader.uid !== currentUser.uid) return;

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const newRanks = [...playerAlliance.ranks, rank];
        await updateDoc(allianceDocRef, { ranks: newRanks });
    };

    const updateAllianceMemberRank = async (memberId, newRankId) => {
        if (!playerAlliance || playerAlliance.leader.uid !== currentUser.uid) return;

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const updatedMembers = playerAlliance.members.map(member =>
            member.uid === memberId ? { ...member, rank: newRankId } : member
        );
        await updateDoc(allianceDocRef, { members: updatedMembers });
    };

    const updateRanksOrder = async (newRanks) => {
        if (!playerAlliance || playerAlliance.leader.uid !== currentUser.uid) {
            throw new Error("You don't have permission to do this.");
        }
        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        await updateDoc(allianceDocRef, { ranks: newRanks });
    };

    const updateAllianceRank = async (rankId, updatedRankData) => {
        if (!playerAlliance || playerAlliance.leader.uid !== currentUser.uid) {
            throw new Error("You don't have permission to do this.");
        }
        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);

        const newRanks = playerAlliance.ranks.map(rank =>
            rank.id === rankId ? { ...rank, ...updatedRankData, id: updatedRankData.name, name: updatedRankData.name } : rank
        );

        const updatedMembers = playerAlliance.members.map(member =>
            member.rank === rankId ? { ...member, rank: updatedRankData.name } : member
        );

        await updateDoc(allianceDocRef, { ranks: newRanks, members: updatedMembers });
    };

    const deleteAllianceRank = async (rankId) => {
        if (!playerAlliance || playerAlliance.leader.uid !== currentUser.uid) {
            throw new Error("You don't have permission to do this.");
        }
        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);

        if (playerAlliance.members.some(m => m.rank === rankId)) {
            throw new Error("Cannot delete rank as it is still assigned to members.");
        }

        const newRanks = playerAlliance.ranks.filter(rank => rank.id !== rankId);

        await updateDoc(allianceDocRef, { ranks: newRanks });
    };

    return { sendAllianceInvitation, revokeAllianceInvitation, acceptAllianceInvitation, declineAllianceInvitation, handleApplication, kickAllianceMember, banAllianceMember, createAllianceRank, updateAllianceMemberRank, updateRanksOrder, updateAllianceRank, deleteAllianceRank };
};
</file>

<file path="src/hooks/actions/useAllianceResearch.js">
// src/hooks/actions/useAllianceResearch.js
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { db } from '../../firebase/config';
import { doc, runTransaction, collection,serverTimestamp} from "firebase/firestore";
import allianceResearch from '../../gameData/allianceResearch.json';

export const useAllianceResearchActions = (playerAlliance) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId, gameState } = useGame();

    const donateToAllianceResearch = async (researchId, donation) => {
        if (!playerAlliance) {
            alert("You are not in an alliance.");
            return;
        }


        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', gameState.id);
        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const eventsRef = collection(allianceDocRef, 'events');

        try {
            await runTransaction(db, async (transaction) => {
                const cityDoc = await transaction.get(cityDocRef);
                const allianceDoc = await transaction.get(allianceDocRef);

                if (!cityDoc.exists() || !allianceDoc.exists()) {
                    throw new Error("City or Alliance data not found.");
                }

                const cityData = cityDoc.data();
                const allianceData = allianceDoc.data();

                for (const resource in donation) {
                    if ((cityData.resources[resource] || 0) < donation[resource]) {
                        throw new Error(`Not enough ${resource}.`);
                    }
                }

                const researchInfo = allianceResearch[researchId];
                const research = allianceData.research[researchId] || { level: 0, progress: { wood: 0, stone: 0, silver: 0 }};
                const newPlayerResources = { ...cityData.resources };
                const newResearchProgress = { ...research.progress };

                for (const resource in donation) {
                    newPlayerResources[resource] -= donation[resource];
                    newResearchProgress[resource] = (newResearchProgress[resource] || 0) + donation[resource];
                }

                transaction.update(cityDocRef, { resources: newPlayerResources });
                
                const cost = {
                    wood: Math.floor(researchInfo.baseCost.wood * Math.pow(researchInfo.costMultiplier, research.level)),
                    stone: Math.floor(researchInfo.baseCost.stone * Math.pow(researchInfo.costMultiplier, research.level)),
                    silver: Math.floor(researchInfo.baseCost.silver * Math.pow(researchInfo.costMultiplier, research.level)),
                };

                if (newResearchProgress.wood >= cost.wood && newResearchProgress.stone >= cost.stone && newResearchProgress.silver >= cost.silver) {
                    const newLevel = research.level + 1;
                    const remainingProgress = {
                        wood: newResearchProgress.wood - cost.wood,
                        stone: newResearchProgress.stone - cost.stone,
                        silver: newResearchProgress.silver - cost.silver,
                    };
                    transaction.update(allianceDocRef, { 
                        [`research.${researchId}`]: { level: newLevel, progress: remainingProgress }
                    });
                    transaction.set(doc(eventsRef), {
                        type: 'research_completed',
                        text: `The alliance has completed ${researchInfo.name} Level ${newLevel}!`,
                        timestamp: serverTimestamp(),
                    });
                } else {
                    transaction.update(allianceDocRef, { [`research.${researchId}.progress`]: newResearchProgress });
                }
            });
            alert("Donation successful!");
        } catch (error) {
            alert(`Donation failed: ${error.message}`);
            console.error("Donation error:", error);
        }
    };

    const recommendAllianceResearch = async (researchId) => {
        if (!playerAlliance || !currentUser || !userProfile) return;

        const member = playerAlliance.members.find(m => m.uid === currentUser.uid);
        if (!member) throw new Error("You are not a member of this alliance.");

        const rank = playerAlliance.ranks.find(r => r.id === member.rank);
        if (!rank || !rank.permissions.recommendResearch) {
            throw new Error("You do not have permission to recommend research.");
        }

        const allianceRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const eventsRef = collection(allianceRef, 'events');

        try {
            await runTransaction(db, async (transaction) => {
                transaction.update(allianceRef, { recommendedResearch: researchId });
                const researchName = allianceResearch[researchId]?.name || 'a research';
                transaction.set(doc(eventsRef), {
                    type: 'research_recommendation',
                    text: `${userProfile.username} has recommended focusing on ${researchName}.`,
                    timestamp: serverTimestamp(),
                });
            });
        } catch (error) {
            console.error("Error recommending research:", error);
            throw error;
        }
    };

    return { donateToAllianceResearch, recommendAllianceResearch };
};
</file>

<file path="src/hooks/actions/useAllianceWonderActions.js">
// src/hooks/actions/useAllianceWonderActions.js
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { db } from '../../firebase/config';
import { doc, runTransaction, collection, serverTimestamp } from "firebase/firestore";
import allianceWonders from '../../gameData/alliance_wonders.json';

// #comment Calculate the total cost to build a wonder level
const getWonderCost = (level) => {
    const costMultiplier = Math.pow(1.5, level);
    return {
        wood: Math.floor(100000 * costMultiplier),
        stone: Math.floor(100000 * costMultiplier),
        silver: Math.floor(50000 * costMultiplier)
    };
};

// #comment Get the current progress of the wonder
export const getWonderProgress = (alliance, wonderId) => {
    const progress = alliance?.wonderProgress?.[wonderId] || { wood: 0, stone: 0, silver: 0 };
    return progress;
};

// #comment This hook contains actions related to alliance wonders.
export const useAllianceWonderActions = (playerAlliance) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId, gameState } = useGame();

    const startWonder = async (wonderId, islandId, coords) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        if (playerAlliance.leader.uid !== currentUser.uid) throw new Error("Only the leader can start a wonder.");
        if (playerAlliance.allianceWonder) throw new Error("Your alliance is already building a wonder.");

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', gameState.id);
        const eventRef = doc(collection(allianceDocRef, 'events'));
        const startCost = { wood: 50000, stone: 50000, silver: 25000 };

        await runTransaction(db, async (transaction) => {
            const cityDoc = await transaction.get(cityDocRef);
            if (!cityDoc.exists()) throw new Error("Your city data was not found.");
            const cityData = cityDoc.data();

            for (const resource in startCost) {
                if ((cityData.resources[resource] || 0) < startCost[resource]) {
                    throw new Error(`You do not have enough ${resource} to start the wonder.`);
                }
            }

            const newPlayerResources = { ...cityData.resources };
            for (const resource in startCost) {
                newPlayerResources[resource] -= startCost[resource];
            }

            transaction.update(cityDocRef, { resources: newPlayerResources });

            transaction.update(allianceDocRef, {
                allianceWonder: { id: wonderId, level: 0, islandId, x: coords.x, y: coords.y },
                wonderProgress: { [wonderId]: { wood: 0, stone: 0, silver: 0 } }
            });

            const eventText = `${userProfile.username} has started construction of the ${allianceWonders[wonderId].name}.`;
            transaction.set(eventRef, {
                type: 'wonder_start',
                text: eventText,
                timestamp: serverTimestamp()
            });
        });
    };

    const donateToWonder = async (wonderId, donation) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', gameState.id);
        const eventRef = doc(collection(allianceDocRef, 'events'));

        await runTransaction(db, async (transaction) => {
            const cityDoc = await transaction.get(cityDocRef);
            const allianceDoc = await transaction.get(allianceDocRef);
            if (!cityDoc.exists() || !allianceDoc.exists()) throw new Error("City or Alliance data not found.");

            const cityData = cityDoc.data();
            const allianceData = allianceDoc.data();
            
            const currentWonder = allianceData.allianceWonder;
            if (!currentWonder || currentWonder.id !== wonderId) throw new Error("Cannot donate to this wonder, as it is not the active wonder.");

            const newPlayerResources = { ...cityData.resources };
            const newWonderProgress = { ...(allianceData.wonderProgress?.[wonderId] || { wood: 0, stone: 0, silver: 0 }) };

            for (const resource in donation) {
                if ((newPlayerResources[resource] || 0) < donation[resource]) throw new Error(`Not enough ${resource} in your city.`);
                newPlayerResources[resource] -= donation[resource];
                newWonderProgress[resource] += donation[resource];
            }

            transaction.update(cityDocRef, { resources: newPlayerResources });
            transaction.update(allianceDocRef, { [`wonderProgress.${wonderId}`]: newWonderProgress });

            const donationAmounts = Object.entries(donation).filter(([,a]) => a > 0).map(([r,a]) => `${a.toLocaleString()} ${r}`).join(', ');
            if (donationAmounts) {
                transaction.set(eventRef, {
                    type: 'wonder_donation',
                    text: `${userProfile.username} donated ${donationAmounts} to the wonder.`,
                    timestamp: serverTimestamp()
                });
            }
        });
    };

    const claimWonderLevel = async (wonderId) => {
        if (!playerAlliance) throw new Error("You are not in an alliance.");
        if (playerAlliance.leader.uid !== currentUser.uid) throw new Error("Only the leader can claim wonder levels.");

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);

        await runTransaction(db, async (transaction) => {
            const allianceDoc = await transaction.get(allianceDocRef);
            if (!allianceDoc.exists()) throw new Error("Alliance data not found.");

            const allianceData = allianceDoc.data();
            const currentWonder = allianceData.allianceWonder;
            const progress = allianceData.wonderProgress[wonderId] || { wood: 0, stone: 0, silver: 0 };
            const nextLevel = currentWonder.level + 1;
            const cost = getWonderCost(nextLevel -1);

            if (progress.wood < cost.wood || progress.stone < cost.stone || progress.silver < cost.silver) {
                throw new Error("Not enough resources have been donated to claim this level.");
            }

            const newProgress = {
                wood: progress.wood - cost.wood,
                stone: progress.stone - cost.stone,
                silver: progress.silver - cost.silver,
            };

            transaction.update(allianceDocRef, {
                allianceWonder: { ...currentWonder, level: nextLevel },
                [`wonderProgress.${wonderId}`]: newProgress
            });
        });
    };

    const demolishWonder = async () => {
         if (!playerAlliance) throw new Error("You are not in an alliance.");
         if (playerAlliance.leader.uid !== currentUser.uid) throw new Error("Only the leader can demolish the wonder.");

        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);
        await runTransaction(db, async (transaction) => {
            const allianceDoc = await transaction.get(allianceDocRef);
            if (!allianceDoc.exists()) throw new Error("Alliance data not found.");

            transaction.update(allianceDocRef, { allianceWonder: null, wonderProgress: {} });
        });
    };

    return { startWonder, donateToWonder, claimWonderLevel, demolishWonder };
};
</file>

<file path="src/hooks/actions/useBuildingActions.js">
import { v4 as uuidv4 } from 'uuid';
import buildingConfig from '../../gameData/buildings.json';

// #comment This hook provides actions related to building management in a city.
export const useBuildingActions = ({
    cityGameState, setCityGameState, saveGameState, worldId,
    getUpgradeCost, getFarmCapacity, calculateUsedPopulation, isInstantBuild,
    setMessage, closeModal
}) => {
    // #comment Handles the logic for upgrading or constructing a building.
    const handleUpgrade = async (buildingId) => {
        const currentState = cityGameState;
        if (!currentState || !worldId) return;

        const currentQueue = currentState.buildQueue || [];
        if (currentQueue.length >= 5) {
            setMessage("Build queue is full (max 5).");
            return;
        }

        const building = currentState.buildings[buildingId] || { level: 0 };
        let effectiveCurrentLevel = building.level;
        currentQueue.forEach(task => {
            if (task.buildingId === buildingId && task.type !== 'demolish' && task.level > effectiveCurrentLevel) {
                effectiveCurrentLevel = task.level;
            }
        });

        const nextLevelToQueue = effectiveCurrentLevel + 1;
        const config = buildingConfig[buildingId];
        if (config && nextLevelToQueue > config.maxLevel) {
            setMessage("Building is already at its maximum level or queued to be.");
            return;
        }

        // #comment Check all building and research requirements, including those in the queue.
        const requirements = config.requirements;
        if (requirements) {
            const unmetRequirements = [];
            for (const reqBuildingId in requirements) {
                const requiredLevel = requirements[reqBuildingId];
                
                let finalQueuedLevel = currentState.buildings[reqBuildingId]?.level || 0;
                currentQueue.forEach(task => {
                    if (task.buildingId === reqBuildingId && task.type !== 'demolish' && task.level > finalQueuedLevel) {
                        finalQueuedLevel = task.level;
                    }
                });

                if (finalQueuedLevel < requiredLevel) {
                    unmetRequirements.push(`${buildingConfig[reqBuildingId].name} Level ${requiredLevel}`);
                }
            }

            if (unmetRequirements.length > 0) {
                // #comment Join with newline characters for multi-line display in the modal.
                setMessage(`Requires:\n${unmetRequirements.join('\n')}`);
                return;
            }
        }

        const cost = getUpgradeCost(buildingId, nextLevelToQueue);
        const hasEnoughResources = currentState.resources.wood >= cost.wood &&
                                   currentState.resources.stone >= cost.stone &&
                                   currentState.resources.silver >= cost.silver;

        if (!hasEnoughResources) {
            setMessage('Not enough resources to upgrade!');
            return;
        }

        let populationInQueue = 0;
        currentQueue.forEach(task => {
            if (task.type !== 'demolish') {
                const taskCost = getUpgradeCost(task.buildingId, task.level);
                populationInQueue += taskCost.population;
            }
        });

        const currentUsedPopulation = calculateUsedPopulation(currentState);
        const maxPopulation = getFarmCapacity(currentState.buildings.farm.level);
        const newTotalPopulation = currentUsedPopulation + populationInQueue + cost.population;
        const hasEnoughPopulation = newTotalPopulation <= maxPopulation;

        if (!hasEnoughPopulation && buildingId !== 'farm' && buildingId !== 'warehouse') {
            setMessage('Not enough population capacity!');
            return;
        }

        const newGameState = JSON.parse(JSON.stringify(currentState));
        newGameState.resources.wood -= cost.wood;
        newGameState.resources.stone -= cost.stone;
        newGameState.resources.silver -= cost.silver;

        if (buildingId === 'academy') {
            newGameState.researchPoints = (newGameState.researchPoints || 0) + 4;
        }

        let lastEndTime = Date.now();
        if (currentQueue.length > 0) {
            const lastQueueItem = currentQueue[currentQueue.length - 1];
            if (lastQueueItem.endTime) {
                lastEndTime = lastQueueItem.endTime.toDate
                    ? lastQueueItem.endTime.toDate().getTime()
                    : new Date(lastQueueItem.endTime).getTime();
            }
        }

        const endTime = new Date(lastEndTime + cost.time * 1000);

        const newQueueItem = {
            id: uuidv4(),
            buildingId,
            level: nextLevelToQueue,
            endTime: endTime,
        };
        newGameState.buildQueue = [...currentQueue, newQueueItem];

        try {
            await saveGameState(newGameState);
            setCityGameState(newGameState);
        }
        catch (error) {
            console.error("Error adding to build queue:", error);
            setMessage("Could not start upgrade. Please try again.");
        }
    };

    const handleCancelBuild = async (itemToCancel) => {
        console.log(`[handleCancelBuild] Triggered at ${new Date().toLocaleTimeString()} for item:`, JSON.parse(JSON.stringify(itemToCancel)));
        const currentState = cityGameState;
        if (!currentState || !currentState.buildQueue) {
            return;
        }

        const itemIndex = currentState.buildQueue.findIndex(item => item.id === itemToCancel.id);
        if (itemIndex === -1) {
            console.error("Could not find item to cancel in build queue.");
            return;
        }

        if (itemIndex !== currentState.buildQueue.length - 1) {
            setMessage("You can only cancel the last item in the queue.");
            return;
        }

        const newQueue = [...currentState.buildQueue];
        const canceledTask = newQueue.splice(itemIndex, 1)[0];
        const newGameState = { ...currentState, buildQueue: newQueue };

        if (canceledTask.type !== 'demolish') {
            let cost;
            if (canceledTask.isSpecial) {
                cost = { wood: 15000, stone: 15000, silver: 15000, population: 60 };
            } else {
                cost = getUpgradeCost(canceledTask.buildingId, canceledTask.level);
            }
            newGameState.resources = {
                ...currentState.resources,
                wood: currentState.resources.wood + Math.floor(cost.wood * 0.5),
                stone: currentState.resources.stone + Math.floor(cost.stone * 0.5),
                silver: currentState.resources.silver + Math.floor(cost.silver * 0.5),
            };
            if (canceledTask.buildingId === 'academy' && !canceledTask.isSpecial) {
                newGameState.researchPoints = (newGameState.researchPoints || 0) - 4;
            }
        }

        for (let i = itemIndex; i < newQueue.length; i++) {
            const previousTaskEndTime = (i === 0)
                ? Date.now()
                : (newQueue[i - 1]?.endTime ? new Date(newQueue[i - 1].endTime).getTime() : Date.now());

            const taskToUpdate = newQueue[i];
            let taskTime;
            if (taskToUpdate.isSpecial) {
                taskTime = 7200; 
            } else if (taskToUpdate.type === 'demolish') {
                const costConfig = buildingConfig[taskToUpdate.buildingId].baseCost;
                const calculatedTime = Math.floor(costConfig.time * Math.pow(1.25, taskToUpdate.currentLevel - 1));
                taskTime = isInstantBuild ? 1 : Math.floor(calculatedTime / 2);
            }
            else {
                taskTime = getUpgradeCost(taskToUpdate.buildingId, taskToUpdate.level).time;
            }
            const newEndTime = new Date(previousTaskEndTime + taskTime * 1000);
            newQueue[i] = { ...taskToUpdate, endTime: newEndTime };
        }

        await saveGameState(newGameState);
        setCityGameState(newGameState);
    };
    
    const handleDemolish = async (buildingId) => {
        const currentState = cityGameState;
        if (!currentState || !worldId) return;

        const currentQueue = currentState.buildQueue || [];
        if (currentQueue.length >= 5) {
            setMessage("Build queue is full (max 5).");
            return;
        }

        const building = currentState.buildings[buildingId];
        if (!building) {
            setMessage("Building not found.");
            return;
        }

        let finalLevel = building.level;
        const tasksForBuilding = currentQueue.filter(task => task.buildingId === buildingId);
        if (tasksForBuilding.length > 0) {
            finalLevel = tasksForBuilding[tasksForBuilding.length - 1].level;
        }

        if (finalLevel <= 0) {
            setMessage("Building is already at or being demolished to level 0.");
            return;
        }

        const levelToDemolishFrom = finalLevel;
        const targetLevel = finalLevel - 1;

        const costConfig = buildingConfig[buildingId].baseCost;
        const calculatedTime = Math.floor(costConfig.time * Math.pow(1.25, levelToDemolishFrom - 1));
        const demolitionTime = isInstantBuild ? 1 : Math.floor(calculatedTime / 2);

        let lastEndTime = Date.now();
        if (currentQueue.length > 0) {
            const lastQueueItem = currentQueue[currentQueue.length - 1];
            if (lastQueueItem.endTime) {
                lastEndTime = lastQueueItem.endTime.toDate
                    ? lastQueueItem.endTime.toDate().getTime()
                    : new Date(lastQueueItem.endTime).getTime();
            }
        }

        const endTime = new Date(lastEndTime + demolitionTime * 1000);

        const newQueueItem = {
            id: uuidv4(),
            type: 'demolish',
            buildingId,
            level: targetLevel,
            currentLevel: levelToDemolishFrom,
            endTime: endTime,
        };

        const newGameState = JSON.parse(JSON.stringify(currentState));
        newGameState.buildQueue = [...currentQueue, newQueueItem];

        try {
            await saveGameState(newGameState);
            setCityGameState(newGameState);
        } catch (error) {
            console.error("Error adding demolition to build queue:", error);
            setMessage("Could not start demolition. Please try again.");
        }
    };
    
    const handleBuildSpecialBuilding = async (buildingId, cost) => {
        const currentState = cityGameState;
        if (currentState.specialBuilding || (currentState.buildQueue || []).some(task => task.isSpecial)) {
            setMessage("You can only build one special building per city.");
            return;
        }

        const currentQueue = currentState.buildQueue || [];
        if (currentQueue.length >= 5) {
            setMessage("Build queue is full (max 5).");
            return;
        }

        const currentUsedPopulation = calculateUsedPopulation(currentState);
        const maxPopulation = getFarmCapacity(currentState.buildings.farm.level);
        const availablePopulation = maxPopulation - currentUsedPopulation;

        if (availablePopulation < cost.population) {
            setMessage("Not enough population to construct this wonder.");
            return;
        }

        if (
            currentState.resources.wood < cost.wood ||
            currentState.resources.stone < cost.stone ||
            currentState.resources.silver < cost.silver
        ) {
            setMessage("Not enough resources to construct this wonder.");
            return;
        }

        const newGameState = JSON.parse(JSON.stringify(currentState));
        newGameState.resources.wood -= cost.wood;
        newGameState.resources.stone -= cost.stone;
        newGameState.resources.silver -= cost.silver;

        let lastEndTime = Date.now();
        if (currentQueue.length > 0) {
            const lastQueueItem = currentQueue[currentQueue.length - 1];
            if (lastQueueItem.endTime) {
                lastEndTime = lastQueueItem.endTime.toDate
                    ? lastQueueItem.endTime.toDate().getTime()
                    : new Date(lastQueueItem.endTime).getTime();
            }
        }

        const buildTimeInSeconds = 7200;
        const endTime = new Date(lastEndTime + buildTimeInSeconds * 1000);

        const newQueueItem = {
            id: uuidv4(),
            buildingId: buildingId,
            isSpecial: true,
            level: 1, 
            endTime: endTime,
        };

        newGameState.buildQueue = [...currentQueue, newQueueItem];
        await saveGameState(newGameState);
        setCityGameState(newGameState);
        closeModal('isSpecialBuildingMenuOpen');
        setMessage("Construction of your wonder has begun!");
    };

    const handleDemolishSpecialBuilding = async () => {
        const currentState = cityGameState;
        if (!currentState.specialBuilding) {
            setMessage("No special building to demolish.");
            return;
        }

        const cost = { wood: 15000, stone: 15000, silver: 15000, population: 60 };
        const refund = {
            wood: Math.floor(cost.wood * 0.5),
            stone: Math.floor(cost.stone * 0.5),
            silver: Math.floor(cost.silver * 0.5),
        };

        const newGameState = JSON.parse(JSON.stringify(currentState));
        newGameState.resources.wood += refund.wood;
        newGameState.resources.stone += refund.stone;
        newGameState.resources.silver += refund.silver;
        delete newGameState.specialBuilding;

        await saveGameState(newGameState);
        setCityGameState(newGameState);
        setMessage("The wonder has been demolished and half of its resources have been returned.");
    };

    return { handleUpgrade, handleCancelBuild, handleDemolish, handleBuildSpecialBuilding, handleDemolishSpecialBuilding };
};
</file>

<file path="src/hooks/actions/useDivineActions.js">
// src/hooks/actions/useDivineActions.js

export const useDivineActions = ({
    cityGameState, setCityGameState, saveGameState,
    closeModal, setMessage
}) => {
    const handleWorshipGod = async (godName) => {
        if (!cityGameState || !godName) return;
        const newWorshipData = { ...(cityGameState.worship || {}) };
        if (newWorshipData[godName] === undefined) {
            newWorshipData[godName] = 0;
        }
        newWorshipData.lastFavorUpdate = Date.now();
        const newGameState = { ...cityGameState, god: godName, worship: newWorshipData };
        await saveGameState(newGameState);
        setCityGameState(newGameState);
        closeModal('isTempleMenuOpen');
    };

    const handleCastSpell = async (power) => {
        const currentState = cityGameState;
        if (!currentState || !currentState.god || (currentState.worship[currentState.god] || 0) < power.favorCost) {
            setMessage("Not enough favor to cast this spell.");
            return;
        }

        const newGameState = JSON.parse(JSON.stringify(currentState));
        newGameState.worship[currentState.god] -= power.favorCost;

        switch (power.effect.type) {
            case 'add_resources':
                newGameState.resources[power.effect.resource] = (newGameState.resources[power.effect.resource] || 0) + power.effect.amount;
                break;
            case 'add_multiple_resources':
                for (const resource in power.effect.resources) {
                    newGameState.resources[resource] = (newGameState.resources[resource] || 0) + power.effect.resources[resource];
                }
                break;
            default:
                setMessage("This spell's effect is not yet implemented.");
                return;
        }

        try {
            await saveGameState(newGameState);
            setCityGameState(newGameState);
            setMessage(`${power.name} has been cast!`);
            closeModal('isDivinePowersOpen');
        } catch (error) {
            console.error("Error casting spell:", error);
            setMessage("Failed to cast the spell. Please try again.");
        }
    };

    return { handleWorshipGod, handleCastSpell };
};
</file>

<file path="src/hooks/actions/useHeroActions.js">
// src/hooks/actions/useHeroActions.js
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import { db } from '../../firebase/config';
import { doc, runTransaction, collection, serverTimestamp, getDocs } from 'firebase/firestore';
import heroesConfig from '../../gameData/heroes.json';
import { calculateDistance, calculateTravelTime } from '../../utils/travel';

export const useHeroActions = (cityGameState, saveGameState, setMessage) => {
    const { currentUser } = useAuth();
    const { worldId, activeCityId} = useGame();

    const onRecruitHero = async (heroId) => {
        const hero = heroesConfig[heroId];
        if (!hero) return;

        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', activeCityId);

        try {
            await runTransaction(db, async (transaction) => {
                const cityDoc = await transaction.get(cityDocRef);
                if (!cityDoc.exists()) throw new Error("City data not found.");

                const cityData = cityDoc.data();
                if (cityData.resources.silver < hero.cost.silver) throw new Error("Not enough silver.");
                if ((cityData.worship[cityData.god] || 0) < hero.cost.favor) throw new Error("Not enough favor.");

                const newResources = { ...cityData.resources, silver: cityData.resources.silver - hero.cost.silver };
                const newWorship = { ...cityData.worship, [cityData.god]: cityData.worship[cityData.god] - hero.cost.favor };
                const newHeroes = { ...cityData.heroes, [heroId]: { active: true, cityId: null, level: 1, xp: 0 } };

                transaction.update(cityDocRef, { resources: newResources, worship: newWorship, heroes: newHeroes });
            });
            setMessage(`${hero.name} has been recruited!`);
        } catch (error) {
            setMessage(`Failed to recruit hero: ${error.message}`);
        }
    };

    const onActivateSkill = async (heroId, skill) => {
        const hero = heroesConfig[heroId];
        if (!hero) return;

        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', activeCityId);

        try {
            await runTransaction(db, async (transaction) => {
                const cityDoc = await transaction.get(cityDocRef);
                if (!cityDoc.exists()) throw new Error("City data not found.");

                const cityData = cityDoc.data();
                const heroData = cityData.heroes?.[heroId] || { level: 1 };
                const favorCost = skill.cost.favor;
                const currentSkillCost = (favorCost.base || 0) + ((heroData.level - 1) * (favorCost.perLevel || 0));

                if ((cityData.worship?.[cityData.god] || 0) < currentSkillCost) {
                    throw new Error("Not enough favor.");
                }

                const activeSkills = cityData.activeSkills || {};
                const now = Date.now();
                if (activeSkills[skill.name] && now < activeSkills[skill.name].expires) {
                    const timeLeft = Math.ceil((activeSkills[skill.name].expires - now) / 1000);
                    throw new Error(`Skill is on cooldown. Time left: ${timeLeft}s`);
                }

                const newWorship = { ...cityData.worship, [cityData.god]: cityData.worship[cityData.god] - currentSkillCost };

                let newBuffs = { ...(cityData.buffs || {}) };
                const newActiveSkills = { ...activeSkills };

                const skillCooldown = (skill.cooldown || 0) * 1000;
                newActiveSkills[skill.name] = {
                    activatedAt: now,
                    expires: now + skillCooldown
                };

                const effectValue = (skill.effect.baseValue || 0) + ((heroData.level - 1) * (skill.effect.valuePerLevel || 0));

                if (skill.effect.type === 'troop_buff') {
                    newBuffs.battle = {
                        ...(newBuffs.battle || {}),
                        [skill.effect.subtype]: {
                            value: effectValue,
                            unit_type: skill.effect.unit_type
                        }
                    };
                } else if (skill.effect.type === 'city_buff') {
                    const skillDuration = (skill.effect.duration || 0) * 1000;
                    newBuffs.city = {
                        ...(newBuffs.city || {}),
                        [skill.effect.subtype]: {
                            value: effectValue,
                            expires: now + skillDuration
                        }
                    };
                }

                transaction.update(cityDocRef, {
                    worship: newWorship,
                    buffs: newBuffs,
                    activeSkills: newActiveSkills
                });
            });
            setMessage(`${skill.name} has been activated!`);
        } catch (error) {
            setMessage(`Failed to activate skill: ${error.message}`);
        }
    };

    const onAssignHero = async (heroId) => {
        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', activeCityId);
        const newMovementRef = doc(collection(db, 'worlds', worldId, 'movements'));
    
        try {
            await runTransaction(db, async (transaction) => {
                const cityDoc = await transaction.get(cityDocRef);
                if (!cityDoc.exists()) throw new Error("City data not found.");
    
                const cityData = cityDoc.data();
                const heroes = cityData.heroes || {};
    
                for (const hId in heroes) {
                    if (heroes[hId].cityId === activeCityId) {
                        throw new Error("Another hero is already stationed in this city.");
                    }
                }
    
                const distance = calculateDistance({ x: 0, y: 0 }, { x: cityData.x, y: cityData.y });
                const travelSeconds = calculateTravelTime(distance, 10);
                const arrivalTime = new Date(Date.now() + travelSeconds * 1000);
    
                const movementData = {
                    type: 'assign_hero',
                    status: 'moving',
                    hero: heroId,
                    originCityId: null,
                    originCoords: { x: -1, y: -1 },
                    targetCityId: activeCityId,
                    targetCoords: { x: cityData.x, y: cityData.y },
                    targetOwnerId: currentUser.uid,
                    departureTime: serverTimestamp(),
                    arrivalTime: arrivalTime,
                    involvedParties: [currentUser.uid]
                };
    
                transaction.set(newMovementRef, movementData);
            });
            setMessage(`${heroesConfig[heroId].name} is on their way to this city.`);
        } catch (error) {
            setMessage(`Failed to assign hero: ${error.message}`);
        }
    };

    const onUnassignHero = async (heroId) => {
        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', activeCityId);
        try {
            await runTransaction(db, async (transaction) => {
                const cityDoc = await transaction.get(cityDocRef);
                if (!cityDoc.exists()) throw new Error("City data not found.");
                const cityData = cityDoc.data();
                const heroes = cityData.heroes || {};
                const newHeroes = { ...heroes, [heroId]: { ...heroes[heroId], cityId: null } };
                transaction.update(cityDocRef, { heroes: newHeroes });
            });
            setMessage(`${heroesConfig[heroId].name} is no longer stationed in this city.`);
        } catch (error) {
            setMessage(`Failed to unassign hero: ${error.message}`);
        }
    };

    const onReleaseHero = async (prisonerToRelease) => {
        if (!prisonerToRelease || !prisonerToRelease.captureId) {
            setMessage("Invalid prisoner data.");
            return;
        }
    
        const capturingCityRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', activeCityId);
        
        try {
            // #comment Fetch all cities of the hero's owner BEFORE the transaction
            const heroOwnerCitiesRef = collection(db, `users/${prisonerToRelease.ownerId}/games`, worldId, 'cities');
            const heroOwnerCitiesSnap = await getDocs(heroOwnerCitiesRef);

            await runTransaction(db, async (transaction) => {
                const capturingCityDoc = await transaction.get(capturingCityRef);
    
                if (!capturingCityDoc.exists()) throw new Error("Your city data could not be found.");
    
                const capturingCityData = capturingCityDoc.data();
                const currentPrisoners = capturingCityData.prisoners || [];
                const newPrisoners = currentPrisoners.filter(p => p.captureId !== prisonerToRelease.captureId);
    
                if (newPrisoners.length === currentPrisoners.length) {
                    throw new Error("Could not find the specified prisoner to release.");
                }
    
                transaction.update(capturingCityRef, { prisoners: newPrisoners });
    
                // #comment Update all of the owner's city docs to remove the capturedIn flag
                heroOwnerCitiesSnap.forEach(cityDoc => {
                    const cityData = cityDoc.data();
                    const heroes = cityData.heroes || {};
                    if (heroes[prisonerToRelease.heroId]) {
                        const newHeroes = { ...heroes };
                        delete newHeroes[prisonerToRelease.heroId].capturedIn;
                        transaction.update(cityDoc.ref, { heroes: newHeroes });
                    }
                });
    
                // Create a return movement for the hero
                const newMovementRef = doc(collection(db, 'worlds', worldId, 'movements'));
                const heroOwnerCityCoords = prisonerToRelease.originCityCoords;
                if (!heroOwnerCityCoords) {
                    throw new Error("Released hero's home city coordinates not found.");
                }
    
                const distance = calculateDistance(capturingCityData, heroOwnerCityCoords);
                const travelSeconds = calculateTravelTime(distance, 10); // Use a base speed for heroes
                const arrivalTime = new Date(Date.now() + travelSeconds * 1000);
    
                const movementData = {
                    type: 'return',
                    status: 'returning',
                    hero: prisonerToRelease.heroId,
                    originCityId: activeCityId,
                    originCoords: { x: capturingCityData.x, y: capturingCityData.y },
                    originOwnerId: currentUser.uid,
                    originCityName: capturingCityData.cityName,
                    targetCityId: prisonerToRelease.originCityId,
                    targetCoords: { x: heroOwnerCityCoords.x, y: heroOwnerCityCoords.y },
                    targetOwnerId: prisonerToRelease.ownerId,
                    departureTime: serverTimestamp(),
                    arrivalTime: arrivalTime,
                    involvedParties: [currentUser.uid, prisonerToRelease.ownerId]
                };
                transaction.set(newMovementRef, movementData);
            });
            setMessage(`${heroesConfig[prisonerToRelease.heroId].name} has been released and is returning home.`);
        } catch (error) {
            setMessage(`Failed to release hero: ${error.message}`);
            console.error(error);
        }
    };

    return { onRecruitHero, onActivateSkill, onAssignHero, onUnassignHero, onReleaseHero };
};
</file>

<file path="src/hooks/actions/useResearchActions.js">
// src/hooks/actions/useResearchActions.js
import researchConfig from '../../gameData/research.json';

export const useResearchActions = ({
    cityGameState, setCityGameState, saveGameState,
    getResearchCost, setMessage
}) => {
    const handleStartResearch = async (researchId) => {
        const currentState = cityGameState;
        if (!currentState || !researchConfig[researchId]) return;

        const currentQueue = currentState.researchQueue || [];
        if (currentQueue.length >= 5) {
            setMessage("Research queue is full (max 5).");
            return;
        }

        const researchData = researchConfig[researchId];
        const { cost, requirements } = researchData;

        if (currentState.research[researchId]) {
            setMessage("Research already completed.");
            return;
        }
        if (currentQueue.some(item => item.researchId === researchId)) {
            setMessage("Research is already in the queue.");
            return;
        }
        if (requirements.academy && currentState.buildings.academy.level < requirements.academy) {
            setMessage(`Requires Academy Level ${requirements.academy}.`);
            return;
        }
        if (requirements.research && !currentState.research[requirements.research]) {
            setMessage(`Requires "${researchConfig[requirements.research].name}" research first.`);
            return;
        }
        if (
            currentState.resources.wood < cost.wood ||
            currentState.resources.stone < cost.stone ||
            currentState.resources.silver < cost.silver ||
            (currentState.researchPoints || 0) < (cost.points || 0)
        ) {
            setMessage("Not enough resources or research points.");
            return;
        }

        const newGameState = JSON.parse(JSON.stringify(currentState));
        newGameState.resources.wood -= cost.wood;
        newGameState.resources.stone -= cost.stone;
        newGameState.resources.silver -= cost.silver;
        newGameState.researchPoints = (newGameState.researchPoints || 0) - (cost.points || 0);

        let lastEndTime = Date.now();
        if (currentQueue.length > 0) {
            const lastQueueItem = currentQueue[currentQueue.length - 1];
            if (lastQueueItem.endTime) {
                lastEndTime = lastQueueItem.endTime.toDate
                    ? lastQueueItem.endTime.toDate().getTime()
                    : new Date(lastQueueItem.endTime).getTime();
            }
        }
        const researchTime = getResearchCost(researchId).time;
        const endTime = new Date(lastEndTime + researchTime * 1000);

        const newQueueItem = {
            researchId,
            endTime: endTime,
        };
        newGameState.researchQueue = [...currentQueue, newQueueItem];

        try {
            await saveGameState(newGameState);
            setCityGameState(newGameState);
            setMessage(`Research for "${researchData.name}" started.`);
        }
        catch (error) {
            console.error("Error starting research:", error);
            setMessage("Could not start research. Please try again.");
        }
    };

    const handleCancelResearch = async (itemIndex) => {
        const currentState = cityGameState;
        if (!currentState || !currentState.researchQueue || itemIndex < 0 || itemIndex >= currentState.researchQueue.length) {
            return;
        }

        if (itemIndex !== currentState.researchQueue.length - 1) {
            setMessage("You can only cancel the last item in the research queue.");
            return;
        }

        const newQueue = [...currentState.researchQueue];
        const canceledTask = newQueue.splice(itemIndex, 1)[0];
        const researchData = researchConfig[canceledTask.researchId];

        const newResources = {
            ...currentState.resources,
            wood: currentState.resources.wood + researchData.cost.wood,
            stone: currentState.resources.stone + researchData.cost.stone,
            silver: currentState.resources.silver + researchData.cost.silver,
        };
        const newResearchPoints = (currentState.researchPoints || 0) + (researchData.cost.points || 0);

        for (let i = itemIndex; i < newQueue.length; i++) {
            const previousTaskEndTime = (i === 0)
                ? Date.now()
                : (newQueue[i - 1]?.endTime ? newQueue[i - 1].endTime.getTime() : Date.now());
            const taskToUpdate = newQueue[i];
            const taskResearchTime = getResearchCost(taskToUpdate.researchId).time;
            const newEndTime = new Date(previousTaskEndTime + taskResearchTime * 1000);
            newQueue[i] = { ...taskToUpdate, endTime: newEndTime };
        }

        const newGameState = { ...currentState, resources: newResources, researchQueue: newQueue, researchPoints: newResearchPoints };
        await saveGameState(newGameState);
        setCityGameState(newGameState);
    };

    return { handleStartResearch, handleCancelResearch };
};
</file>

<file path="src/hooks/actions/useUnitActions.js">
// src/hooks/actions/useUnitActions.js
import { v4 as uuidv4 } from 'uuid';
import { doc, runTransaction } from 'firebase/firestore';
import { db } from '../../firebase/config';
import unitConfig from '../../gameData/units.json';
import { useAlliance } from '../../contexts/AllianceContext';

// #comment get warehouse capacity based on its level
const getWarehouseCapacity = (level) => {
    if (!level) return 0;
    return Math.floor(1500 * Math.pow(1.4, level - 1));
};

export const useUnitActions = ({
    cityGameState, setCityGameState, saveGameState, worldId, currentUser,
    getFarmCapacity, calculateUsedPopulation, isInstantUnits,
    setMessage
}) => {
    const { playerAlliance } = useAlliance();

    const handleTrainTroops = async (unitId, amount) => {
        const currentState = cityGameState;
        if (!currentState || !worldId || amount <= 0) return;

        const unit = unitConfig[unitId];
        if (!unit) {
            setMessage("Invalid unit type");
            return;
        }

        let queueName;
        let requiredBuildingLevel = 0;
        
        if (unit.type === 'naval') {
            queueName = 'shipyardQueue';
            requiredBuildingLevel = currentState.buildings.shipyard?.level || 0;
            if (requiredBuildingLevel === 0) {
                setMessage("Naval units can only be built in the Shipyard.");
                return;
            }
        } else if (unit.mythical) {
            queueName = 'divineTempleQueue';
            requiredBuildingLevel = currentState.buildings.divine_temple?.level || 0;
            if (requiredBuildingLevel === 0) {
                setMessage("Mythical units can only be trained in the Divine Temple.");
                return;
            }
        } else if (unit.type === 'land') {
            queueName = 'barracksQueue';
            requiredBuildingLevel = currentState.buildings.barracks?.level || 0;
            if (requiredBuildingLevel === 0) {
                setMessage("Land units can only be trained in the Barracks.");
                return;
            }
        } else {
            setMessage("Unknown unit type.");
            return;
        }

        const currentQueue = currentState[queueName] || [];
        if (currentQueue.length >= 5) {
            setMessage("Unit training queue is full (max 5).");
            return;
        }

        const totalCost = {
            wood: unit.cost.wood * amount,
            stone: unit.cost.stone * amount,
            silver: unit.cost.silver * amount,
            population: unit.cost.population * amount,
            favor: unit.cost.favor ? unit.cost.favor * amount : 0,
        };

        const effectiveUsedPopulation = calculateUsedPopulation(currentState);

        const maxPopulation = getFarmCapacity(currentState.buildings.farm.level);
        const availablePopulation = maxPopulation - effectiveUsedPopulation;

        if (currentState.resources.wood < totalCost.wood) {
            setMessage(`Need ${totalCost.wood - currentState.resources.wood} more wood`);
            return;
        }
        if (currentState.resources.stone < totalCost.stone) {
            setMessage(`Need ${totalCost.stone - currentState.resources.stone} more stone`);
            return;
        }
        if (currentState.resources.silver < totalCost.silver) {
            setMessage(`Need ${totalCost.silver - currentState.resources.silver} more silver`);
            return;
        }
        if (availablePopulation < totalCost.population) {
            setMessage(`Need ${totalCost.population - availablePopulation} more population capacity`);
            return;
        }
        if (unit.mythical && currentState.worship[currentState.god] < totalCost.favor) {
            setMessage(`Need ${totalCost.favor - currentState.worship[currentState.god]} more favor for ${currentState.god}`);
            return;
        }

        const newGameState = JSON.parse(JSON.stringify(currentState));
        newGameState.resources.wood -= totalCost.wood;
        newGameState.resources.stone -= totalCost.stone;
        newGameState.resources.silver -= totalCost.silver;
        if (unit.mythical) {
            newGameState.worship[newGameState.god] -= totalCost.favor;
        }

        const activeQueueForType = currentQueue.filter(task => {
            const taskEndTime = task.endTime?.toDate ? task.endTime.toDate() : new Date(task.endTime);
            return taskEndTime.getTime() > Date.now();
        });

        let lastEndTime = Date.now();
        if (activeQueueForType.length > 0) {
            const lastItem = activeQueueForType[activeQueueForType.length - 1];
            const lastItemEndTime = lastItem.endTime?.toDate ? lastItem.endTime.toDate() : new Date(lastItem.endTime);
            lastEndTime = lastItemEndTime.getTime();
        }

        let trainingTimeMultiplier = 1.0;
        if (playerAlliance?.research) {
            const trainingBoostLevel = playerAlliance.research.training_regimens?.level || 0;
            trainingTimeMultiplier -= trainingBoostLevel * 0.01;
        }

        const trainingTime = isInstantUnits ? 1 : (unit.cost.time * amount * trainingTimeMultiplier);
        const endTime = new Date(lastEndTime + trainingTime * 1000);

        const newQueueItem = {
            id: uuidv4(),
            unitId,
            amount,
            endTime: endTime,
        };
        newGameState[queueName] = [...activeQueueForType, newQueueItem];

        try {
            await saveGameState(newGameState);
            setCityGameState(newGameState);
        } catch (error) {
            console.error("Error adding to unit queue:", error);
            setMessage("Could not start training. Please try again.");
        }
    };

    const handleCancelTrain = async (canceledItem, queueType) => {
        const currentState = cityGameState;
        let queueName;
        let costField;
        let refundField;
    
        switch (queueType) {
            case 'barracks':
            case 'shipyard':
            case 'divineTemple':
                queueName = `${queueType}Queue`;
                costField = 'cost';
                refundField = 'units';
                break;
            case 'heal':
                queueName = 'healQueue';
                costField = 'heal_cost';
                refundField = 'wounded';
                break;
            default:
                console.error("Invalid queueType for cancellation:", queueType);
                setMessage("Error: Invalid queue type for cancellation.");
                return;
        }
    
        if (!currentState || !currentState[queueName]) {
            return;
        }
    
        const currentQueue = [...currentState[queueName]];
        const itemIndex = currentQueue.findIndex((item) => item.id === canceledItem.id);
    
        if (itemIndex === -1) {
            console.error("Item not found in queue for cancellation:", canceledItem);
            setMessage("Error: Item not found in queue.");
            return;
        }

        if (itemIndex !== currentQueue.length - 1) {
            setMessage("You can only cancel the last item in the queue.");
            return;
        }
    
        const newQueue = [...currentQueue];
        const removedTask = newQueue.splice(itemIndex, 1)[0];
        const unit = unitConfig[removedTask.unitId];
    
        if (!unit) {
            console.error("Unit not found for canceled task:", removedTask.unitId);
            setMessage("Error: Unit data missing for canceled task.");
            return;
        }
    
        const cityDocRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'cities', currentState.id);

        try {
            await runTransaction(db, async (transaction) => {
                const cityDoc = await transaction.get(cityDocRef);
                if (!cityDoc.exists()) throw new Error("City data not found.");
                const liveCityData = cityDoc.data();
                const capacity = getWarehouseCapacity(liveCityData.buildings.warehouse?.level);
                
                const newResources = {
                    ...liveCityData.resources,
                    wood: Math.min(capacity, (liveCityData.resources.wood || 0) + (unit[costField]?.wood || 0) * removedTask.amount),
                    stone: Math.min(capacity, (liveCityData.resources.stone || 0) + (unit[costField]?.stone || 0) * removedTask.amount),
                    silver: Math.min(capacity, (liveCityData.resources.silver || 0) + (unit[costField]?.silver || 0) * removedTask.amount),
                };
        
                const newRefundUnits = { ...liveCityData[refundField] };
                if (queueType === 'heal') {
                    newRefundUnits[removedTask.unitId] = (newRefundUnits[removedTask.unitId] || 0) + removedTask.amount;
                }
        
                for (let i = itemIndex; i < newQueue.length; i++) {
                    const previousTaskEndTime = (i === 0)
                        ? Date.now()
                        : (newQueue[i - 1]?.endTime ? new Date(newQueue[i - 1].endTime).getTime() : Date.now());
                    
                    const taskToUpdate = newQueue[i];
                    const taskUnit = unitConfig[taskToUpdate.unitId];
                    const taskTime = (queueType === 'heal' ? taskUnit.heal_time : taskUnit.cost.time) * taskToUpdate.amount;
                    const newEndTime = new Date(previousTaskEndTime + taskTime * 1000);
                    newQueue[i] = { ...taskToUpdate, endTime: newEndTime };
                }
        
                const updates = { resources: newResources, [queueName]: newQueue };
                if (queueType === 'heal') {
                    updates[refundField] = newRefundUnits;
                }
                
                transaction.update(cityDocRef, updates);
            });
        } catch (error) {
            console.error("Error cancelling training/healing:", error);
            setMessage("Could not cancel. Please try again.");
        }
    };

    const handleHealTroops = async (unitsToHeal) => {
        const currentState = cityGameState;
        if (!currentState || !worldId || Object.keys(unitsToHeal).length === 0) return;
    
        const newGameState = JSON.parse(JSON.stringify(currentState));
        let currentQueue = newGameState.healQueue || [];
        
        const maxPopulation = getFarmCapacity(currentState.buildings.farm.level);
        const usedPopulation = calculateUsedPopulation(currentState.buildings, currentState.units, currentState.specialBuilding);
        const availablePopulation = maxPopulation - usedPopulation;
        let populationToHeal = 0;
        for (const unitId in unitsToHeal) {
            const amount = unitsToHeal[unitId];
            const unit = unitConfig[unitId];
            populationToHeal += (unit.cost.population || 0) * amount;
        }
        if (availablePopulation < populationToHeal) {
            setMessage("Not enough available population to heal these units.");
            return;
        }
    
        const tasksToAdd = [];
        const totalCost = { wood: 0, stone: 0, silver: 0 };
    
        for (const unitId in unitsToHeal) {
            const amount = unitsToHeal[unitId];
            if (amount > 0) {
                const unit = unitConfig[unitId];
                tasksToAdd.push({
                    unitId,
                    amount,
                    cost: {
                        wood: (unit.heal_cost.wood || 0) * amount,
                        stone: (unit.heal_cost.stone || 0) * amount,
                        silver: (unit.heal_cost.silver || 0) * amount,
                    },
                    time: (unit.heal_time || 0) * amount,
                });
                totalCost.wood += tasksToAdd[tasksToAdd.length - 1].cost.wood;
                totalCost.stone += tasksToAdd[tasksToAdd.length - 1].cost.stone;
                totalCost.silver += tasksToAdd[tasksToAdd.length - 1].cost.silver;
            }
        }
    
        if (tasksToAdd.length + currentQueue.length > 5) {
            setMessage("Not enough space in the healing queue.");
            return;
        }
    
        if (
            currentState.resources.wood >= totalCost.wood &&
            currentState.resources.stone >= totalCost.stone &&
            currentState.resources.silver >= totalCost.silver
        ) {
            newGameState.resources.wood -= totalCost.wood;
            newGameState.resources.stone -= totalCost.stone;
            newGameState.resources.silver -= totalCost.silver;
    
            const newWounded = { ...newGameState.wounded };
            for (const task of tasksToAdd) {
                newWounded[task.unitId] -= task.amount;
                if (newWounded[task.unitId] <= 0) {
                    delete newWounded[task.unitId];
                }
            }
            newGameState.wounded = newWounded;
    
            let lastEndTime = Date.now();
            if (currentQueue.length > 0) {
                const lastQueueItem = currentQueue[currentQueue.length - 1];
                lastEndTime = lastQueueItem.endTime.toDate ? lastQueueItem.endTime.toDate().getTime() : new Date(lastQueueItem.endTime).getTime();
            }
    
            for (const task of tasksToAdd) {
                const endTime = new Date(lastEndTime + task.time * 1000);
                const newQueueItem = {
                    id: uuidv4(),
                    unitId: task.unitId,
                    amount: task.amount,
                    endTime,
                };
                currentQueue.push(newQueueItem);
                lastEndTime = endTime.getTime();
            }
            newGameState.healQueue = currentQueue;
    
            try {
                await saveGameState(newGameState);
                setCityGameState(newGameState);
                setMessage(`Healing started.`);
            } catch (error) {
                console.error("Error starting healing:", error);
                setMessage("Could not start healing. Please try again.");
            }
        } else {
            setMessage("Not enough resources to heal troops!");
        }
    };

    const handleCancelHeal = async (item) => {
        await handleCancelTrain(item, 'heal');
    };

    const handleFireTroops = async (unitsToFire) => {
        if (!cityGameState || !worldId || Object.keys(unitsToFire).length === 0) return;

        const cityDocRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'cities', cityGameState.id);

        try {
            await runTransaction(db, async (transaction) => {
                const cityDoc = await transaction.get(cityDocRef);
                if (!cityDoc.exists()) {
                    throw new Error("City document not found!");
                }
                const currentState = cityDoc.data();
                const newUnits = { ...currentState.units };

                for (const unitId in unitsToFire) {
                    const amount = unitsToFire[unitId];
                    if (newUnits[unitId] && newUnits[unitId] >= amount) {
                        newUnits[unitId] -= amount;
                        if (newUnits[unitId] === 0) {
                            delete newUnits[unitId];
                        }
                    } else {
                        throw new Error(`Trying to dismiss more ${unitId} than available.`);
                    }
                }
                transaction.update(cityDocRef, { units: newUnits });
            });
            setMessage("Units dismissed.");
        } catch (error) {
            console.error("Error firing units:", error);
            setMessage(`Could not dismiss units: ${error.message}`);
        }
    };

    return { handleTrainTroops, handleCancelTrain, handleHealTroops, handleCancelHeal, handleFireTroops };
};
</file>

<file path="src/hooks/actions/useWorkerActions.js">
// src/hooks/actions/useWorkerActions.js
import { useGame } from '../../contexts/GameContext';

export const useWorkerActions = ({ cityGameState, saveGameState, getMaxWorkerSlots, calculateUsedPopulation, getFarmCapacity, setMessage }) => {
    const { gameSettings } = useGame();

    const handleAddWorker = async (buildingId) => {
        const newGameState = { ...cityGameState };
        if (!newGameState.buildings[buildingId].workers) {
            newGameState.buildings[buildingId].workers = 0;
        }
        newGameState.buildings[buildingId].workers += 1;
        await saveGameState(newGameState);
    };
    
    // #comment Fixed a bug where removing a worker from a building with no workers assigned would result in NaN.
    const handleRemoveWorker = async (buildingId) => {
        const newGameState = { ...cityGameState };
        const currentWorkers = newGameState.buildings[buildingId].workers || 0;
        newGameState.buildings[buildingId].workers = Math.max(0, currentWorkers - 1);
        await saveGameState(newGameState);
    };

    // #comment Applies worker presets from the global game settings.
    const applyWorkerPresets = async () => {
        const presets = gameSettings.workerPresets;
        if (!presets) {
            setMessage("Worker presets not configured.");
            return;
        }

        const buildingsToUpdate = ['timber_camp', 'quarry', 'silver_mine'];
        
        const maxPopulation = getFarmCapacity(cityGameState.buildings.farm.level);
        const usedPopulation = calculateUsedPopulation(cityGameState.buildings, cityGameState.units, cityGameState.specialBuilding);
        let availablePopulation = maxPopulation - usedPopulation;

        const cappedGameState = JSON.parse(JSON.stringify(cityGameState));
        let appliedChanges = false;

        // Prioritize removing workers first to free up population
        for (const buildingId of buildingsToUpdate) {
             const building = cappedGameState.buildings[buildingId];
             if (!building || building.level === 0) continue;
             const currentWorkers = building.workers || 0;
             const presetWorkers = presets[buildingId] || 0;
             const targetWorkers = Math.min(presetWorkers, getMaxWorkerSlots(building.level));
             const diff = targetWorkers - currentWorkers;
             if (diff < 0) {
                 building.workers = targetWorkers;
                 availablePopulation -= diff * 20; // This will add to availablePopulation
                 appliedChanges = true;
             }
        }

        // Then add workers with the available population
        for (const buildingId of buildingsToUpdate) {
            const building = cappedGameState.buildings[buildingId];
            if (!building || building.level === 0) continue;
            const currentWorkers = building.workers || 0;
            const presetWorkers = presets[buildingId] || 0;
            const maxSlots = getMaxWorkerSlots(building.level);
            const targetWorkers = Math.min(presetWorkers, maxSlots);
            const diff = targetWorkers - currentWorkers;

            if (diff > 0) {
                const workersToAdd = Math.min(diff, Math.floor(availablePopulation / 20));
                if (workersToAdd > 0) {
                    building.workers += workersToAdd;
                    availablePopulation -= workersToAdd * 20;
                    appliedChanges = true;
                }
            }
        }
        
        if (appliedChanges) {
            await saveGameState(cappedGameState);
            setMessage("Applied presets with available population.");
        } else {
            setMessage("Worker distribution already matches presets or no population is available to add more.");
        }
    };

    // #comment Applies a specific worker preset from the Senate view.
    const applySenateWorkerPreset = async (preset) => {
        if (!preset || !preset.workers) {
            setMessage("Invalid preset.");
            return;
        }
        
        const buildingsToUpdate = ['timber_camp', 'quarry', 'silver_mine'];
        const maxPopulation = getFarmCapacity(cityGameState.buildings.farm.level);
        const usedPopulation = calculateUsedPopulation(cityGameState.buildings, cityGameState.units, cityGameState.specialBuilding);
        let availablePopulation = maxPopulation - usedPopulation;

        const newBuildingsState = JSON.parse(JSON.stringify(cityGameState.buildings));
        let changesMade = false;
        let populationNeeded = 0;
        let populationFreed = 0;
        
        // Calculate population changes
        for (const buildingId of buildingsToUpdate) {
            const building = newBuildingsState[buildingId];
            if (!building || building.level === 0) continue;
            const currentWorkers = building.workers || 0;
            const maxSlots = getMaxWorkerSlots(building.level);
            const targetWorkers = Math.min(preset.workers[buildingId] || 0, maxSlots);
            const diff = targetWorkers - currentWorkers;
            if (diff > 0) {
                populationNeeded += diff * 20;
            } else if (diff < 0) {
                populationFreed += -diff * 20;
            }
        }

        if (populationNeeded > availablePopulation + populationFreed) {
            setMessage(`Not enough population. Need ${populationNeeded}, but only ${availablePopulation + populationFreed} will be available.`);
            return;
        }

        // Apply changes
        for (const buildingId of buildingsToUpdate) {
            const building = newBuildingsState[buildingId];
            if (!building || building.level === 0) continue;
            const currentWorkers = building.workers || 0;
            const maxSlots = getMaxWorkerSlots(building.level);
            const targetWorkers = Math.min(preset.workers[buildingId] || 0, maxSlots);
            if (targetWorkers !== currentWorkers) {
                building.workers = targetWorkers;
                changesMade = true;
            }
        }

        if (changesMade) {
            const newGameState = { ...cityGameState, buildings: newBuildingsState };
            await saveGameState(newGameState);
            setMessage("Worker presets applied successfully.");
        } else {
            setMessage("All buildings already match the worker counts in the preset.");
        }
    };

    return { handleAddWorker, handleRemoveWorker, applyWorkerPresets, applySenateWorkerPreset };
};
</file>

<file path="src/hooks/useCityActions.js">
// src/hooks/useCityActions.js
import { useAdminActions } from './actions/useAdminActions';
import { useBuildingActions } from './actions/useBuildingActions';
import { useDivineActions } from './actions/useDivineActions';
import { useResearchActions } from './actions/useResearchActions';
import { useUnitActions } from './actions/useUnitActions';
import { useWorkerActions } from './actions/useWorkerActions';

/**
 * #comment A custom hook to aggregate all city-related actions from smaller, focused hooks.
 */
export const useCityActions = (props) => {
    const { cityGameState, openModal, setModalState } = props;

    // Instantiate all individual action hooks
    const adminActions = useAdminActions(props);
    const buildingActions = useBuildingActions(props);
    const divineActions = useDivineActions(props);
    const researchActions = useResearchActions(props);
    const unitActions = useUnitActions(props);
    const workerActions = useWorkerActions(props);

    // #comment Handles clicks on building plots in the city view.
    const handlePlotClick = (buildingId) => {
        const buildingData = cityGameState.buildings[buildingId];
        if (!buildingData || buildingData.level === 0) {
            // #comment If the special building plot is clicked and it's not built, open the menu
            if (buildingId === 'special_building_plot') {
                if (cityGameState.specialBuilding) {
                    openModal('isSpecialBuildingPanelOpen');
                } else {
                    openModal('isSpecialBuildingMenuOpen');
                }
                return;
            }
            openModal('isSenateViewOpen');
            return;
        }
        switch (buildingId) {
            case 'senate': openModal('isSenateViewOpen'); break;
            case 'barracks': openModal('isBarracksMenuOpen'); break;
            case 'shipyard': openModal('isShipyardMenuOpen'); break;
            case 'temple': openModal('isTempleMenuOpen'); break;
            case 'divine_temple': openModal('isDivineTempleMenuOpen'); break;
            case 'cave': openModal('isCaveMenuOpen'); break;
            case 'academy': openModal('isAcademyMenuOpen'); break;
            case 'hospital': openModal('isHospitalMenuOpen'); break;
            case 'market': openModal('isMarketMenuOpen'); break;
            case 'heroes_altar': openModal('isHeroesAltarOpen'); break;
            case 'prison': openModal('isPrisonMenuOpen'); break; // #comment Open prison menu
            // #comment Handle special building plot click
            case 'special_building_plot':
                if (cityGameState.specialBuilding) {
                    openModal('isSpecialBuildingPanelOpen');
                } else {
                    openModal('isSpecialBuildingMenuOpen');
                }
                break;
            default: setModalState(prev => ({ ...prev, selectedBuildingId: buildingId })); break;
        }
    };

    // Combine all actions into a single object
    return {
        ...adminActions,
        ...buildingActions,
        ...divineActions,
        ...researchActions,
        ...unitActions,
        ...workerActions,
        handlePlotClick,
    };
};
</file>

<file path="src/hooks/useCityModalManager.js">
// src/hooks/useCityModalManager.js
import { useState } from 'react';

/**
 * #comment Manages the state of all modals within the CityView.
 */
export const useCityModalManager = () => {
    const [modalState, setModalState] = useState({
        selectedBuildingId: null,
        isSenateViewOpen: false,
        isBarracksMenuOpen: false,
        isShipyardMenuOpen: false,
        isTempleMenuOpen: false,
        isDivineTempleMenuOpen: false,
        isCaveMenuOpen: false,
        isAcademyMenuOpen: false,
        isHospitalMenuOpen: false,
        isCheatMenuOpen: false,
        isDivinePowersOpen: false,
        isMarketMenuOpen: false,
        isSpecialBuildingMenuOpen: false,
        isSpecialBuildingPanelOpen: false, // #comment Add state for the new panel
        isHeroesAltarOpen: false,
        isWorkerPresetPanelOpen: false,
        isPrisonMenuOpen: false, // #comment Add state for the prison menu
    });

    const openModal = (modalKey) => setModalState(prev => ({ ...prev, [modalKey]: true }));
    const closeModal = (modalKey) => setModalState(prev => ({ ...prev, [modalKey]: false, selectedBuildingId: null }));

    return { modalState, setModalState, openModal, closeModal };
};
</file>

<file path="src/hooks/useCityState.js">
import { useState, useEffect, useCallback, useRef } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { doc, onSnapshot, setDoc, serverTimestamp} from 'firebase/firestore';
import { db } from '../firebase/config';
import buildingConfig from '../gameData/buildings.json';
import unitConfig from '../gameData/units.json';
import researchConfig from '../gameData/research.json';
import heroesConfig from '../gameData/heroes.json';
import { useGame } from '../contexts/GameContext';
import { v4 as uuidv4 } from 'uuid';
import { useAlliance } from '../contexts/AllianceContext';
import allianceWonders from '../gameData/alliance_wonders.json';

export const calculateTotalPointsForCity = (gameState, playerAlliance) => {
    if (!gameState) return 0;
    let points = 0;
    // #comment Calculate points from buildings
    if (gameState.buildings) {
        for (const buildingId in gameState.buildings) {
            const buildingData = gameState.buildings[buildingId];
            const buildingInfo = buildingConfig[buildingId];
            if (buildingInfo && buildingInfo.points) {
                const level = buildingData.level;
                // #comment Sum of an arithmetic series for level points
                points += buildingInfo.points * (level * (level + 1) / 2);
            }
        }
    }
    // #comment Calculate points from units based on population cost
    if (gameState.units) {
        for (const unitId in gameState.units) {
            const unit = unitConfig[unitId];
            if (unit) points += gameState.units[unitId] * (unit.cost.population || 1);
        }
    }
    // #comment Add points for completed research
    if (gameState.research) {
        points += Object.keys(gameState.research).length * 50;
    }
    // #comment Add points for alliance wonder
    if (playerAlliance?.allianceWonder) {
        points += 500;
    }
    return Math.floor(points);
};

const getMarketCapacity = (level) => {
    if (!level || level < 1) return 0;
    const capacity = 500 + (level - 1) * 200;
    return Math.min(2500, capacity);
};


export const useCityState = (worldId, isInstantBuild, isInstantResearch, isInstantUnits) => {
    const { currentUser } = useAuth();
    const { activeCityId, addNotification } = useGame();
    const { playerAlliance } = useAlliance();
    const [cityGameState, setCityGameState] = useState(null);
    const gameStateRef = useRef(cityGameState);

    useEffect(() => {
        gameStateRef.current = cityGameState;
    }, [cityGameState]);

    // #comment Memoized function to get happiness details
    const getHappinessDetails = useCallback((buildings) => {
        if (!buildings || !buildings.senate) return { base: 0, penalty: 0, total: 0 };

        const base = buildings.senate.level * 10;
        let workerCount = 0;
        const productionBuildings = ['timber_camp', 'quarry', 'silver_mine'];
        productionBuildings.forEach(buildingId => {
            if (buildings[buildingId] && buildings[buildingId].workers) {
                workerCount += Number(buildings[buildingId].workers || 0);
            }
        });
        const penalty = workerCount * 5;
        const total = Math.max(0, Math.min(100, base - penalty));
        return { base, penalty, total };
    }, []);

    // #comment Memoized function to calculate happiness
    const calculateHappiness = useCallback((buildings) => {
        if (!buildings || !buildings.senate) return 0;
        const details = getHappinessDetails(buildings);
        let happiness = details.total;
        if (playerAlliance?.allianceWonder?.id === 'shrine_of_the_ancestors') {
             happiness += allianceWonders.shrine_of_the_ancestors.bonus.value * 100;
        }
        return Math.min(100, happiness);
    }, [getHappinessDetails, playerAlliance]);

    // #comment Memoized function to get max worker slots
    const getMaxWorkerSlots = useCallback((level) => {
        if (!level || level < 1) return 0;
        return Math.min(6, 1 + Math.floor(level / 5));
    }, []);

    // #comment Memoized function to get production rates
    const getProductionRates = useCallback((buildings) => {
        if (!buildings) return { wood: 0, stone: 0, silver: 0 };
        const happiness = calculateHappiness(buildings);
        const happinessBonus = happiness > 70 ? 1.10 : (happiness < 40 ? 0.9 : 1.0);
        const rates = {
            wood: Math.floor(30 * Math.pow(1.2, (buildings.timber_camp?.level || 1) - 1)),
            stone: Math.floor(30 * Math.pow(1.2, (buildings.quarry?.level || 1) - 1)),
            silver: Math.floor(15 * Math.pow(1.15, (buildings.silver_mine?.level || 1) - 1)),
        };

        if (buildings.timber_camp?.workers) {
            const workerCount = Number(buildings.timber_camp.workers) || 0;
            rates.wood *= (1 + workerCount * 0.1);
        }
        if (buildings.quarry?.workers) {
            const workerCount = Number(buildings.quarry.workers) || 0;
            rates.stone *= (1 + workerCount * 0.1);
        }
        if (buildings.silver_mine?.workers) {
            const workerCount = Number(buildings.silver_mine.workers) || 0;
            rates.silver *= (1 + workerCount * 0.1);
        }
        // #comment Apply hero passive effects
        if (cityGameState?.heroes) {
            for (const heroId in cityGameState.heroes) {
                if (cityGameState.heroes[heroId].cityId === activeCityId) {
                    const hero = heroesConfig[heroId];
                    if (hero.passive.effect.subtype === 'silver_production') {
                        rates.silver *= (1 + hero.passive.effect.value);
                    }
                }
            }
        }
        // #comment Apply alliance research bonuses
        if (playerAlliance?.research) {
            const woodBoostLevel = playerAlliance.research.forestry_experts?.level || 0;
            const stoneBoostLevel = playerAlliance.research.masonry_techniques?.level || 0;
            const silverBoostLevel = playerAlliance.research.coinage_reform?.level || 0;
            rates.wood *= (1 + woodBoostLevel * 0.02);
            rates.stone *= (1 + stoneBoostLevel * 0.02);
            rates.silver *= (1 + silverBoostLevel * 0.02);
        }
        rates.wood = Math.floor(rates.wood * happinessBonus);
        rates.stone = Math.floor(rates.stone * happinessBonus);
        rates.silver = Math.floor(rates.silver * happinessBonus);
        return rates;
    }, [calculateHappiness, cityGameState, activeCityId, playerAlliance]);

    // #comment Memoized function to get warehouse capacity
    const getWarehouseCapacity = useCallback((level) => {
        if (!level) return 0;
        let capacity = Math.floor(1500 * Math.pow(1.4, level - 1));
        if (playerAlliance?.research) {
            const warehouseBoostLevel = playerAlliance.research.advanced_storage?.level || 0;
            capacity *= (1 + warehouseBoostLevel * 0.05);
        }
        return Math.floor(capacity);
    }, [playerAlliance]);

    // #comment Memoized function to get farm capacity
    const getFarmCapacity = useCallback((level) => {
        if (!level) return 0;
        let capacity = Math.floor(200 * Math.pow(1.25, level - 1));
        if (playerAlliance?.allianceWonder?.id === 'shrine_of_the_ancestors') {
            capacity *= (1 + allianceWonders.shrine_of_the_ancestors.bonus.value);
        }
        return capacity;
    }, [playerAlliance]);

    // #comment Memoized function to get hospital capacity
    const getHospitalCapacity = useCallback((level) => {
        if (!level) return 0;
        return level * 1000;
    }, []);

    // #comment Memoized function to get upgrade cost
    const getUpgradeCost = useCallback((buildingId, level) => {
        const building = buildingConfig[buildingId];
        if (!building || level < 1) return { wood: 0, stone: 0, silver: 0, population: 0, time: 0 };
        const cost = building.baseCost;
        let populationCost = Math.floor(cost.population * Math.pow(1.1, level - 1));
        const initialBuildings = ['senate', 'farm', 'warehouse', 'timber_camp', 'quarry', 'silver_mine', 'cave', 'hospital'];
        if (level === 1 && initialBuildings.includes(buildingId)) {
          populationCost = 0;
        }
        const calculatedTime = Math.floor(cost.time * Math.pow(1.25, level - 1));
        return {
            wood: Math.floor(cost.wood * Math.pow(1.6, level - 1)),
            stone: Math.floor(cost.stone * Math.pow(1.6, level - 1)),
            silver: Math.floor(cost.silver * Math.pow(1.8, level - 1)),
            population: populationCost,
            time: isInstantBuild ? 1 : calculatedTime,
        };
    }, [isInstantBuild]);

    // #comment Memoized function to get research cost
    const getResearchCost = useCallback((researchId) => {
        const research = researchConfig[researchId];
        if (!research) return null;
        let time = research.cost.time;
        if (playerAlliance?.allianceWonder?.id === 'great_forum') {
            time *= (1 - allianceWonders.great_forum.bonus.value);
        }
        return {
            wood: research.cost.wood,
            stone: research.cost.stone,
            silver: research.cost.silver,
            time: isInstantResearch ? 1 : time,
        };
    }, [isInstantResearch, playerAlliance]);

    // #comment Memoized function to calculate used population
    const calculateUsedPopulation = useCallback((gameState) => {
        if (!gameState) return 0;
        const { buildings, units, specialBuilding, barracksQueue, shipyardQueue, divineTempleQueue } = gameState;
        let used = 0;
        if (buildings) {
          for (const buildingId in buildings) {
            const buildingData = buildings[buildingId];
            const startLevel = ['senate', 'farm', 'warehouse', 'timber_camp', 'quarry', 'silver_mine', 'cave', 'hospital'].includes(buildingId) ? 1 : 0;
            for (let i = startLevel; i <= buildingData.level; i++) {
              if (i > 0) {
                used += getUpgradeCost(buildingId, i).population;
              }
            }
            if (buildingData.workers) {
                used += buildingData.workers * 20;
            }
          }
        }
        if (units) {
          for (const unitId in units) {
            used += (unitConfig[unitId]?.cost.population || 0) * units[unitId];
          }
        }
        if (specialBuilding) {
            used += 60;
        }
        const queues = [barracksQueue || [], shipyardQueue || [], divineTempleQueue || []];
        queues.forEach(queue => {
            queue.forEach(task => {
                const unit = unitConfig[task.unitId];
                if (unit) {
                    used += (unit.cost.population || 0) * task.amount;
                }
            });
        });
        return used;
    }, [getUpgradeCost]);

    // #comment Memoized function to calculate total points
    const calculateTotalPoints = useCallback((gameState) => {
        return calculateTotalPointsForCity(gameState, playerAlliance);
    }, [playerAlliance]);

    // #comment Save game state to Firestore
    const saveGameState = useCallback(async (stateToSave) => {
        if (!currentUser || !worldId || !activeCityId || !stateToSave) return;
        try {
            const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', activeCityId);
            const capacity = getWarehouseCapacity(stateToSave.buildings?.warehouse?.level);
            const cappedResources = {
                wood: Math.min(capacity, stateToSave.resources.wood || 0),
                stone: Math.min(capacity, stateToSave.resources.stone || 0),
                silver: Math.min(capacity, stateToSave.resources.silver || 0),
            };
            const dataToSave = {
                ...stateToSave,
                resources: { ...stateToSave.resources, ...cappedResources },
                lastUpdated: Date.now()
            };
            await setDoc(cityDocRef, dataToSave, { merge: true });
        } catch (error) {
            console.error('Failed to save game state:', error);
        }
    }, [currentUser, worldId, activeCityId, getWarehouseCapacity]);

    // #comment Effect to subscribe to city data changes
    useEffect(() => {
        if (!currentUser || !worldId || !activeCityId) {
            setCityGameState(null);
            return;
        }
        const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', activeCityId);
        const unsubscribe = onSnapshot(cityDocRef, (docSnap) => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                // #comment Initialize fields if they don't exist
                if (!data.buildings) data.buildings = {};
                for (const buildingId in buildingConfig) {
                    if (!data.buildings[buildingId]) {
                        data.buildings[buildingId] = { level: 0 };
                    }
                }
                if (!data.units) data.units = {};
                if (!data.agents) data.agents = {};
                if (!data.wounded) data.wounded = {};
                if (!data.worship) data.worship = {};
                if (!data.cave) data.cave = { silver: 0 };
                if (!data.research) data.research = {};
                if (!data.buildQueue) data.buildQueue = [];
                if (!data.barracksQueue) data.barracksQueue = [];
                if (!data.shipyardQueue) data.shipyardQueue = [];
                if (!data.divineTempleQueue) data.divineTempleQueue = [];
                if (!data.healQueue) data.healQueue = [];

                const convertAndAssignIds = (queue) => (queue || []).map(task => ({
                    id: task.id || uuidv4(),
                    ...task,
                    endTime: task.endTime?.toDate ? task.endTime.toDate() : task.endTime
                }));

                data.buildQueue = convertAndAssignIds(data.buildQueue);
                data.barracksQueue = convertAndAssignIds(data.barracksQueue);
                data.shipyardQueue = convertAndAssignIds(data.shipyardQueue);
                data.divineTempleQueue = convertAndAssignIds(data.divineTempleQueue);
                data.researchQueue = convertAndAssignIds(data.researchQueue);
                data.healQueue = convertAndAssignIds(data.healQueue);

                setCityGameState(data);
            } else {
                setCityGameState(null);
            }
        });
        return () => unsubscribe();
    }, [currentUser, worldId, activeCityId]);

    // #comment Effect for resource generation and queue processing
    useEffect(() => {
        if (!activeCityId) return;
        const interval = setInterval(() => {
            setCityGameState(prevState => {
                if (!prevState) return prevState;
                const now = Date.now();
                const lastUpdateTimestamp = prevState.lastUpdated?.toDate ? prevState.lastUpdated.toDate().getTime() : prevState.lastUpdated;
                const lastUpdate = lastUpdateTimestamp || now;
                const elapsedSeconds = (now - lastUpdate) / 1000;
                if (elapsedSeconds < 0) return prevState;
                const newState = JSON.parse(JSON.stringify(prevState));
                const productionRates = getProductionRates(newState.buildings);
                const capacity = getWarehouseCapacity(newState.buildings?.warehouse?.level);
                newState.resources.wood = Math.min(capacity, (prevState.resources.wood || 0) + (productionRates.wood / 3600) * elapsedSeconds);
                newState.resources.stone = Math.min(capacity, (prevState.resources.stone || 0) + (productionRates.stone / 3600) * elapsedSeconds);
                newState.resources.silver = Math.min(capacity, (prevState.resources.silver || 0) + (productionRates.silver / 3600) * elapsedSeconds);
                const templeLevel = newState.buildings.temple?.level || 0;
                if (newState.god && templeLevel > 0) {
                    let favorPerSecond = templeLevel / 3600;
                    if (playerAlliance?.research) {
                        const favorBoostLevel = playerAlliance.research.divine_devotion?.level || 0;
                        favorPerSecond *= (1 + favorBoostLevel * 0.02);
                    }
                    const maxFavor = 100 + (templeLevel * 20);
                    newState.worship[newState.god] = Math.min(maxFavor, (prevState.worship[newState.god] || 0) + favorPerSecond * elapsedSeconds);
                }
                newState.lastUpdated = now;
                return newState;
            });
        }, 1000);
        return () => clearInterval(interval);
    }, [activeCityId, getProductionRates, getWarehouseCapacity, playerAlliance]);

    useEffect(() => {
    const processQueue = async () => {
        try {
            const currentState = gameStateRef.current;
            if (!currentUser || !worldId || !activeCityId) return;
            if (!currentState?.buildQueue?.length &&
                !currentState?.barracksQueue?.length &&
                !currentState?.shipyardQueue?.length &&
                !currentState?.divineTempleQueue?.length &&
                !currentState?.researchQueue?.length &&
                !currentState?.healQueue?.length) {
                return;
            }
            const now = Date.now();
            let updates = {};
            let hasUpdates = false;
            const processSingleQueue = (queueName, processCompleted) => {
                if (!currentState[queueName]?.length) return;
                const activeQueue = [];
                const completedTasks = [];
                currentState[queueName].forEach(task => {
                    try {
                        const endTime = task.endTime?.toDate?.() ||
                                      (task.endTime instanceof Date ? task.endTime : new Date(task.endTime));
                        if (isNaN(endTime.getTime())) {
                            console.error('Invalid endTime', task);
                            return;
                        }
                        if (now >= endTime.getTime()) {
                            completedTasks.push(task);
                        } else {
                            activeQueue.push(task);
                        }
                    } catch (error) {
                        console.error('Error processing queue item:', error);
                    }
                });
                if (completedTasks.length > 0) {
                    updates[queueName] = activeQueue;
                    processCompleted(completedTasks, updates);
                    hasUpdates = true;
                    completedTasks.forEach(task => {
                        let message = '';
                        let iconType = '';
                        let iconId = '';
                        const cityName = currentState.cityName;
                        switch (queueName) {
                            case 'buildQueue':
                                const building = buildingConfig[task.buildingId];
                                if (task.type === 'demolish') {
                                    message = `Demolition of ${building.name} is complete in ${cityName}.`;
                                } else {
                                    message = `Your ${building.name} (Level ${task.level}) is complete in ${cityName}.`;
                                }
                                iconType = 'building';
                                iconId = task.buildingId;
                                break;
                            case 'barracksQueue':
                            case 'shipyardQueue':
                            case 'divineTempleQueue':
                                const unit = unitConfig[task.unitId];
                                message = `Training of ${task.amount}x ${unit.name} is complete in ${cityName}.`;
                                iconType = 'unit';
                                iconId = task.unitId;
                                break;
                            case 'researchQueue':
                                const research = researchConfig[task.researchId];
                                message = `Research for ${research.name} is complete in ${cityName}.`;
                                iconType = 'building';
                                iconId = 'academy';
                                break;
                            case 'healQueue':
                                const healedUnit = unitConfig[task.unitId];
                                message = `Healing of ${task.amount}x ${healedUnit.name} is complete in ${cityName}.`;
                                iconType = 'unit';
                                iconId = task.unitId;
                                break;
                            default:
                                break;
                        }
                        if (message && addNotification) {
                            addNotification(message, iconType, iconId);
                        }
                    });
                }
            };
            processSingleQueue('buildQueue', (completed, updates) => {
                updates.buildings = updates.buildings || { ...currentState.buildings };
                completed.forEach(task => {
                    if (task.type === 'demolish') {
                        if (updates.buildings[task.buildingId]) {
                            updates.buildings[task.buildingId].level = task.level;
                        }
                        // #comment Deactivate research if academy level is too low
                        if (task.buildingId === 'academy') {
                            const newAcademyLevel = task.level;
                            updates.research = updates.research || { ...currentState.research };
                            Object.keys(updates.research).forEach(researchId => {
                                const researchState = updates.research[researchId];
                                const isCompleted = researchState === true || (researchState && researchState.completed);
                                if (isCompleted) {
                                    const researchInfo = researchConfig[researchId];
                                    if (researchInfo && researchInfo.requirements.academy > newAcademyLevel) {
                                        updates.research[researchId] = { completed: true, active: false };
                                    }
                                }
                            });
                        }
                    } else if (task.isSpecial) {
                        updates.specialBuilding = task.buildingId;
                    } else {
                        if (!updates.buildings[task.buildingId]) {
                            updates.buildings[task.buildingId] = { level: 0 };
                        }
                        updates.buildings[task.buildingId].level = task.level;
                        // #comment Reactivate research if academy level is sufficient
                        if (task.buildingId === 'academy') {
                            const newAcademyLevel = task.level;
                            updates.research = updates.research || { ...currentState.research };
                            Object.keys(updates.research).forEach(researchId => {
                                const researchState = updates.research[researchId];
                                const isCompleted = researchState === true || (researchState && researchState.completed);
                                const isActive = researchState === true || (researchState && researchState.active);
                                if (isCompleted && !isActive) {
                                    const researchInfo = researchConfig[researchId];
                                    if (researchInfo && researchInfo.requirements.academy <= newAcademyLevel) {
                                        updates.research[researchId] = { completed: true, active: true };
                                    }
                                }
                            });
                        }
                    }
                });
            });
            processSingleQueue('barracksQueue', (completed, updates) => {
                updates.units = updates.units || { ...currentState.units };
                completed.forEach(task => {
                    updates.units[task.unitId] = (updates.units[task.unitId] || 0) + task.amount;
                });
            });
            processSingleQueue('shipyardQueue', (completed, updates) => {
                updates.units = updates.units || { ...currentState.units };
                completed.forEach(task => {
                    updates.units[task.unitId] = (updates.units[task.unitId] || 0) + task.amount;
                });
            });
            processSingleQueue('divineTempleQueue', (completed, updates) => {
                updates.units = updates.units || { ...currentState.units };
                completed.forEach(task => {
                    updates.units[task.unitId] = (updates.units[task.unitId] || 0) + task.amount;
                });
            });
            processSingleQueue('researchQueue', (completed, updates) => {
                updates.research = updates.research || { ...currentState.research };
                completed.forEach(task => {
                    updates.research[task.researchId] = { completed: true, active: true };
                });
            });
            processSingleQueue('healQueue', (completed, updates) => {
                updates.units = updates.units || { ...currentState.units };
                completed.forEach(task => {
                    updates.units[task.unitId] = (updates.units[task.unitId] || 0) + task.amount;
                });
            });
            if (hasUpdates) {
                const cityDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', activeCityId);
                await setDoc(cityDocRef, {
                    ...updates,
                    lastUpdated: serverTimestamp()
                }, { merge: true });
            }
        } catch (error) {
            console.error("Error in queue processing:", error);
        }
    };
    const interval = setInterval(processQueue, 1000);
    return () => clearInterval(interval);
}, [currentUser, worldId, activeCityId, getUpgradeCost, addNotification]);

    useEffect(() => {
        const autoSave = async () => {
            if (gameStateRef.current) {
                try {
                    await saveGameState(gameStateRef.current);
                } catch (error) {
                    console.error("Auto-save failed:", error);
                }
            }
        };
        const saveInterval = setInterval(autoSave, 30000); // Save every 30 seconds
        return () => clearInterval(saveInterval);
    }, [saveGameState]);
    
    return {
        cityGameState,
        setCityGameState,
        getUpgradeCost,
        getFarmCapacity,
        getWarehouseCapacity,
        getHospitalCapacity,
        getProductionRates,
        calculateUsedPopulation,
        saveGameState,
        getResearchCost,
        calculateTotalPoints,
        calculateHappiness,
        getHappinessDetails,
        getMaxWorkerSlots,
        getMarketCapacity
    }
};
</file>

<file path="src/hooks/useGameManager.js">
// src/hooks/useGameManager.js
import { useState } from 'react';
import { useGame } from '../contexts/GameContext';

export const useGameManager = () => {
    const { gameState, worldId, loading } = useGame();
    const [view, setView] = useState('city');
    const [isChatOpen, setIsChatOpen] = useState(false);

    const showMap = () => setView('map');
    const showCity = () => setView('city');

    const isLoading = loading || !gameState;

    return {
        view,
        isChatOpen,
        setIsChatOpen,
        showMap,
        showCity,
        isLoading,
        worldId
    };
};
</file>

<file path="src/hooks/useKeyboardControls.js">
// src/hooks/useKeyboardControls.js
import { useEffect } from 'react';

/**
 * #comment A custom hook to handle global keyboard shortcuts for game navigation.
 */
export const useKeyboardControls = (controls) => {
    useEffect(() => {
        const handleKeyDown = (e) => {
            // #comment Ignore key presses if the user is typing in an input, textarea, or text editor
            const activeElement = document.activeElement;
            const isTyping = activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable;
            if (isTyping) return;

            // #comment General controls, available in both views
            switch (e.key.toLowerCase()) {
                case 'm':
                    controls.toggleView?.();
                    break;
                case 'g': // Remapped from 'a'
                    controls.openAlliance?.();
                    break;
                case 'q':
                    controls.openQuests?.();
                    break;
                case ' ': // Space bar
                    e.preventDefault(); // Prevent default space bar action (e.g., scrolling)
                    controls.centerOnCity?.();
                    break;
                case 'f':
                    controls.openForum?.();
                    break;
                case 'i': // Using 'i' for messages/inbox
                    controls.openMessages?.();
                    break;
                case 'l':
                    controls.openLeaderboard?.();
                    break;
                case 'p':
                    controls.openProfile?.();
                    break;
                case 'o': // Remapped from 's'
                    controls.openSettings?.();
                    break;
                case 'arrowleft':
                    controls.cycleCityLeft?.();
                    break;
                case 'arrowright':
                    controls.cycleCityRight?.();
                    break;
                default:
                    break;
            }

            // #comment City-specific controls
            if (controls.view === 'city') {
                 switch (e.key.toLowerCase()) {
                    case 's':
                        controls.openSenate?.();
                        break;
                    case 'b':
                        controls.openBarracks?.();
                        break;
                    case 'h': // 'h' for Shipyard
                        controls.openShipyard?.();
                        break;
                    case 'u': // 'u' for University/Academy
                        controls.openAcademy?.();
                        break;
                    case 'k': // 'k' for Market
                        controls.openMarket?.();
                        break;
                    case 't':
                        controls.openTemple?.();
                        break;
                    default:
                        break;
                }
            }
        };

        window.addEventListener('keydown', handleKeyDown);

        // #comment Cleanup function to remove the event listener
        return () => {
            window.removeEventListener('keydown', handleKeyDown);
        };
    }, [controls]); // #comment Re-run the effect if the controls object changes
};
</file>

<file path="src/hooks/useMapActions.js">
import { useState, useCallback } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { useGame } from '../contexts/GameContext';
import { db } from '../firebase/config';
import { collection, writeBatch, doc, serverTimestamp, getDoc, runTransaction, query, where, limit, getDocs } from 'firebase/firestore';
import { v4 as uuidv4 } from 'uuid';
import { calculateDistance, calculateTravelTime } from '../utils/travel';
import unitConfig from '../gameData/units.json';
import buildingConfig from '../gameData/buildings.json';

export const useMapActions = (openModal, closeModal, showCity, invalidateChunkCache, setMessage) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId, gameState, playerCity, setGameState, worldState, playerCities } = useGame();
    const [travelTimeInfo, setTravelTimeInfo] = useState(null);

    const handleActionClick = useCallback((mode, targetCity) => {
        if (['attack', 'reinforce', 'scout', 'trade'].includes(mode)) {
            openModal('action', { mode, city: targetCity });
            closeModal('city');
            closeModal('village');
        } else if (mode === 'withdraw') {
            openModal('withdraw', targetCity);
            closeModal('city');
        } else if (mode === 'message') {
            openModal('messages', { city: targetCity });
            closeModal('city');
        } else if (mode === 'castSpell') {
            openModal('divinePowers', { targetCity });
            closeModal('city');
        } else if (mode === 'profile') {
            openModal('profile', { userId: targetCity.ownerId });
            closeModal('city');
        } else if (['information', 'rally'].includes(mode)) {
            setMessage(`${mode.charAt(0).toUpperCase() + mode.slice(1)} is not yet implemented.`);
        }
    }, [openModal, closeModal, setMessage]);

    const handleSendMovement = useCallback(async (movementDetails) => {
        const { mode, targetCity, units, resources, attackFormation, hero } = movementDetails;

        if (!playerCity) {
            setMessage("Cannot send movement: Your city data could not be found.");
            return;
        }
        if (targetCity.isVillageTarget && playerCity.islandId !== targetCity.islandId) {
            setMessage("You can only attack villages from a city on the same island.");
            return;
        }
        const isCrossIsland = targetCity.isRuinTarget || targetCity.isGodTownTarget ? true : playerCity.islandId !== targetCity.islandId;
        let hasLandUnits = false, hasNavalUnits = false, hasFlyingUnits = false, totalTransportCapacity = 0, totalLandUnitsToSend = 0;

        for (const unitId in units) {
            if (units[unitId] > 0) {
                const config = unitConfig[unitId];
                if (config.type === 'land') {
                    hasLandUnits = true;
                    totalLandUnitsToSend += units[unitId];
                    if (config.flying) {
                        hasFlyingUnits = true;
                    }
                }
                else if (config.type === 'naval') { hasNavalUnits = true; totalTransportCapacity += (config.capacity || 0) * units[unitId]; }
            }
        }

        if (isCrossIsland && hasLandUnits && !hasNavalUnits && !hasFlyingUnits) { setMessage("Ground troops cannot travel across the sea without transport ships."); return; }
        if (isCrossIsland && hasLandUnits && totalTransportCapacity < totalLandUnitsToSend && !hasFlyingUnits) { setMessage(`Not enough transport ship capacity. Need ${totalLandUnitsToSend - totalTransportCapacity} more capacity.`); return; }
        
        const unitTypes = [];
        if (hasLandUnits) unitTypes.push('land');
        if (hasNavalUnits) unitTypes.push('naval');
        if (hasFlyingUnits) unitTypes.push('flying');

        const batch = writeBatch(db);
        const newMovementRef = doc(collection(db, 'worlds', worldId, 'movements'));

        const finalTargetOwnerId = targetCity.ownerId || currentUser.uid;
        const isOwnCityTarget = finalTargetOwnerId === currentUser.uid;
        let targetCityDocId = null;

        if (!targetCity.isVillageTarget && !targetCity.isRuinTarget && !targetCity.isGodTownTarget && finalTargetOwnerId) {
            if (isOwnCityTarget) {
                targetCityDocId = targetCity.id;
            } else {
                const citiesRef = collection(db, `users/${finalTargetOwnerId}/games`, worldId, 'cities');
                const q = query(citiesRef, where('slotId', '==', targetCity.id), limit(1));
                try {
                    const cityQuerySnap = await getDocs(q);
                    if (cityQuerySnap.empty) {
                        setMessage("Error: Could not find the target city's data. It may have been conquered or deleted.");
                        return;
                    }
                    targetCityDocId = cityQuerySnap.docs[0].id;
                } catch (error) {
                    console.error("Error fetching target city doc ID:", error);
                    setMessage("An error occurred while trying to target the city.");
                    return;
                }
            }
        }
        
        const distance = calculateDistance(playerCity, targetCity);
        const unitsBeingSent = Object.entries(units || {}).filter(([, count]) => count > 0);
        
        if (unitsBeingSent.length === 0 && !['trade', 'scout'].includes(mode) && !hero) {
            setMessage("No units or hero selected for movement.");
            return;
        }

        const slowestSpeed = unitsBeingSent.length > 0
            ? Math.min(...unitsBeingSent.map(([unitId]) => unitConfig[unitId].speed))
            : 10; 
        
        const travelSeconds = calculateTravelTime(distance, slowestSpeed, mode, worldState, unitTypes);
        const arrivalTime = new Date(Date.now() + travelSeconds * 1000);
        const cancellableUntil = new Date(Date.now() + 30 * 1000);

        let movementData;

        if (mode === 'attack' && targetCity.isGodTownTarget) {
            movementData = {
                type: 'attack_god_town',
                originCityId: playerCity.id,
                originCoords: { x: playerCity.x, y: playerCity.y },
                originOwnerId: currentUser.uid,
                originCityName: playerCity.cityName,
                originOwnerUsername: userProfile.username,
                targetTownId: targetCity.id,
                targetTownName: targetCity.name,
                targetCoords: { x: targetCity.x, y: targetCity.y },
                units: units,
                hero: hero,
                departureTime: serverTimestamp(),
                arrivalTime: arrivalTime,
                cancellableUntil: cancellableUntil,
                status: 'moving',
                attackFormation: attackFormation || {},
                involvedParties: [currentUser.uid],
                isGodTownTarget: true,
                isCrossIsland: true,
            };
        } else if (mode === 'attack' && targetCity.isVillageTarget) {
             movementData = {
                type: 'attack_village',
                originCityId: playerCity.id,
                originCoords: { x: playerCity.x, y: playerCity.y },
                originOwnerId: currentUser.uid,
                originCityName: playerCity.cityName,
                originOwnerUsername: userProfile.username,
                targetVillageId: targetCity.id,
                targetVillageName: targetCity.name,
                targetCoords: { x: targetCity.x, y: targetCity.y },
                units: units,
                hero: hero,
                resources: resources || {},
                departureTime: serverTimestamp(),
                arrivalTime: arrivalTime,
                cancellableUntil: cancellableUntil,
                status: 'moving',
                attackFormation: attackFormation || {},
                involvedParties: [currentUser.uid],
                isVillageTarget: true,
                isCrossIsland: false,
            };
        } else if (mode === 'attack' && targetCity.isRuinTarget) {
            movementData = {
                type: 'attack_ruin',
                originCityId: playerCity.id,
                originCoords: { x: playerCity.x, y: playerCity.y },
                originOwnerId: currentUser.uid,
                originCityName: playerCity.cityName,
                originOwnerUsername: userProfile.username,
                targetRuinId: targetCity.id,
                targetRuinName: targetCity.name,
                targetCoords: { x: targetCity.x, y: targetCity.y },
                units: units,
                hero: hero,
                departureTime: serverTimestamp(),
                arrivalTime: arrivalTime,
                cancellableUntil: cancellableUntil,
                status: 'moving',
                attackFormation: attackFormation || {},
                involvedParties: [currentUser.uid],
                isRuinTarget: true,
                isCrossIsland: true,
            };
        }
        else {
             movementData = {
                type: mode,
                originCityId: playerCity.id,
                originCoords: { x: playerCity.x, y: playerCity.y },
                originOwnerId: currentUser.uid,
                originCityName: playerCity.cityName,
                originOwnerUsername: userProfile.username,
                targetCityId: targetCityDocId,
                targetSlotId: isOwnCityTarget ? targetCity.slotId : targetCity.id,
                targetCoords: { x: targetCity.x, y: targetCity.y },
                targetOwnerId: finalTargetOwnerId,
                ownerUsername: targetCity.ownerUsername || userProfile.username,
                targetCityName: targetCity.cityName,
                units: units,
                hero: hero,
                resources: resources || {},
                departureTime: serverTimestamp(),
                arrivalTime: arrivalTime,
                cancellableUntil: cancellableUntil,
                status: 'moving',
                attackFormation: attackFormation || {},
                involvedParties: mode === 'scout' ? [currentUser.uid] : [currentUser.uid, finalTargetOwnerId].filter(id => id),
                isVillageTarget: !!targetCity.isVillageTarget,
                isCrossIsland,
            };
        }

        batch.set(newMovementRef, movementData);

        const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', playerCity.id);
        const updatedUnits = { ...gameState.units };
        for (const unitId in units) {
            updatedUnits[unitId] = (updatedUnits[unitId] || 0) - units[unitId];
        }

        const updatedResources = { ...gameState.resources };
        const updatedCave = { ...gameState.cave };
        if (mode === 'scout') {
            if (resources && resources.silver) {
                updatedCave.silver = (updatedCave.silver || 0) - resources.silver;
            }
        } else if (resources) {
            for (const resource in resources) {
                updatedResources[resource] -= resources[resource];
            }
        }
        
        const updatedHeroes = gameState.heroes ? { ...gameState.heroes } : {};
        if (hero && updatedHeroes[hero]) {
            updatedHeroes[hero].cityId = playerCity.id;
        }

        batch.update(gameDocRef, {
            units: updatedUnits,
            resources: updatedResources,
            cave: updatedCave,
            heroes: updatedHeroes
        });

        const newGameState = {
            ...gameState,
            units: updatedUnits,
            resources: updatedResources,
            cave: updatedCave,
            heroes: updatedHeroes
        };

        try {
            await batch.commit();
            setGameState(newGameState);
            setMessage(`Movement sent to ${targetCity.cityName || targetCity.name}!`);
        } catch (error) {
            console.error("Error sending movement:", error);
            setMessage(`Failed to send movement: ${error.message}`);
        }
    }, [currentUser, userProfile, worldId, gameState, playerCity, setGameState, setMessage, worldState]);

    const handleCancelMovement = useCallback(async (movementId) => {
        const movementRef = doc(db, 'worlds', worldId, 'movements', movementId);
        try {
            await runTransaction(db, async (transaction) => {
                const movementDoc = await transaction.get(movementRef);
                if (!movementDoc.exists()) {
                    throw new Error("Movement data not found.");
                }
                const movementData = movementDoc.data();
                const cancellableUntilData = movementData.cancellableUntil;
                const cancellableUntil = cancellableUntilData?.toDate ? cancellableUntilData.toDate() : new Date(cancellableUntilData);

                if (new Date() > cancellableUntil) {
                    throw new Error("The grace period to cancel this movement has passed.");
                }
                
                const now = Date.now();
                const departureTimeData = movementData.departureTime;
                const departureTime = departureTimeData?.toDate ? departureTimeData.toDate().getTime() : new Date(departureTimeData).getTime();

                const elapsedTime = now - departureTime;
                const returnArrivalTime = new Date(now + elapsedTime);

                transaction.update(movementRef, {
                    status: 'returning',
                    arrivalTime: returnArrivalTime,
                    departureTime: serverTimestamp(),
                    cancellableUntil: new Date(0) 
                });
            });
            setMessage("Movement is now returning.");
        } catch (error) {
            console.error("Error cancelling movement:", error);
            setMessage(`Could not cancel movement: ${error.message}`);
        }
    }, [worldId, setMessage]);

    const handleCreateDummyCity = useCallback(async (citySlotId, slotData) => {
        if (!userProfile?.is_admin) {
            setMessage("You are not authorized to perform this action.");
            return;
        }
        setMessage("Creating dummy city...");
        const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', citySlotId);
        const dummyUserId = `dummy_${uuidv4()}`;
        const dummyUsername = `DummyPlayer_${Math.floor(Math.random() * 10000)}`;
        const newCityDocRef = doc(collection(db, `users/${dummyUserId}/games`, worldId, 'cities'));

        try {
            const slotSnap = await getDoc(citySlotRef);
            if (!slotSnap.exists() || slotSnap.data().ownerId !== null) {
                throw new Error("Slot is already taken.");
            }
            const batch = writeBatch(db);
            const dummyCityName = `${dummyUsername}'s Outpost`;
            batch.update(citySlotRef, {
                ownerId: dummyUserId,
                ownerUsername: dummyUsername,
                cityName: dummyCityName,
            });
            const initialBuildings = {};
            Object.keys(buildingConfig).forEach(key => {
                initialBuildings[key] = { level: 0 };
            });
            initialBuildings.senate = { level: 1 };
            const newCityData = {
                id: newCityDocRef.id,
                slotId: citySlotId,
                cityName: dummyCityName,
                playerInfo: { religion: 'Dummy', nation: 'Dummy' },
                resources: { wood: 500, stone: 500, silver: 100 },
                buildings: initialBuildings,
                units: { swordsman: 10 },
                lastUpdated: Date.now(),
            };
            batch.set(newCityDocRef, newCityData);
            await batch.commit();
            setMessage(`Dummy city "${dummyCityName}" created successfully!`);
            invalidateChunkCache(slotData.x, slotData.y);
        } catch (error) {
            console.error("Error creating dummy city:", error);
            setMessage(`Failed to create dummy city: ${error.message}`);
        }
    }, [userProfile, worldId, invalidateChunkCache, setMessage]);
    
    const handleFoundCity = useCallback(async (plot, agentId, units) => {
        if (!playerCity || !gameState) {
            setMessage("Cannot found city: Your city data could not be found.");
            return;
        }
        const newMovementRef = doc(collection(db, 'worlds', worldId, 'movements'));
        const batch = writeBatch(db);
    
        // #comment Calculate travel time for the journey to the plot, then founding time separately.
        const slowestSpeed = Object.entries(units)
            .filter(([, count]) => count > 0)
            .map(([unitId]) => unitConfig[unitId].speed)
            .reduce((min, speed) => Math.min(min, speed), Infinity);
        
        const distance = calculateDistance(playerCity, plot);
        const travelSeconds = slowestSpeed === Infinity ? 0 : calculateTravelTime(distance, slowestSpeed, 'found_city', worldState, ['land']);
        const arrivalTime = new Date(Date.now() + travelSeconds * 1000);

        const baseFoundingTime = 86400;
        const reductionPerVillager = 3600;
        const villagers = units.villager || 0;
        const foundingTimeSeconds = Math.max(3600, baseFoundingTime - (villagers * reductionPerVillager));
    
        const existingCityNames = Object.values(playerCities).map(c => c.cityName);
        const baseName = `${userProfile.username}'s Colony`;
        let finalCityName = baseName;
        if (existingCityNames.includes(finalCityName)) {
            let count = 2;
            let newName;
            do {
                newName = `${baseName} ${count}`;
                count++;
            } while (existingCityNames.includes(newName));
            finalCityName = newName;
        }
        const movementData = {
            type: 'found_city',
            originCityId: playerCity.id,
            originCoords: { x: playerCity.x, y: playerCity.y },
            originOwnerId: currentUser.uid,
            originCityName: playerCity.cityName,
            originOwnerUsername: userProfile.username,
            targetSlotId: plot.id,
            targetCoords: { x: plot.x, y: plot.y },
            targetPlotName: 'Empty Plot',
            units: units,
            agent: agentId,
            departureTime: serverTimestamp(),
            arrivalTime: arrivalTime,
            status: 'moving',
            involvedParties: [currentUser.uid],
            newCityName: finalCityName,
            foundingTimeSeconds: foundingTimeSeconds
        };
        batch.set(newMovementRef, movementData);
        const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId, 'cities', playerCity.id);
        const updatedUnits = { ...gameState.units };
        for (const unitId in units) {
            updatedUnits[unitId] = (updatedUnits[unitId] || 0) - units[unitId];
        }
        const updatedAgents = { ...gameState.agents };
        updatedAgents[agentId] = (updatedAgents[agentId] || 0) - 1;
        batch.update(gameDocRef, {
            units: updatedUnits,
            agents: updatedAgents
        });
        const newGameState = {
            ...gameState,
            units: updatedUnits,
            agents: updatedAgents
        };
        try {
            await batch.commit();
            setGameState(newGameState);
            setMessage(`Your architect and troops are on their way to found a new city at (${plot.x}, ${plot.y})!`);
        } catch (error) {
            console.error("Error sending founding party:", error);
            setMessage(`Failed to send founding party: ${error.message}`);
        }
    }, [currentUser, userProfile, worldId, gameState, playerCity, setGameState, setMessage, playerCities, worldState]);

    const handleWithdrawTroops = useCallback(async (reinforcedCity, withdrawalData) => {
        if (!reinforcedCity || !reinforcedCity.ownerId) {
            setMessage("Invalid city data for withdrawal.");
            return;
        }
        const reinforcedCityOwnerId = reinforcedCity.ownerId;
        const reinforcedCitySlotId = reinforcedCity.slotId || reinforcedCity.id;

        const batch = writeBatch(db);

        for (const originCityId in withdrawalData) {
            const unitsToWithdraw = withdrawalData[originCityId];
            if (Object.values(unitsToWithdraw).every(amount => amount === 0)) {
                continue;
            }

            const newMovementRef = doc(collection(db, 'worlds', worldId, 'movements'));
            const originCity = playerCities[originCityId];
            if (!originCity) {
                console.error(`Could not find origin city with ID ${originCityId} for withdrawal.`);
                continue;
            }

            const distance = calculateDistance(reinforcedCity, originCity);
            const speeds = Object.keys(unitsToWithdraw).map(unitId => unitConfig[unitId].speed);
            const slowestSpeed = Math.min(...speeds);
            const travelSeconds = calculateTravelTime(distance, slowestSpeed);
            const arrivalTime = new Date(Date.now() + travelSeconds * 1000);

            const movementData = {
                type: 'return',
                status: 'returning',
                originCityId: originCityId,
                originCoords: { x: originCity.x, y: originCity.y },
                originOwnerId: currentUser.uid,
                originCityName: originCity.cityName,
                targetCityId: reinforcedCity.id,
                targetCoords: { x: reinforcedCity.x, y: reinforcedCity.y },
                units: unitsToWithdraw,
                departureTime: serverTimestamp(),
                arrivalTime: arrivalTime,
                involvedParties: [currentUser.uid, reinforcedCityOwnerId]
            };
            batch.set(newMovementRef, movementData);
        }

        try {
             await runTransaction(db, async (transaction) => {
                const citiesRef = collection(db, `users/${reinforcedCityOwnerId}/games`, worldId, 'cities');
                const q = query(citiesRef, where('slotId', '==', reinforcedCitySlotId), limit(1));
                const cityQuerySnap = await getDocs(q);

                if (cityQuerySnap.empty) {
                    console.warn(`Could not find city doc for slotId ${reinforcedCitySlotId} to update reinforcements.`);
                    return;
                }
                const reinforcedCityDocId = cityQuerySnap.docs[0].id;
                const reinforcedCityRef = doc(db, `users/${reinforcedCityOwnerId}/games`, worldId, 'cities', reinforcedCityDocId);
                const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', reinforcedCitySlotId);

                const reinforcedCitySnap = await transaction.get(reinforcedCityRef);
                if (!reinforcedCitySnap.exists()) {
                    throw new Error("Reinforced city data not found.");
                }

                const currentReinforcements = reinforcedCitySnap.data().reinforcements || {};
                const newReinforcements = JSON.parse(JSON.stringify(currentReinforcements));

                for (const originCityId in withdrawalData) {
                    const unitsToWithdraw = withdrawalData[originCityId];
                    for (const unitId in unitsToWithdraw) {
                        if (newReinforcements[originCityId]?.units?.[unitId]) {
                            newReinforcements[originCityId].units[unitId] -= unitsToWithdraw[unitId];
                            if (newReinforcements[originCityId].units[unitId] <= 0) {
                                delete newReinforcements[originCityId].units[unitId];
                            }
                        }
                    }
                    if (Object.keys(newReinforcements[originCityId]?.units || {}).length === 0) {
                        delete newReinforcements[originCityId];
                    }
                }
                transaction.update(reinforcedCityRef, { reinforcements: newReinforcements });
                transaction.update(citySlotRef, { reinforcements: newReinforcements });
            });
            await batch.commit();
        } catch (error) {
            console.error("Error withdrawing troops:", error);
            setMessage(`Failed to withdraw troops: ${error.message}`);
        }
    }, [currentUser, worldId, playerCities, setMessage]);

    return {
        travelTimeInfo,
        setTravelTimeInfo,
        handleActionClick,
        handleSendMovement,
        handleCancelMovement,
        handleCreateDummyCity,
        handleWithdrawTroops,
        handleFoundCity,
    };
};
</file>

<file path="src/hooks/useMapClickHandler.js">
import { calculateDistance } from '../utils/travel';
import { getVillageTroops } from '../utils/combat';
import { useGame } from '../contexts/GameContext';

export const useMapClickHandler = ({
    playerCity,
    isPlacingDummyCity,
    handleCreateDummyCity,
    setTravelTimeInfo,
    openModal,
    closeModal,
    setMessage,
    conqueredVillages,
    conqueredRuins,
}) => {
    const { gameState: cityGameState } = useGame();

    const onCitySlotClick = (e, slotData) => {
        if (!playerCity) {
            setMessage("Your city data is still loading. Please wait a moment.");
            return;
        }
        closeModal('village');
        if (isPlacingDummyCity && !slotData.ownerId) {
            handleCreateDummyCity(slotData.id, slotData);
            return;
        }
        if (slotData.ownerId) {
             const distance = calculateDistance(playerCity, slotData);
             setTravelTimeInfo({ distance });
            const cityData = slotData;
            const rect = e.currentTarget.getBoundingClientRect();
            const position = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2,
            };
            const modalData = { ...cityData, position };
            openModal('city', modalData);
        } else {
            if (!cityGameState) {
                setMessage("You must have an active city to found a new one. Please select one from the top bar.");
                return;
            }
            const hasArchitect = cityGameState.agents?.architect > 0;
            if (hasArchitect) {
                openModal('emptyCity', slotData);
            } else {
                setMessage('You need an Architect to found a new city. Recruit one at the Heroes Altar.');
            }
        }
    };

    const onVillageClick = (e, villageData) => {
        if (!playerCity) {
            setMessage("Your city data is still loading. Please wait a moment.");
            return;
        }
        closeModal('city');
        if (playerCity.islandId !== villageData.islandId) {
            setMessage("You can only interact with villages on islands where you have a city.");
            return;
        }
        const isConqueredByPlayer = conqueredVillages && conqueredVillages[villageData.id];
        if (isConqueredByPlayer) {
            openModal('village', { ...villageData, ...conqueredVillages[villageData.id] });
        } else {
            const distance = calculateDistance(playerCity, villageData);
            setTravelTimeInfo({ distance });
            const targetData = {
                id: villageData.id,
                name: villageData.name,
                cityName: villageData.name,
                ownerId: null,
                ownerUsername: 'Neutral',
                x: villageData.x,
                y: villageData.y,
                islandId: villageData.islandId,
                isVillageTarget: true,
                troops: getVillageTroops(villageData),
                level: villageData.level || 1,
                demands: villageData.demands,
                supplies: villageData.supplies,
                tradeRatio: villageData.tradeRatio
            };
            openModal('city', targetData);
        }
    };

    const onRuinClick = (e, ruinData) => {
        if (!playerCity) {
            setMessage("Your city data is still loading. Please wait a moment.");
            return;
        }
        closeModal('city');
        closeModal('village');
        const distance = calculateDistance(playerCity, ruinData);
        setTravelTimeInfo({ distance });
        const isConqueredByYou = conqueredRuins && conqueredRuins[ruinData.id];
        const targetData = {
            id: ruinData.id,
            name: ruinData.name,
            cityName: ruinData.name,
            ownerId: ruinData.ownerId || 'ruins',
            ownerUsername: ruinData.ownerUsername || 'Ancient Guardians',
            x: ruinData.x,
            y: ruinData.y,
            isRuinTarget: true,
            troops: ruinData.troops,
            researchReward: ruinData.researchReward,
            isConqueredByYou: !!isConqueredByYou
        };
        openModal('city', targetData);
    };

    return { onCitySlotClick, onVillageClick, onRuinClick };
};
</file>

<file path="src/hooks/usemapdatapls.js">
import { useState, useEffect, useCallback, useRef } from 'react';
import { collection, query, where, onSnapshot } from 'firebase/firestore';
import { db } from '../firebase/config';

const CHUNK_SIZE = 10;
const TILE_SIZE = 32;

export const useMapData = (currentUser, worldId, worldState, pan, zoom, viewportSize) => {
    const [cachedData, setCachedData] = useState({});
    const [visibleSlots, setVisibleSlots] = useState({});
    const [visibleVillages, setVisibleVillages] = useState({});
    const [visibleRuins, setVisibleRuins] = useState({});
    const activeListenersRef = useRef({});

    const invalidateChunkCache = useCallback((x, y) => {
        const chunkX = Math.floor(x / CHUNK_SIZE);
        const chunkY = Math.floor(y / CHUNK_SIZE);
        const chunkKey = `${chunkX},${chunkY}`;
        setCachedData(prevCache => {
            const newCache = { ...prevCache };
            delete newCache[chunkKey];
            return newCache;
        });
    }, []);

    useEffect(() => {
        // #comment Cleanup all listeners on unmount
        return () => {
            Object.values(activeListenersRef.current).forEach(unsubArray => {
                if (Array.isArray(unsubArray)) {
                    unsubArray.forEach(unsub => unsub());
                }
            });
            activeListenersRef.current = {};
        };
    }, []);

    useEffect(() => {
        if (!worldState || viewportSize.width === 0 || zoom <= 0 || !worldId) {
            return;
        }

        const scaledTileSize = TILE_SIZE * zoom;
        const viewStartCol = Math.floor(-pan.x / scaledTileSize) - 1;
        const viewEndCol = Math.ceil((-pan.x + viewportSize.width) / scaledTileSize) + 1;
        const viewStartRow = Math.floor(-pan.y / scaledTileSize) - 1;
        const viewEndRow = Math.ceil((-pan.y + viewportSize.height) / scaledTileSize) + 1;

        const requiredChunks = new Set();
        for (let y = viewStartRow; y <= viewEndRow; y++) {
            for (let x = viewStartCol; x <= viewEndCol; x++) {
                const chunkKey = `${Math.floor(x / CHUNK_SIZE)},${Math.floor(y / CHUNK_SIZE)}`;
                requiredChunks.add(chunkKey);
            }
        }

        // Unsubscribe from chunks that are no longer visible
        Object.keys(activeListenersRef.current).forEach(chunkKey => {
            if (!requiredChunks.has(chunkKey)) {
                activeListenersRef.current[chunkKey].forEach(unsub => unsub());
                delete activeListenersRef.current[chunkKey];
            }
        });

        // Subscribe to new visible chunks
        requiredChunks.forEach(chunkKey => {
            if (!activeListenersRef.current[chunkKey]) {
                const [chunkX, chunkY] = chunkKey.split(',').map(Number);
                const collectionsToFetch = ['citySlots', 'villages', 'ruins'];
                const unsubscribers = [];

                collectionsToFetch.forEach(colName => {
                    const q = query(
                        collection(db, 'worlds', worldId, colName),
                        where('x', '>=', chunkX * CHUNK_SIZE), where('x', '<', (chunkX + 1) * CHUNK_SIZE),
                        where('y', '>=', chunkY * CHUNK_SIZE), where('y', '<', (chunkY + 1) * CHUNK_SIZE)
                    );

                    const unsubscribe = onSnapshot(q, (snapshot) => {
                        const chunkData = {};
                        snapshot.forEach(doc => {
                            chunkData[doc.id] = { id: doc.id, ...doc.data() };
                        });
                        setCachedData(prevCache => ({
                            ...prevCache,
                            [chunkKey]: {
                                ...prevCache[chunkKey],
                                [colName]: chunkData
                            }
                        }));
                    }, (error) => {
                        console.error(`Error fetching ${colName} for chunk ${chunkKey}:`, error);
                    });
                    unsubscribers.push(unsubscribe);
                });
                activeListenersRef.current[chunkKey] = unsubscribers;
            }
        });

    }, [pan, zoom, viewportSize, worldState, worldId]);
    
    useEffect(() => {
        if (viewportSize.width === 0) return;

        const scaledTileSize = TILE_SIZE * zoom;
        const viewStartCol = Math.floor(-pan.x / scaledTileSize);
        const viewEndCol = Math.ceil((-pan.x + viewportSize.width) / scaledTileSize);
        const viewStartRow = Math.floor(-pan.y / scaledTileSize);
        const viewEndRow = Math.ceil((-pan.y + viewportSize.height) / scaledTileSize);

        const newVisibleSlots = {};
        const newVisibleVillages = {};
        const newVisibleRuins = {};

        Object.values(cachedData).forEach(chunk => {
            Object.values(chunk.citySlots || {}).forEach(slot => {
                if (slot.x >= viewStartCol && slot.x <= viewEndCol && slot.y >= viewStartRow && slot.y <= viewEndRow) {
                    newVisibleSlots[slot.id] = slot;
                }
            });
            Object.values(chunk.villages || {}).forEach(village => {
                if (village.x >= viewStartCol && village.x <= viewEndCol && village.y >= viewStartRow && village.y <= viewEndRow) {
                    newVisibleVillages[village.id] = village;
                }
            });
            Object.values(chunk.ruins || {}).forEach(ruin => {
                if (ruin.x >= viewStartCol && ruin.x <= viewEndCol && ruin.y >= viewStartRow && ruin.y <= viewEndRow) {
                    newVisibleRuins[ruin.id] = ruin;
                }
            });
        });
        setVisibleSlots(newVisibleSlots);
        setVisibleVillages(newVisibleVillages);
        setVisibleRuins(newVisibleRuins);

    }, [cachedData, pan, zoom, viewportSize]);


    return {
        visibleSlots,
        visibleVillages,
        visibleRuins,
        invalidateChunkCache
    };
};
</file>

<file path="src/hooks/useMapEvents.js">
// src/hooks/useMapEvents.js
import { useEffect } from 'react';
import { db } from '../firebase/config';
import { collection, onSnapshot, query, where } from 'firebase/firestore';

/**
 * #comment Manages event listeners and side effects for the MapView.
 */
export const useMapEvents = (currentUser, worldId, setUnreadReportsCount, setUnreadMessagesCount) => {
    useEffect(() => {
        if (!currentUser || !worldId) return;

        // #comment Listener for unread reports
        const reportsQuery = query(collection(db, 'users', currentUser.uid, 'worlds', worldId, 'reports'), where('read', '==', false));
        const unsubscribeReports = onSnapshot(reportsQuery, (snapshot) => {
            setUnreadReportsCount(snapshot.size);
        });

        // #comment Listener for unread messages
        const conversationsQuery = query(
            collection(db, 'worlds', worldId, 'conversations'),
            where('participants', 'array-contains', currentUser.uid)
        );
        const unsubscribeMessages = onSnapshot(conversationsQuery, (snapshot) => {
            let unreadCount = 0;
            snapshot.forEach(doc => {
                const convo = doc.data();
                if (convo.lastMessage && convo.lastMessage.senderId !== currentUser.uid && !convo.readBy.includes(currentUser.uid)) {
                    unreadCount++;
                }
            });
            setUnreadMessagesCount(unreadCount);
        });

        return () => {
            unsubscribeReports();
            unsubscribeMessages();
        };
    }, [currentUser, worldId, setUnreadReportsCount, setUnreadMessagesCount]);
};
</file>

<file path="src/hooks/useMapInteraction.js">
// src/hooks/useMapInteraction.js
import { useState, useCallback, useEffect } from 'react';

const TILE_SIZE = 32;
const OVERSCROLL_AMOUNT = 0;

export const useMapInteraction = (viewportRef, mapContainerRef, worldState, playerCity) => {
    const [pan, setPan] = useState({ x: 0, y: 0 });
    const [zoom, setZoom] = useState(0.15);
    const [minZoom, setMinZoom] = useState(0.15);
    const [isPanning, setIsPanning] = useState(false);
    const [startPos, setStartPos] = useState({ x: 0, y: 0 });
    const [borderOpacity, setBorderOpacity] = useState({ top: 0, bottom: 0, left: 0, right: 0 });
    const [viewportSize, setViewportSize] = useState({ width: 0, height: 0 });

    const clampPan = useCallback((newPan, currentZoom) => {
        if (!viewportRef.current || !worldState?.islands) return newPan;
        const mapWidth = worldState.width * TILE_SIZE;
        const mapHeight = worldState.height * TILE_SIZE;
        const { clientWidth: viewportWidth, clientHeight: viewportHeight } = viewportRef.current;
        const minX = viewportWidth - mapWidth * currentZoom;
        const minY = viewportHeight - mapHeight * currentZoom;

        setBorderOpacity({
            left: Math.max(0, Math.min(1, newPan.x / OVERSCROLL_AMOUNT)),
            right: Math.max(0, Math.min(1, (minX - newPan.x) / OVERSCROLL_AMOUNT)),
            top: Math.max(0, Math.min(1, newPan.y / OVERSCROLL_AMOUNT)),
            bottom: Math.max(0, Math.min(1, (minY - newPan.y) / OVERSCROLL_AMOUNT)),
        });

        return {
            x: Math.min(OVERSCROLL_AMOUNT, Math.max(minX - OVERSCROLL_AMOUNT, newPan.x)),
            y: Math.min(OVERSCROLL_AMOUNT, Math.max(minY - OVERSCROLL_AMOUNT, newPan.y)),
        };
    }, [worldState, viewportRef]);

    const goToCoordinates = useCallback((x, y) => {
        if (!viewportRef.current) return;
        const { clientWidth: viewportWidth, clientHeight: viewportHeight } = viewportRef.current;
        const targetX = -x * TILE_SIZE * zoom + (viewportWidth / 2) - (TILE_SIZE * zoom / 2);
        const targetY = -y * TILE_SIZE * zoom + (viewportHeight / 2) - (TILE_SIZE * zoom / 2);
        const newPan = clampPan({ x: targetX, y: targetY }, zoom);
        setPan(newPan);
    }, [zoom, clampPan, viewportRef]);

    const centerOnCity = useCallback(() => {
        if (playerCity) {
            goToCoordinates(playerCity.x, playerCity.y);
        }
    }, [playerCity, goToCoordinates]);


    useEffect(() => {
        const viewport = viewportRef.current;
        if (!viewport || !worldState?.islands) return;
        const handleResize = () => {
            setViewportSize({ width: viewport.clientWidth, height: viewport.clientHeight });
            const newMinZoom = Math.max(
                viewport.clientWidth / (worldState.width * TILE_SIZE),
                viewport.clientHeight / (worldState.height * TILE_SIZE),
                0.15
            );
            setMinZoom(newMinZoom);
            setZoom(prevZoom => Math.max(newMinZoom, prevZoom));
        };
        handleResize();
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, [worldState, viewportRef]);

    // #comment This effect now only runs when the active city changes, preventing the map from resetting during panning.
    useEffect(() => {
        if (playerCity) {
            centerOnCity();
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [playerCity?.id]);


    useEffect(() => {
        const container = mapContainerRef.current;
        if (container) {
            container.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`;
        }
    }, [pan, zoom, mapContainerRef]);

    const handleWheel = useCallback((e) => {
        if (!viewportRef.current) return;
        e.preventDefault();
        const scaleAmount = -e.deltaY * 0.002;
        const newZoom = Math.max(minZoom, Math.min(3, zoom + scaleAmount));
        const rect = viewportRef.current.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const pointX = (mouseX - pan.x) / zoom;
        const pointY = (mouseY - pan.y) / zoom;
        const newPan = clampPan({ x: mouseX - pointX * newZoom, y: mouseY - pointY * newZoom }, newZoom);
        setZoom(newZoom);
        setPan(newPan);
    }, [zoom, pan, clampPan, minZoom, viewportRef]);


    useEffect(() => {
        const viewport = viewportRef.current;
        if (viewport) {
            viewport.addEventListener('wheel', handleWheel, { passive: false });
        }
        return () => {
            if (viewport) {
                viewport.removeEventListener('wheel', handleWheel);
            }
        };
    }, [handleWheel, viewportRef]);


    const handleMouseDown = useCallback((e) => {
        if (e.button !== 0) return;
        setStartPos({ x: e.clientX - pan.x, y: e.clientY - pan.y });
        setIsPanning(true);
    }, [pan]);

    useEffect(() => {
        const handleMouseMove = (e) => {
            if (!isPanning) return;
            const newPan = clampPan({ x: e.clientX - startPos.x, y: e.clientY - startPos.y }, zoom);
            setPan(newPan);
        };
        const handleMouseUp = () => setIsPanning(false);

        if (isPanning) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        }

        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isPanning, startPos, zoom, clampPan]);


    return {
        pan,
        zoom,
        viewportSize,
        borderOpacity,
        isPanning,
        handleMouseDown,
        goToCoordinates,
        centerOnCity
    };
};
</file>

<file path="src/hooks/useMapState.js">
// src/hooks/useMapState.js
import { useState } from 'react';

/**
 * #comment Manages local state for the MapView component.
 */
export const useMapState = () => {
    const [isPlacingDummyCity, setIsPlacingDummyCity] = useState(false);
    const [unreadReportsCount, setUnreadReportsCount] = useState(0);
    const [unreadMessagesCount, setUnreadMessagesCount] = useState(0);
    const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);

    return {
        isPlacingDummyCity,
        setIsPlacingDummyCity,
        unreadReportsCount,
        setUnreadReportsCount,
        unreadMessagesCount,
        setUnreadMessagesCount,
        isSettingsModalOpen,
        setIsSettingsModalOpen,
    };
};
</file>

<file path="src/hooks/useModalState.js">
import { useState } from 'react';

// #comment Manages the state of all modals in the map view.
export const useModalState = () => {
    const [modalState, setModalState] = useState({
        selectedCity: null,
        selectedVillage: null,
        actionDetails: null,
        isMovementsPanelOpen: false,
        isReportsPanelOpen: false,
        isAllianceModalOpen: false,
        isAllianceCreationOpen: false,
        isMessagesPanelOpen: false,
        isDivinePowersOpen: false,
        divinePowersTarget: null,
        isProfileModalOpen: false,
        isAllianceForumOpen: false,
        isLeaderboardOpen: false,
        isAllianceProfileOpen: false,
        isQuestsModalOpen: false,
        isSettingsModalOpen: false,
        isRecruitmentPanelOpen: false,
        isTradesPanelOpen: false,
        isWithdrawModalOpen: false,
        withdrawModalData: null,
        isReinforcementsModalOpen: false,
        reinforcementsModalData: null,
        isEventTriggerOpen: false,
        viewingProfileId: null,
        viewingAllianceId: null,
        isEmptyCityModalOpen: false,
        emptyCityModalData: null,
    });

    // #comment Opens a modal of a given type with optional data.
    const openModal = (type, data) => {
        setModalState(prevState => {
            switch (type) {
                case 'city': return { ...prevState, selectedCity: data };
                case 'village': return { ...prevState, selectedVillage: data };
                case 'action': return { ...prevState, actionDetails: data };
                case 'movements': return { ...prevState, isMovementsPanelOpen: true };
                case 'reports': return { ...prevState, isReportsPanelOpen: true };
                case 'alliance': return { ...prevState, isAllianceModalOpen: true };
                case 'allianceCreation': return { ...prevState, isAllianceCreationOpen: true };
                case 'messages': return { ...prevState, isMessagesPanelOpen: true };
                case 'divinePowers': return { ...prevState, isDivinePowersOpen: true, divinePowersTarget: data?.targetCity || null };
                case 'profile': return { ...prevState, isProfileModalOpen: true, viewingProfileId: data?.userId || null };
                case 'allianceForum': return { ...prevState, isAllianceForumOpen: true };
                case 'leaderboard': return { ...prevState, isLeaderboardOpen: true };
                case 'allianceProfile': return { ...prevState, isAllianceProfileOpen: true, viewingAllianceId: data?.allianceId || null };
                case 'quests': return { ...prevState, isQuestsModalOpen: true };
                case 'settings': return { ...prevState, isSettingsModalOpen: true };
                case 'recruitment': return { ...prevState, isRecruitmentPanelOpen: true };
                case 'trades': return { ...prevState, isTradesPanelOpen: true };
                case 'eventTrigger': return { ...prevState, isEventTriggerOpen: true };
                case 'withdraw': return { ...prevState, isWithdrawModalOpen: true, withdrawModalData: data };
                case 'reinforcements': return { ...prevState, isReinforcementsModalOpen: true, reinforcementsModalData: data };
                case 'emptyCity': return { ...prevState, isEmptyCityModalOpen: true, emptyCityModalData: data };
                default: return prevState;
            }
        });
    };

    // #comment Closes a modal of a given type.
    const closeModal = (type) => {
        setModalState(prevState => {
            switch (type) {
                case 'city': return { ...prevState, selectedCity: null };
                case 'village': return { ...prevState, selectedVillage: null };
                case 'action': return { ...prevState, actionDetails: null };
                case 'movements': return { ...prevState, isMovementsPanelOpen: false };
                case 'reports': return { ...prevState, isReportsPanelOpen: false };
                case 'alliance': return { ...prevState, isAllianceModalOpen: false };
                case 'allianceCreation': return { ...prevState, isAllianceCreationOpen: false };
                case 'messages': return { ...prevState, isMessagesPanelOpen: false };
                case 'divinePowers': return { ...prevState, isDivinePowersOpen: false, divinePowersTarget: null };
                case 'profile': return { ...prevState, isProfileModalOpen: false, viewingProfileId: null };
                case 'allianceForum': return { ...prevState, isAllianceForumOpen: false };
                case 'leaderboard': return { ...prevState, isLeaderboardOpen: false };
                case 'allianceProfile': return { ...prevState, isAllianceProfileOpen: false, viewingAllianceId: null };
                case 'quests': return { ...prevState, isQuestsModalOpen: false };
                case 'settings': return { ...prevState, isSettingsModalOpen: false };
                case 'recruitment': return { ...prevState, isRecruitmentPanelOpen: false };
                case 'trades': return { ...prevState, isTradesPanelOpen: false };
                case 'eventTrigger': return { ...prevState, isEventTriggerOpen: false };
                case 'withdraw': return { ...prevState, isWithdrawModalOpen: false, withdrawModalData: null };
                case 'reinforcements': return { ...prevState, isReinforcementsModalOpen: false, reinforcementsModalData: null };
                case 'emptyCity': return { ...prevState, isEmptyCityModalOpen: false, emptyCityModalData: null };
                default: return prevState;
            }
        });
    };

    return {
        modalState,
        openModal,
        closeModal,
    };
};
</file>

<file path="src/hooks/useMovementProcessor.js">
import { useEffect, useCallback } from 'react';
import { db } from '../firebase/config';
import { collection, query, where, getDocs, writeBatch, doc, getDoc, serverTimestamp, runTransaction, arrayUnion, deleteDoc, updateDoc } from 'firebase/firestore';
import { resolveCombat, resolveScouting, getVillageTroops } from '../utils/combat';
import { useCityState } from './useCityState';
import unitConfig from '../gameData/units.json';
import buildingConfig from '../gameData/buildings.json';
import { v4 as uuidv4 } from 'uuid';

const getWarehouseCapacity = (level) => {
    if (!level) return 0;
    return Math.floor(1500 * Math.pow(1.4, level - 1));
};

export const useMovementProcessor = (worldId) => {
    const { getHospitalCapacity } = useCityState(worldId);

    const processMovement = useCallback(async (movementDoc) => {
        console.log(`Processing movement ID: ${movementDoc.id}`);
        const movement = { id: movementDoc.id, ...movementDoc.data() };

        // #comment Handle hero assignment first as it has no origin city
        if (movement.type === 'assign_hero') {
            const targetCityRef = doc(db, `users/${movement.targetOwnerId}/games`, worldId, 'cities', movement.targetCityId);
            try {
                await runTransaction(db, async (transaction) => {
                    const cityDoc = await transaction.get(targetCityRef);
                    if (!cityDoc.exists()) throw new Error("Target city not found.");
    
                    const cityData = cityDoc.data();
                    const heroes = cityData.heroes || {};
                    const newHeroes = { ...heroes, [movement.hero]: { ...heroes[movement.hero], cityId: movement.targetCityId } };
    
                    transaction.update(targetCityRef, { heroes: newHeroes });
                    transaction.delete(movementDoc.ref);
                });
            } catch (error) {
                console.error("Error processing hero assignment:", error);
                await deleteDoc(movementDoc.ref);
            }
            return; // End processing for this movement
        }
        
        const originCityRef = doc(db, `users/${movement.originOwnerId}/games`, worldId, 'cities', movement.originCityId);

        let targetCityRef;
        if (movement.targetOwnerId && movement.targetCityId) {
            targetCityRef = doc(db, `users/${movement.targetOwnerId}/games`, worldId, 'cities', movement.targetCityId);
        }

        // #comment Handle city founding movements
        if (movement.type === 'found_city') {
            const targetSlotRef = doc(db, 'worlds', worldId, 'citySlots', movement.targetSlotId);

            if (movement.status === 'moving') {
                // Troops have arrived, now start the founding timer.
                const newArrivalTime = new Date(Date.now() + movement.foundingTimeSeconds * 1000);
                await updateDoc(movementDoc.ref, {
                    status: 'founding',
                    arrivalTime: newArrivalTime,
                });
                return; // Stop processing, wait for founding to finish
            }

            if (movement.status === 'founding') {
                const newCityDocRef = doc(collection(db, `users/${movement.originOwnerId}/games`, worldId, 'cities'));
                try {
                    await runTransaction(db, async (transaction) => {
                        const [targetSlotSnap, originCitySnap] = await Promise.all([
                            transaction.get(targetSlotRef),
                            transaction.get(originCityRef)
                        ]);
                        if (!originCitySnap.exists()) {
                            transaction.delete(movementDoc.ref);
                            return;
                        }
                        if (!targetSlotSnap.exists() || targetSlotSnap.data().ownerId !== null) {
                            const travelDuration = movement.arrivalTime.toMillis() - movement.departureTime.toMillis();
                            const returnArrivalTime = new Date(movement.arrivalTime.toDate().getTime() + travelDuration);
                            transaction.update(movementDoc.ref, {
                                status: 'returning',
                                units: movement.units,
                                agent: movement.agent,
                                arrivalTime: returnArrivalTime,
                                involvedParties: [movement.originOwnerId]
                            });
                            const failureReport = {
                                type: 'found_city_failed',
                                title: `Founding attempt failed`,
                                timestamp: serverTimestamp(),
                                outcome: { message: `The plot at (${movement.targetCoords.x}, ${movement.targetCoords.y}) was claimed by another player before your party arrived.` },
                                read: false,
                            };
                            transaction.set(doc(collection(db, `users/${movement.originOwnerId}/worlds/${worldId}/reports`)), failureReport);
                            return;
                        }
                        const originCityData = originCitySnap.data();
                        const newCityName = movement.newCityName;
                        transaction.update(targetSlotRef, {
                            ownerId: movement.originOwnerId,
                            ownerUsername: movement.originOwnerUsername,
                            cityName: newCityName,
                            alliance: originCityData.alliance || null,
                            allianceName: originCityData.allianceName || null,
                        });
                        const initialBuildings = {};
                        Object.keys(buildingConfig).forEach(id => {
                            initialBuildings[id] = { level: 0 };
                        });
                        ['senate', 'farm', 'warehouse', 'timber_camp', 'quarry', 'silver_mine', 'cave'].forEach(id => {
                            initialBuildings[id] = { level: 1 };
                        });
                        const newCityData = {
                            id: newCityDocRef.id,
                            slotId: movement.targetSlotId,
                            x: movement.targetCoords.x,
                            y: movement.targetCoords.y,
                            islandId: targetSlotSnap.data().islandId,
                            cityName: newCityName,
                            playerInfo: originCityData.playerInfo,
                            resources: { wood: 1000, stone: 1000, silver: 500 },
                            buildings: initialBuildings,
                            units: movement.units, wounded: {}, research: {}, worship: {},
                            cave: { silver: 0 }, buildQueue: [], barracksQueue: [],
                            shipyardQueue: [], divineTempleQueue: [], healQueue: [],
                            lastUpdated: serverTimestamp(),
                        };
                        transaction.set(newCityDocRef, newCityData);
                        const successReport = {
                            type: 'found_city_success',
                            title: `New city founded!`,
                            timestamp: serverTimestamp(),
                            outcome: { message: `You have successfully founded the city of ${newCityName} at (${movement.targetCoords.x}, ${movement.targetCoords.y}). Your troops have garrisoned the new city.` },
                            read: false,
                        };
                        transaction.set(doc(collection(db, `users/${movement.originOwnerId}/worlds/${worldId}/reports`)), successReport);
                        transaction.delete(movementDoc.ref);
                    });
                } catch (error) {
                    console.error("Error in found_city transaction:", error);
                    await deleteDoc(movementDoc.ref);
                }
                return;
            }
        }


        const batch = writeBatch(db);
        const [originCitySnap, targetCitySnap] = await Promise.all([
            getDoc(originCityRef),
            targetCityRef ? getDoc(targetCityRef) : Promise.resolve(null)
        ]);

        const originGameRef = doc(db, `users/${movement.originOwnerId}/games`, worldId);
        const targetGameRef = movement.targetOwnerId ? doc(db, `users/${movement.targetOwnerId}/games`, worldId) : null;

        const [originGameSnap, targetGameSnap] = await Promise.all([
            getDoc(originGameRef),
            targetGameRef ? getDoc(targetGameRef) : Promise.resolve(null)
        ]);

        const originGameData = originGameSnap.exists() ? originGameSnap.data() : {};
        const targetGameData = targetGameSnap?.exists() ? targetGameSnap.data() : {};

        const originAlliancePromise = originGameData.alliance ? getDoc(doc(db, 'worlds', worldId, 'alliances', originGameData.alliance)) : Promise.resolve(null);
        const targetAlliancePromise = targetGameData.alliance ? getDoc(doc(db, 'worlds', worldId, 'alliances', targetGameData.alliance)) : Promise.resolve(null);
        const [originAllianceSnap, targetAllianceSnap] = await Promise.all([originAlliancePromise, targetAlliancePromise]);
        const originAllianceData = originAllianceSnap?.exists() ? {id: originAllianceSnap.id, name: originAllianceSnap.data().name} : null;
        const targetAllianceData = targetAllianceSnap?.exists() ? {id: targetAllianceSnap.id, name: targetAllianceSnap.data().name} : null;

        if (!originCitySnap.exists()) {
            console.log(`Origin city ${movement.originOwnerId} for owner ${movement.originOwnerId} not found. Deleting movement.`);
            batch.delete(movementDoc.ref);
            await batch.commit();
            return;
        }

        const originCityState = originCitySnap.data();

        if (movement.status === 'returning') {
            console.log(`Movement ${movement.id} is returning.`);
            const newCityState = { ...originCityState };
            const newUnits = { ...newCityState.units };
            for (const unitId in movement.units) {
                newUnits[unitId] = (newUnits[unitId] || 0) + movement.units[unitId];
            }
            // #comment Return agent if it exists in the movement
            if (movement.agent) {
                const newAgents = { ...(newCityState.agents || {}) };
                newAgents[movement.agent] = (newAgents[movement.agent] || 0) + 1;
                batch.update(originCityRef, { agents: newAgents });
            }

            // #comment When a hero returns, update their status across ALL of the owner's cities.
            if (movement.hero) {
                const heroOwnerCitiesRef = collection(db, `users/${movement.originOwnerId}/games`, worldId, 'cities');
                const heroOwnerCitiesSnap = await getDocs(heroOwnerCitiesRef);

                heroOwnerCitiesSnap.forEach(cityDoc => {
                    const cityData = cityDoc.data();
                    const heroes = cityData.heroes || {};
                    if (heroes[movement.hero]) {
                        const newHeroes = { ...heroes };
                        const heroState = newHeroes[movement.hero];
                        
                        // #comment Update hero state: assign to city, clear negative statuses.
                        heroState.cityId = movement.originCityId;
                        delete heroState.capturedIn;
                        delete heroState.woundedUntil;

                        batch.update(cityDoc.ref, { heroes: newHeroes });
                    }
                });
            }

            const capacity = getWarehouseCapacity(newCityState.buildings.warehouse?.level);
            const newResources = { ...newCityState.resources };

            if (movement.resources) {
                for (const resourceId in movement.resources) {
                    newResources[resourceId] = (newResources[resourceId] || 0) + movement.resources[resourceId];
                }
            }
            newResources.wood = Math.min(capacity, newResources.wood || 0);
            newResources.stone = Math.min(capacity, newResources.stone || 0);
            newResources.silver = Math.min(capacity, newResources.silver || 0);

            const newWounded = { ...newCityState.wounded };
            let totalWoundedInHospital = Object.values(newWounded).reduce((sum, count) => sum + count, 0);
            const hospitalCapacity = getHospitalCapacity(newCityState.buildings.hospital?.level || 0);

            if (movement.wounded) {
                for (const unitId in movement.wounded) {
                    const woundedCount = movement.wounded[unitId];
                    if (totalWoundedInHospital < hospitalCapacity) {
                        const canFit = hospitalCapacity - totalWoundedInHospital;
                        const toHeal = Math.min(canFit, woundedCount);
                        newWounded[unitId] = (newWounded[unitId] || 0) + toHeal;
                        totalWoundedInHospital += toHeal;
                    }
                }
            }

             const returnReport = {
                type: 'return',
                title: `Troops returned to ${originCityState.cityName}`,
                timestamp: serverTimestamp(),
                units: movement.units || {},
                hero: movement.hero || null,
                resources: movement.resources || {},
                wounded: movement.wounded || {},
                read: false,
            };

            batch.set(doc(collection(db, `users/${movement.originOwnerId}/worlds/${worldId}/reports`)), returnReport);
            batch.update(originCityRef, { units: newUnits, resources: newResources, wounded: newWounded });
            batch.delete(movementDoc.ref);
            await batch.commit();
            console.log(`Movement ${movement.id} processed and deleted.`);
        } else if (movement.status === 'moving') {
            console.log(`Movement ${movement.id} is moving with type: ${movement.type}`);
            const targetCityState = targetCitySnap?.exists() ? targetCitySnap.data() : null;
            switch (movement.type) {
                case 'attack_god_town': {
                    console.log(`Processing God Town attack: ${movement.id}`);
                    const townRef = doc(db, 'worlds', worldId, 'godTowns', movement.targetTownId);
                    const townSnap = await getDoc(townRef);
                    if (!townSnap.exists() || townSnap.data().stage !== 'city') {
                        const travelDuration = movement.arrivalTime.toMillis() - movement.departureTime.toMillis();
                        const returnArrivalTime = new Date(movement.arrivalTime.toDate().getTime() + travelDuration);
                        batch.update(movementDoc.ref, {
                            status: 'returning',
                            arrivalTime: returnArrivalTime,
                            involvedParties: [movement.originOwnerId]
                        });
                        break;
                    }
                    const townData = townSnap.data();
                    const combatResult = resolveCombat(movement.units, townData.troops, {}, false);
                    const damageDealt = Object.values(combatResult.defenderLosses).reduce((sum, count) => sum + count, 0) * 5;
                    const newHealth = Math.max(0, (townData.health || 10000) - damageDealt);
                    const warPoints = Math.floor(damageDealt / 10);
                    const resourcesWon = {
                        wood: warPoints * 10,
                        stone: warPoints * 10,
                        silver: warPoints * 5
                    };
                    const playerProgressRef = doc(db, 'worlds', worldId, 'godTowns', movement.targetTownId, 'playerProgress', movement.originOwnerId);
                    const playerProgressSnap = await getDoc(playerProgressRef);
                    const currentDamage = playerProgressSnap.exists() ? playerProgressSnap.data().damageDealt : 0;
                    batch.set(playerProgressRef, { damageDealt: currentDamage + damageDealt }, { merge: true });
                    const attackerReport = {
                        type: 'attack_god_town',
                        title: `Attack on ${townData.name}`,
                        timestamp: serverTimestamp(),
                        outcome: combatResult,
                        rewards: { warPoints, resources: resourcesWon },
                        read: false,
                    };
                    if (newHealth === 0) {
                        batch.delete(townRef);
                        attackerReport.rewards.message = "You have vanquished the City of the Gods! It has vanished from the world.";
                    } else {
                        const newTroops = { ...townData.troops };
                        for (const unitId in combatResult.defenderLosses) {
                            newTroops[unitId] = Math.max(0, (newTroops[unitId] || 0) - combatResult.defenderLosses[unitId]);
                        }
                        batch.update(townRef, { health: newHealth, troops: newTroops });
                    }
                    batch.set(doc(collection(db, `users/${movement.originOwnerId}/worlds/${worldId}/reports`)), attackerReport);
                    const survivingAttackers = {};
                    for (const unitId in movement.units) {
                        const survivors = movement.units[unitId] - (combatResult.attackerLosses[unitId] || 0);
                        if (survivors > 0) survivingAttackers[unitId] = survivors;
                    }
                    const travelDuration = movement.arrivalTime.toMillis() - movement.departureTime.toMillis();
                    const returnArrivalTime = new Date(movement.arrivalTime.toDate().getTime() + travelDuration);
                    batch.update(movementDoc.ref, {
                        status: 'returning',
                        units: survivingAttackers,
                        resources: resourcesWon,
                        arrivalTime: returnArrivalTime,
                        involvedParties: [movement.originOwnerId]
                    });
                    await batch.commit();
                    break;
                }
                case 'attack_village': {
                    console.log(`Processing village attack: ${movement.id}`);
                    const villageRef = doc(db, 'worlds', worldId, 'villages', movement.targetVillageId);
                    const villageSnap = await getDoc(villageRef);
                    if (!villageSnap.exists()) {
                        console.log(`Village ${movement.targetVillageId} not found.`);
                        batch.delete(movementDoc.ref);
                        const report = {
                            type: 'attack_village',
                            title: `Attack on missing village`,
                            timestamp: serverTimestamp(),
                            outcome: { message: 'The village was no longer there.' },
                            read: false,
                        };
                        batch.set(doc(collection(db, `users/${movement.originOwnerId}/worlds/${worldId}/reports`)), report);
                        break;
                    }
                    const villageData = villageSnap.data();
                    const villageTroops = getVillageTroops(villageData);
                    const result = resolveCombat(movement.units, villageTroops, villageData.resources, false);
                    console.log('Village combat resolved:', result);
                    if (result.attackerWon) {
                        console.log('Attacker won. Conquering/farming village.');
                        const playerVillageRef = doc(db, `users/${movement.originOwnerId}/games/${worldId}/conqueredVillages`, movement.targetVillageId);
                        batch.set(playerVillageRef, {
                            level: villageData.level,
                            lastCollected: serverTimestamp(),
                            happiness: 100,
                            happinessLastUpdated: serverTimestamp()
                        }, { merge: true });
                    }
                    const reportOutcome = { ...result };
                    delete reportOutcome.attackerBattlePoints;
                    delete reportOutcome.defenderBattlePoints;
                    const attackerReport = {
                        type: 'attack_village',
                        title: `Attack on ${villageData.name}`,
                        timestamp: serverTimestamp(),
                        outcome: reportOutcome,
                        attacker: {
                            cityId: movement.originCityId,
                            cityName: originCityState.cityName,
                            units: movement.units,
                            losses: result.attackerLosses,
                            ownerId: movement.originOwnerId,
                            username: movement.originOwnerUsername || 'Unknown Player',
                            allianceId: originAllianceData ? originAllianceData.id : null,
                            allianceName: originAllianceData ? originAllianceData.name : null,
                            x: originCityState.x,
                            y: originCityState.y
                        },
                        defender: {
                            villageId: movement.targetVillageId,
                            villageName: villageData.name,
                            troops: villageTroops,
                            losses: result.defenderLosses,
                            x: villageData.x,
                            y: villageData.y
                        },
                        read: false,
                    };
                    batch.set(doc(collection(db, `users/${movement.originOwnerId}/worlds/${worldId}/reports`)), attackerReport);
                    const survivingAttackers = {};
                    let anySurvivors = false;
                    for (const unitId in movement.units) {
                        const survivors = movement.units[unitId] - (result.attackerLosses[unitId] || 0) - (result.wounded[unitId] || 0);
                        if (survivors > 0) {
                            survivingAttackers[unitId] = survivors;
                            anySurvivors = true;
                        }
                    }
                    if (anySurvivors || Object.keys(result.wounded).length > 0) {
                        console.log('Survivors/wounded are returning.');
                        const travelDuration = movement.arrivalTime.toMillis() - movement.departureTime.toMillis();
                        const returnArrivalTime = new Date(movement.arrivalTime.toDate().getTime() + travelDuration);
                        batch.update(movementDoc.ref, {
                            status: 'returning',
                            units: survivingAttackers,
                            resources: result.plunder,
                            wounded: result.wounded,
                            arrivalTime: returnArrivalTime,
                            involvedParties: [movement.originOwnerId]
                        });
                    } else {
                        console.log('No survivors. Deleting movement.');
                        batch.delete(movementDoc.ref);
                    }
                    await batch.commit();
                    break;
                }
                case 'attack_ruin': {
                    console.log(`Processing ruin attack: ${movement.id}`);
                    const ruinRef = doc(db, 'worlds', worldId, 'ruins', movement.targetRuinId);
                    const ruinSnap = await getDoc(ruinRef);
                    if (!ruinSnap.exists()) {
                        console.log(`Ruin ${movement.targetRuinId} not found.`);
                        batch.delete(movementDoc.ref);
                        const report = {
                            type: 'attack_ruin',
                            title: `Attack on vanished ruins`,
                            timestamp: serverTimestamp(),
                            outcome: { message: 'The ruins crumbled into the sea before your fleet arrived.' },
                            read: false,
                        };
                        batch.set(doc(collection(db, `users/${movement.originOwnerId}/worlds/${worldId}/reports`)), report);
                        break;
                    }
                    const ruinData = ruinSnap.data();
                    if (ruinData.ownerId) {
                        batch.delete(movementDoc.ref);
                        break;
                    }
                    const result = resolveCombat(movement.units, ruinData.troops, {}, true);
                    if (result.attackerBattlePoints > 0) {
                        const attackerGameRef = doc(db, `users/${movement.originOwnerId}/games`, worldId);
                        const attackerGameDoc = await getDoc(attackerGameRef);
                        if (attackerGameDoc.exists()) {
                            const currentPoints = attackerGameDoc.data().battlePoints || 0;
                            batch.update(attackerGameRef, { battlePoints: currentPoints + result.attackerBattlePoints });
                        }
                    }
                    if (result.attackerWon) {
                        const newCityState = { ...originCityState };
                        if (!newCityState.research) newCityState.research = {};
                        newCityState.research[ruinData.researchReward] = true;
                        batch.update(originCityRef, { research: newCityState.research });
                        batch.update(ruinRef, {
                            ownerId: movement.originOwnerId,
                            ownerUsername: movement.originOwnerUsername
                        });
                        const playerRuinRef = doc(db, `users/${movement.originOwnerId}/games/${worldId}/conqueredRuins`, movement.targetRuinId);
                        batch.set(playerRuinRef, {
                            conqueredAt: serverTimestamp(),
                            researchReward: ruinData.researchReward
                        });
                    } else {
                        const survivingRuinTroops = { ...ruinData.troops };
                        for (const unitId in result.defenderLosses) {
                            survivingRuinTroops[unitId] = Math.max(0, (survivingRuinTroops[unitId] || 0) - result.defenderLosses[unitId]);
                        }
                        batch.update(ruinRef, { troops: survivingRuinTroops });
                    }
                    const attackerReport = {
                        type: 'attack_ruin',
                        title: `Attack on ${ruinData.name}`,
                        timestamp: serverTimestamp(),
                        outcome: result,
                        attacker: {
                            cityId: movement.originCityId,
                            cityName: originCityState.cityName,
                            units: movement.units,
                            losses: result.attackerLosses,
                            ownerId: movement.originOwnerId,
                            username: movement.originOwnerUsername || 'Unknown Player',
                            allianceId: originAllianceData ? originAllianceData.id : null,
                            allianceName: originAllianceData ? originAllianceData.name : null,
                            x: originCityState.x,
                            y: originCityState.y
                        },
                        defender: {
                            ruinId: movement.targetRuinId,
                            ruinName: ruinData.name,
                            troops: ruinData.troops,
                            losses: result.defenderLosses,
                            x: ruinData.x,
                            y: ruinData.y
                        },
                        reward: result.attackerWon ? ruinData.researchReward : null,
                        read: false,
                    };
                    batch.set(doc(collection(db, `users/${movement.originOwnerId}/worlds/${worldId}/reports`)), attackerReport);
                    const survivingAttackers = {};
                    let anySurvivors = false;
                    for (const unitId in movement.units) {
                        const survivors = movement.units[unitId] - (result.attackerLosses[unitId] || 0) - (result.wounded[unitId] || 0);
                        if (survivors > 0) {
                            survivingAttackers[unitId] = survivors;
                            anySurvivors = true;
                        }
                    }
                    if (anySurvivors || Object.keys(result.wounded).length > 0) {
                        const travelDuration = movement.arrivalTime.toMillis() - movement.departureTime.toMillis();
                        const returnArrivalTime = new Date(movement.arrivalTime.toDate().getTime() + travelDuration);
                        batch.update(movementDoc.ref, {
                            status: 'returning',
                            units: survivingAttackers,
                            wounded: result.wounded,
                            arrivalTime: returnArrivalTime,
                            involvedParties: [movement.originOwnerId]
                        });
                    } else {
                        batch.delete(movementDoc.ref);
                    }
                    await batch.commit();
                    break;
                }
                case 'attack': {
                    if (!targetCityState) {
                        console.log(`Target game state not found for movement ${movement.id}. Deleting.`);
                        batch.delete(movementDoc.ref);
                        break;
                    }
                    const result = resolveCombat(
                        movement.units,
                        targetCityState.units,
                        targetCityState.resources,
                        !!movement.isCrossIsland,
                        movement.attackFormation?.front,
                        movement.attackFormation?.mid,
                        null,
                        null,
                        movement.hero,
                        Object.keys(targetCityState.heroes || {}).find(id => targetCityState.heroes[id].cityId === movement.targetCityId) || null
                    );

                    // #comment This transaction only handles battle points to avoid contention with other updates.
                    await runTransaction(db, async (transaction) => {
                        const attackerGameRef = doc(db, `users/${movement.originOwnerId}/games`, worldId);
                        const defenderGameRef = doc(db, `users/${movement.targetOwnerId}/games`, worldId);
                        const attackerGameDoc = await transaction.get(attackerGameRef);
                        const defenderGameDoc = await transaction.get(defenderGameRef);
                        if (attackerGameDoc.exists() && result.attackerBattlePoints > 0) {
                            const currentPoints = attackerGameDoc.data().battlePoints || 0;
                            transaction.update(attackerGameRef, { battlePoints: currentPoints + result.attackerBattlePoints });
                        }
                        if (defenderGameDoc.exists() && result.defenderBattlePoints > 0) {
                            const currentPoints = defenderGameDoc.data().battlePoints || 0;
                            transaction.update(defenderGameRef, { battlePoints: currentPoints + result.defenderBattlePoints });
                        }
                    });

                    // #comment Helper to update a hero's state across all their owner's cities.
                    const updateGlobalHeroState = async (heroId, ownerId, updates) => {
                        const ownerCitiesRef = collection(db, `users/${ownerId}/games`, worldId, 'cities');
                        const ownerCitiesSnap = await getDocs(ownerCitiesRef);
                        ownerCitiesSnap.forEach(cityDoc => {
                            const cityRef = cityDoc.ref;
                            const heroUpdateData = {};
                            for (const key in updates) {
                                heroUpdateData[`heroes.${heroId}.${key}`] = updates[key];
                            }
                            batch.update(cityRef, heroUpdateData);
                        });
                    };

                    if (result.woundedHero) {
                        const { heroId, side } = result.woundedHero;
                        const woundedUntil = new Date(Date.now() + 12 * 60 * 60 * 1000);
                        const heroOwnerId = side === 'attacker' ? movement.originOwnerId : movement.targetOwnerId;
                        await updateGlobalHeroState(heroId, heroOwnerId, { woundedUntil: woundedUntil, cityId: null });
                    }

                    if (result.capturedHero) {
                        const { heroId, capturedBy } = result.capturedHero;
                        const prisonerObject = {
                            captureId: uuidv4(),
                            heroId,
                        };
                        let wasImprisoned = false;
                        if (capturedBy === 'attacker') {
                            prisonerObject.ownerId = movement.targetOwnerId;
                            prisonerObject.ownerUsername = movement.ownerUsername;
                            prisonerObject.originCityId = movement.targetCityId;
                            prisonerObject.originCityName = movement.targetCityName;
                            prisonerObject.originCityCoords = { x: targetCityState.x, y: targetCityState.y };
                            const prisonLevel = originCityState.buildings.prison?.level || 0;
                            const capacity = prisonLevel > 0 ? prisonLevel + 4 : 0;
                            const currentPrisoners = originCityState.prisoners?.length || 0;
                            if (prisonLevel > 0 && currentPrisoners < capacity) {
                                const newPrisonerObject = { ...prisonerObject, capturedAt: new Date() };
                                batch.update(originCityRef, { prisoners: arrayUnion(newPrisonerObject) });
                                wasImprisoned = true;
                            }
                        } else { // captured by defender
                            prisonerObject.ownerId = movement.originOwnerId;
                            prisonerObject.ownerUsername = movement.originOwnerUsername;
                            prisonerObject.originCityId = movement.originCityId;
                            prisonerObject.originCityName = movement.originCityName;
                            prisonerObject.originCityCoords = { x: originCityState.x, y: originCityState.y };
                            const prisonLevel = targetCityState.buildings.prison?.level || 0;
                            const capacity = prisonLevel > 0 ? prisonLevel + 4 : 0;
                            const currentPrisoners = targetCityState.prisoners?.length || 0;
                            if (prisonLevel > 0 && currentPrisoners < capacity) {
                                const newPrisonerObject = { ...prisonerObject, capturedAt: new Date() };
                                batch.update(targetCityRef, { prisoners: arrayUnion(newPrisonerObject) });
                                wasImprisoned = true;
                            }
                        }
                        if (!wasImprisoned) {
                            result.capturedHero = null;
                        } else {
                            const heroOwnerId = capturedBy === 'attacker' ? movement.targetOwnerId : movement.originOwnerId;
                            const capturingCityId = capturedBy === 'attacker' ? movement.originCityId : movement.targetCityId;
                            await updateGlobalHeroState(heroId, heroOwnerId, { capturedIn: capturingCityId, cityId: null });
                        }
                    }
                    
                    const newDefenderUnits = { ...targetCityState.units };
                    for (const unitId in result.defenderLosses) {
                        newDefenderUnits[unitId] = Math.max(0, (newDefenderUnits[unitId] || 0) - result.defenderLosses[unitId]);
                    }
                    const newDefenderResources = { ...targetCityState.resources };
                    if (result.attackerWon) {
                        newDefenderResources.wood = Math.max(0, newDefenderResources.wood - result.plunder.wood);
                        newDefenderResources.stone = Math.max(0, newDefenderResources.stone - result.plunder.stone);
                        newDefenderResources.silver = Math.max(0, newDefenderResources.silver - result.plunder.silver);
                    }
                    const survivingAttackers = {};
                    for (const unitId in movement.units) {
                        const survivors = movement.units[unitId] - (result.attackerLosses[unitId] || 0) - (result.wounded[unitId] || 0);
                        if (survivors > 0) {
                            survivingAttackers[unitId] = survivors;
                        }
                    }
                    const hasSurvivingLandOrMythic = Object.keys(survivingAttackers).some(unitId => {
                        const unit = unitConfig[unitId];
                        return unit && (unit.type === 'land' || unit.mythical);
                    });
                    const attackerReport = {
                        type: 'attack',
                        title: `Attack on ${targetCityState.cityName}`,
                        timestamp: serverTimestamp(),
                        outcome: result,
                        attacker: {
                            cityId: movement.originCityId,
                            cityName: originCityState.cityName,
                            units: movement.units,
                            hero: movement.hero || null,
                            losses: result.attackerLosses,
                            ownerId: movement.originOwnerId,
                            username: movement.originOwnerUsername || 'Unknown Player',
                            allianceId: originAllianceData ? originAllianceData.id : null,
                            allianceName: originAllianceData ? originAllianceData.name : null,
                            x: originCityState.x,
                            y: originCityState.y
                        },
                        defender: {
                            cityId: movement.targetCityId,
                            cityName: targetCityState.cityName,
                            units: hasSurvivingLandOrMythic ? targetCityState.units : {},
                            hero: hasSurvivingLandOrMythic ? (Object.keys(targetCityState.heroes || {}).find(id => targetCityState.heroes[id].cityId === movement.targetCityId) || null) : null,
                            losses: hasSurvivingLandOrMythic ? result.defenderLosses : {},
                            ownerId: movement.targetOwnerId,
                            username: movement.ownerUsername || 'Unknown Player',
                            allianceId: targetAllianceData ? targetAllianceData.id : null,
                            allianceName: targetAllianceData ? targetAllianceData.name : null,
                            x: targetCityState.x,
                            y: targetCityState.y
                        },
                        read: false,
                    };
                    if (!hasSurvivingLandOrMythic) {
                        attackerReport.outcome.message = "Your forces were annihilated. No information could be gathered from the battle.";
                    }
                    const defenderReport = {
                        type: 'attack',
                        title: `Defense of ${targetCityState.cityName}`,
                        timestamp: serverTimestamp(),
                        outcome: {
                            attackerWon: !result.attackerWon,
                            plunder: {},
                            attackerLosses: result.attackerLosses,
                            defenderLosses: result.defenderLosses,
                            wounded: {},
                            attackerBattlePoints: result.attackerBattlePoints,
                            defenderBattlePoints: result.defenderBattlePoints,
                            capturedHero: result.capturedHero,
                            woundedHero: result.woundedHero,
                        },
                        attacker: {
                            cityId: movement.originCityId,
                            cityName: originCityState.cityName,
                            units: movement.units,
                            hero: movement.hero || null,
                            losses: result.attackerLosses,
                            ownerId: movement.originOwnerId,
                            username: movement.originOwnerUsername || 'Unknown Player',
                            allianceId: originAllianceData ? originAllianceData.id : null,
                            allianceName: originAllianceData ? originAllianceData.name : null,
                            x: originCityState.x,
                            y: originCityState.y
                        },
                        defender: {
                            cityId: movement.targetCityId,
                            cityName: targetCityState.cityName,
                            units: targetCityState.units,
                            hero: Object.keys(targetCityState.heroes || {}).find(id => targetCityState.heroes[id].cityId === movement.targetCityId) || null,
                            losses: result.defenderLosses,
                            ownerId: movement.targetOwnerId,
                            username: movement.ownerUsername || 'Unknown Player',
                            allianceId: targetAllianceData ? targetAllianceData.id : null,
                            allianceName: targetAllianceData ? targetAllianceData.name : null,
                            x: targetCityState.x,
                            y: targetCityState.y
                        },
                        read: false,
                    };
                    batch.update(targetCityRef, { units: newDefenderUnits, resources: newDefenderResources });
                    batch.set(doc(collection(db, `users/${movement.originOwnerId}/worlds/${worldId}/reports`)), attackerReport);
                    if (movement.targetOwnerId) {
                        batch.set(doc(collection(db, `users/${movement.targetOwnerId}/worlds/${worldId}/reports`)), defenderReport);
                    }
                    if (Object.keys(survivingAttackers).length > 0 || Object.keys(result.wounded).length > 0) {
                        const travelDuration = movement.arrivalTime.toMillis() - movement.departureTime.toMillis();
                        const returnArrivalTime = new Date(movement.arrivalTime.toDate().getTime() + travelDuration);
                        batch.update(movementDoc.ref, {
                            status: 'returning',
                            units: survivingAttackers,
                            resources: result.plunder,
                            wounded: result.wounded,
                            arrivalTime: returnArrivalTime,
                            involvedParties: [movement.originOwnerId]
                        });
                    } else {
                        batch.delete(movementDoc.ref);
                    }
                    await batch.commit();
                    break;
                }
                case 'scout': {
                    if (!targetCityState) {
                        console.log(`Target game state not found for movement ${movement.id}. Deleting.`);
                        batch.delete(movementDoc.ref);
                        break;
                    }
                    const attackingSilver = movement.resources?.silver || 0;
                    const result = resolveScouting(targetCityState, attackingSilver);
                    if (result.success) {
                        const scoutReport = {
                            type: 'scout',
                            title: `Scout report of ${targetCityState.cityName}`,
                            timestamp: serverTimestamp(),
                            scoutSucceeded: true,
                            ...result,
                            targetOwnerUsername: movement.ownerUsername,
                            attacker: {
                                cityId: movement.originCityId,
                                cityName: originCityState.cityName,
                                ownerId: movement.originOwnerId,
                                username: movement.originOwnerUsername,
                                allianceId: originAllianceData ? originAllianceData.id : null,
                                allianceName: originAllianceData ? originAllianceData.name : null,
                                x: originCityState.x,
                                y: originCityState.y
                            },
                            defender: {
                                cityId: movement.targetCityId,
                                cityName: targetCityState.cityName,
                                ownerId: movement.targetOwnerId,
                                username: movement.ownerUsername,
                                allianceId: targetAllianceData ? targetAllianceData.id : null,
                                allianceName: targetAllianceData ? targetAllianceData.name : null,
                                x: targetCityState.x,
                                y: targetCityState.y
                            },
                            read: false,
                        };
                        batch.set(doc(collection(db, `users/${movement.originOwnerId}/worlds/${worldId}/reports`)), scoutReport);
                    } else {
                        const failedScoutAttackerReport = {
                            type: 'scout',
                            title: `Scouting ${targetCityState.cityName} failed`,
                            timestamp: serverTimestamp(),
                            scoutSucceeded: false,
                            message: result.message,
                            read: false,
                        };
                        batch.set(doc(collection(db, `users/${movement.originOwnerId}/worlds/${worldId}/reports`)), failedScoutAttackerReport);
                        const newDefenderCave = { ...targetCityState.cave, silver: (targetCityState.cave?.silver || 0) + result.silverGained };
                        batch.update(targetCityRef, { cave: newDefenderCave });
                        const spyCaughtReport = {
                            type: 'spy_caught',
                            title: `Caught a spy from ${originCityState.cityName}!`,
                            timestamp: serverTimestamp(),
                            originCity: originCityState.cityName,
                            silverGained: result.silverGained,
                            read: false,
                        };
                        batch.set(doc(collection(db, `users/${movement.targetOwnerId}/worlds/${worldId}/reports`)), spyCaughtReport);
                    }
                    batch.delete(movementDoc.ref);
                    await batch.commit();
                    break;
                }
                case 'reinforce': {
                    if (!targetCityState || !movement.targetSlotId) {
                        console.log(`Target game state or slot ID not found for movement ${movement.id}. Deleting.`);
                        batch.delete(movementDoc.ref);
                        break;
                    }
                    const targetCitySlotRef = doc(db, 'worlds', worldId, 'citySlots', movement.targetSlotId);
                    await runTransaction(db, async (transaction) => {
                        const targetCitySnap = await transaction.get(targetCityRef);
                        const targetCitySlotSnap = await transaction.get(targetCitySlotRef);
                        if (!targetCitySnap.exists() || !targetCitySlotSnap.exists()) {
                            throw new Error("Target city or slot data not found.");
                        }
                        const currentCityState = targetCitySnap.data();
                        const newReinforcements = { ...(currentCityState.reinforcements || {}) };
                        const originCityId = movement.originCityId;
                        if (!newReinforcements[originCityId]) {
                            newReinforcements[originCityId] = {
                                ownerId: movement.originOwnerId,
                                originCityName: movement.originCityName,
                                units: {},
                            };
                        }
                        for (const unitId in movement.units) {
                            newReinforcements[originCityId].units[unitId] = (newReinforcements[originCityId].units[unitId] || 0) + movement.units[unitId];
                        }
                        transaction.update(targetCityRef, { reinforcements: newReinforcements });
                        transaction.update(targetCitySlotRef, { reinforcements: newReinforcements });
                        const reinforceReport = {
                            type: 'reinforce',
                            title: `Reinforcement to ${targetCityState.cityName}`,
                            timestamp: serverTimestamp(),
                            units: movement.units,
                            read: false,
                            originCityName: originCityState.cityName,
                            targetCityName: targetCityState.cityName,
                            originPlayer: {
                                username: movement.originOwnerUsername,
                                id: movement.originOwnerId,
                                cityId: movement.originCityId,
                                x: originCityState.x,
                                y: originCityState.y
                            },
                            targetPlayer: {
                                username: movement.ownerUsername,
                                id: movement.targetOwnerId,
                                cityId: movement.targetCityId,
                                x: targetCityState.x,
                                y: targetCityState.y
                            }
                        };
                        transaction.set(doc(collection(db, `users/${movement.originOwnerId}/worlds/${worldId}/reports`)), reinforceReport);
                        if (movement.targetOwnerId) {
                            const arrivalReport = {
                                ...reinforceReport,
                                title: `Reinforcements from ${originCityState.cityName}`,
                            };
                            transaction.set(doc(collection(db, `users/${movement.targetOwnerId}/worlds/${worldId}/reports`)), arrivalReport);
                        }
                        transaction.delete(movementDoc.ref);
                    });
                    break;
                }
                case 'trade': {
                    if (!targetCityState) {
                        console.log(`Target game state not found for movement ${movement.id}. Deleting.`);
                        batch.delete(movementDoc.ref);
                        break;
                    }
                    const newTargetResources = { ...targetCityState.resources };
                    for (const resource in movement.resources) {
                        newTargetResources[resource] = (newTargetResources[resource] || 0) + movement.resources[resource];
                    }
                    batch.update(targetCityRef, { resources: newTargetResources });
                    const tradeReport = {
                        type: 'trade',
                        title: `Trade to ${targetCityState.cityName}`,
                        timestamp: serverTimestamp(),
                        resources: movement.resources,
                        read: false,
                        originCityName: originCityState.cityName,
                        targetCityName: targetCityState.cityName,
                        originPlayer: {
                            username: movement.originOwnerUsername,
                            id: movement.originOwnerId,
                            cityId: movement.originCityId,
                            x: originCityState.x,
                            y: originCityState.y
                        },
                        targetPlayer: {
                            username: movement.ownerUsername,
                            id: movement.targetOwnerId,
                            cityId: movement.targetCityId,
                            x: targetCityState.x,
                            y: targetCityState.y
                        }
                    };
                    batch.set(doc(collection(db, `users/${movement.originOwnerId}/worlds/${worldId}/reports`)), tradeReport);
                    const arrivalReport = {
                        type: 'trade',
                        title: `Trade from ${originCityState.cityName}`,
                        timestamp: serverTimestamp(),
                        resources: movement.resources,
                        read: false,
                        originCityName: originCityState.cityName,
                        targetCityName: targetCityState.cityName,
                        originPlayer: {
                            username: movement.originOwnerUsername,
                            id: movement.originOwnerId,
                            cityId: movement.originCityId,
                            x: originCityState.x,
                            y: originCityState.y
                        },
                        targetPlayer: {
                            username: movement.ownerUsername,
                            id: movement.targetOwnerId,
                            cityId: movement.targetCityId,
                            x: targetCityState.x,
                            y: targetCityState.y
                        }
                    };
                    batch.set(doc(collection(db, `users/${movement.targetOwnerId}/worlds/${worldId}/reports`)), arrivalReport);
                    batch.delete(movementDoc.ref);
                    await batch.commit();
                    break;
                }
                default:
                    console.log(`Unknown movement type: ${movement.type}. Deleting movement ${movement.id}`);
                    batch.delete(movementDoc.ref);
                    await batch.commit();
                    break;
            }
        }
    }, [worldId, getHospitalCapacity]);

    useEffect(() => {
        const processMovements = async () => {
            if (!worldId) return;
            const movementsRef = collection(db, 'worlds', worldId, 'movements');
            const q = query(movementsRef, where('arrivalTime', '<=', new Date()));
            const arrivedMovementsSnapshot = await getDocs(q);
            if (arrivedMovementsSnapshot.empty) return;
            console.log(`Found ${arrivedMovementsSnapshot.docs.length} arrived movements to process.`);
            for (const movementDoc of arrivedMovementsSnapshot.docs) {
                try {
                    await processMovement(movementDoc);
                } catch (error) {
                    console.error("Error processing movement:", movementDoc.id, error);
                }
            }
        };
        const interval = setInterval(processMovements, 5000);
        return () => clearInterval(interval);
    }, [worldId, processMovement]);
};
</file>

<file path="src/hooks/useQuestTracker.js">
// src/hooks/useQuestTracker.js
import { useState, useEffect, useCallback } from 'react';
import { db } from '../firebase/config';
import { doc, setDoc, runTransaction, onSnapshot } from 'firebase/firestore';
import { useAuth } from '../contexts/AuthContext';
import { useGame } from '../contexts/GameContext'; // Import useGame
import allQuests from '../gameData/quests.json';
import { getNationalUnitReward, getGenericUnitType } from '../utils/nationality';

// #comment get warehouse capacity based on its level
const getWarehouseCapacity = (level) => {
    if (!level) return 0;
    return Math.floor(1500 * Math.pow(1.4, level - 1));
};

export const useQuestTracker = (cityState) => {
    const { currentUser } = useAuth();
    const { worldId, activeCityId } = useGame(); // Get worldId and activeCityId from context
    const [questProgress, setQuestProgress] = useState(null);
    const [quests, setQuests] = useState([]);
    const [isClaiming, setIsClaiming] = useState(false);

    // Fetch quest progress from Firestore on load and listen for changes
    useEffect(() => {
        if (!currentUser || !worldId) return;

        const questDocRef = doc(db, `users/${currentUser.uid}/games/${worldId}/quests`, 'progress');
        const unsubscribe = onSnapshot(questDocRef, (docSnap) => {
            if (docSnap.exists()) {
                setQuestProgress(docSnap.data());
            } else {
                // Initialize if it doesn't exist
                const initialProgress = { completed: {}, claimed: {} };
                setDoc(questDocRef, initialProgress).then(() => {
                    setQuestProgress(initialProgress);
                });
            }
        });

        return () => unsubscribe();
    }, [currentUser, worldId]);

    // Update quest status when cityState or progress changes
    useEffect(() => {
        if (!cityState || !questProgress) {
            setQuests([]);
            return;
        }

        const updatedQuests = Object.entries(allQuests).map(([id, questData]) => {
            let isComplete = false;
            if (questProgress.completed[id]) {
                isComplete = true;
            } else {
                switch (questData.type) {
                    case 'building':
                        if (cityState.buildings[questData.targetId]?.level >= questData.targetLevel) {
                            isComplete = true;
                        }
                        break;
                    case 'units':
                        // #comment Sum up all units of the target generic type by checking their national equivalent
                        const totalCount = Object.entries(cityState.units || {})
                            .reduce((sum, [unitId, count]) => {
                                if (getGenericUnitType(unitId) === questData.targetId || unitId === questData.targetId) {
                                    return sum + count;
                                }
                                return sum;
                            }, 0);

                        if (totalCount >= questData.targetCount) {
                            isComplete = true;
                        }
                        break;
                    default:
                        break;
                }
            }

            return {
                id,
                ...questData,
                isComplete,
                isClaimed: !!questProgress.claimed[id],
            };
        });

        setQuests(updatedQuests);

    }, [cityState, questProgress]);

    const claimReward = useCallback(async (questId) => {
        if (isClaiming) return;
        if (!currentUser || !worldId || !activeCityId) return;

        const quest = quests.find(q => q.id === questId);
        if (!quest || !quest.isComplete || quest.isClaimed) {
            console.error("Quest not available for claiming.");
            return;
        }

        setIsClaiming(true);

        const cityDocRef = doc(db, `users/${currentUser.uid}/games/${worldId}/cities`, activeCityId);
        const questDocRef = doc(db, `users/${currentUser.uid}/games/${worldId}/quests`, 'progress');

        try {
            await runTransaction(db, async (transaction) => {
                const cityDoc = await transaction.get(cityDocRef);
                const questDoc = await transaction.get(questDocRef);

                if (!cityDoc.exists() || !questDoc.exists()) {
                    throw new Error("City or quest data not found.");
                }

                const cityData = cityDoc.data();
                const questData = questDoc.data();
                const capacity = getWarehouseCapacity(cityData.buildings.warehouse?.level);

                // Apply rewards
                const newResources = { ...cityData.resources };
                const newUnits = { ...cityData.units };
                const playerNation = cityData.playerInfo?.nation;

                if (quest.rewards.resources) {
                    for (const resource in quest.rewards.resources) {
                        newResources[resource] = Math.min(capacity, (newResources[resource] || 0) + quest.rewards.resources[resource]);
                    }
                }
                if (quest.rewards.units) {
                    for (const unit in quest.rewards.units) {
                        // #comment Check for a generic unit reward
                        if (unit.startsWith('generic_')) {
                            if (!playerNation) {
                                console.error("Player nation not found for generic unit reward.");
                                continue;
                            }
                            const nationalUnitId = getNationalUnitReward(playerNation, unit);
                            newUnits[nationalUnitId] = (newUnits[nationalUnitId] || 0) + quest.rewards.units[unit];
                        } else {
                            newUnits[unit] = (newUnits[unit] || 0) + quest.rewards.units[unit];
                        }
                    }
                }

                // Update quest progress
                const newQuestProgress = { ...questData };
                newQuestProgress.claimed[questId] = true;
                if (!newQuestProgress.completed[questId]) {
                    newQuestProgress.completed[questId] = true;
                }

                transaction.update(cityDocRef, { resources: newResources, units: newUnits });
                transaction.set(questDocRef, newQuestProgress);
            });
            // The onSnapshot listener will update the local state automatically.
        } catch (error) {
            console.error("Error claiming quest reward:", error);
        } finally {
            setIsClaiming(false);
        }
    }, [currentUser, worldId, activeCityId, quests, isClaiming]);

    return { quests, claimReward, isClaiming };
};
</file>

<file path="src/hooks/useWorldClock.js">
// src/hooks/useWorldClock.js
import { useEffect } from 'react';
import { db } from '../firebase/config';
import { doc, writeBatch, serverTimestamp } from 'firebase/firestore';

/**
 * #comment A custom hook to manage the world's season and weather updates.
 */
export const useWorldClock = (worldId, worldState) => {
    useEffect(() => {
        const checkForSeasonAndWeatherUpdate = async () => {
            if (!worldState) return;

            const now = new Date();
            const worldDocRef = doc(db, 'worlds', worldId);
            const batch = writeBatch(db);
            let needsUpdate = false;

            const seasons = ['Spring', 'Summer', 'Autumn', 'Winter'];
            const weathers = ['Clear', 'Rainy', 'Windy', 'Foggy', 'Stormy'];

            // #comment season changes every 7 days
            const seasonDuration = 7 * 24 * 60 * 60 * 1000;
            const lastSeasonUpdate = worldState.seasonLastUpdate?.toDate() || new Date(0);
            if (now.getTime() - lastSeasonUpdate.getTime() > seasonDuration) {
                const currentSeasonIndex = seasons.indexOf(worldState.season || 'Winter');
                const nextSeason = seasons[(currentSeasonIndex + 1) % seasons.length];
                batch.update(worldDocRef, { season: nextSeason, seasonLastUpdate: serverTimestamp() });
                needsUpdate = true;
            }

            // #comment weather changes every 3 hours
            const weatherDuration = 3 * 60 * 60 * 1000;
            const lastWeatherUpdate = worldState.weatherLastUpdate?.toDate() || new Date(0);
            if (now.getTime() - lastWeatherUpdate.getTime() > weatherDuration) {
                const nextWeather = weathers[Math.floor(Math.random() * weathers.length)];
                batch.update(worldDocRef, { weather: nextWeather, weatherLastUpdate: serverTimestamp() });
                needsUpdate = true;
            }

            if (needsUpdate) {
                try {
                    await batch.commit();
                    console.log("Season/Weather updated by client check.");
                } catch (error) {
                    console.error("Error updating season/weather: ", error);
                }
            }
        };

        checkForSeasonAndWeatherUpdate();
    }, [worldId, worldState]);
};
</file>

<file path="src/index.css">
/* src/index.css */
/* All @import statements have been moved to index.js */

/* --- Auth Card Flip --- */
.perspective {
    perspective: 1000px;
}
.auth-card {
    transition: transform 0.8s;
    transform-style: preserve-3d;
    position: relative;
    width: 100%;
    max-width: 448px; /* max-w-md */
    min-height: 550px;
}
.auth-card.flipped {
    transform: rotateY(180deg);
}
.auth-card-face {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
}
.auth-card-back {
    transform: rotateY(180deg);
}

/* --- City View --- */
.city-viewport {
    width: 100%;
    height: 100%;
    cursor: grab;
    overflow: hidden;
    position: relative;
}
.city-viewport:active {
    cursor: grabbing;
}
.city-grid {
    flex-grow: 1;
    display: grid;
    height: 100%;
    width: 100%;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    gap: 0.75rem;
    grid-template-areas:
        "wall wall wall wall wall wall wall wall"
        ". timber timber senate senate quarry quarry ."
        "silver silver warehouse warehouse market market . ."
        "barracks barracks farm farm . . academy academy"
        "cave cave temple temple . . . ."
        "shipyard shipyard . . . . . ."
        ". . . . . . . ."
        ". . . . . . . .";
    background: linear-gradient(to bottom, 
        #2a623d 0%,
        #2a623d 65%,
        #1e3a8a 65%,
        #1e3a8a 100%
    );
    padding: 1.5rem;
    position: relative;
}

/* Building Plot Styles */
.building-plot {
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    background-color: rgba(0, 0, 0, 0.3);
    position: relative;
    overflow: hidden;
    grid-area: var(--grid-area);
}
.building-plot::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 50%, rgba(0,0,0,0.7) 100%);
}
.building-plot:hover {
    transform: translateY(-4px) scale(1.03);
    border-color: #f0e0c0;
    box-shadow: 0 0 25px rgba(255, 235, 192, 0.5);
}
.building-plot-empty {
    border: 2px dashed rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    background-color: rgba(0, 0, 0, 0.2);
}
.building-plot-empty:hover {
    background-color: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.4);
}

/* Specific Building Styles */
#plot-city_wall { min-height: 60px; }
#plot-senate { border: 4px solid #a17c48; border-radius: 12px; }
#plot-shipyard {
    align-self: end;
    min-height: 120px;
    border: 3px solid #6b4a2b;
    border-top-left-radius: 40px;
    border-top-right-radius: 40px;
    background: linear-gradient(to bottom, #5d4037 0%, #5d4037 60%, #1e3a8a 60%, #1e3a8a 100%);
}
#plot-temple { clip-path: polygon(50% 0%, 100% 25%, 100% 100%, 0 100%, 0 25%); background-color: #8d6e63; }
#plot-cave { background-color: #5d4037; }
#plot-farm { background-color: #689f38; grid-area: farm; }
#plot-timber_camp { grid-area: timber; }
#plot-quarry { grid-area: quarry; }
#plot-silver_mine { grid-area: silver; }
#plot-warehouse { grid-area: warehouse; }
#plot-market { grid-area: market; }
#plot-barracks { grid-area: barracks; }
#plot-academy { grid-area: academy; }
</file>

<file path="src/index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import './styles/base.css';
import './styles/components.css';
import './styles/effects.css';
import './styles/map.css';
import './styles/panels.css';
import './styles/tooltips.css';
import './components/ReportsView.css';
import './components/map/MovementModal.css';
import './components/map/OtherCityModal.css';
import './components/map/MapOverlay.css';
import './components/city/ResearchQueue.css';
import './components/shared/Notification.css';
import App from './App';
import { AuthProvider } from './contexts/AuthContext';
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <AuthProvider>
      <div className="bg-gray-900 text-white min-h-screen font-sans">
        <App />
      </div>
    </AuthProvider>
  </React.StrictMode>
);
</file>

<file path="src/styles/base.css">
/* src/styles/index.css */
@import url('https://fonts.googleapis.com/css2?family=IM+Fell+English+SC&family=Inter:wght@400;500;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

body {
    font-family: 'Inter', sans-serif;
    background-color: #3a2d27; /* Dark wood color as fallback */
    background-image: url('https://www.transparenttextures.com/patterns/dark-wood.png');
}

.font-title {
    font-family: 'IM Fell English SC', serif;
}

/* Hide number input spinners */
.hide-number-spinners::-webkit-outer-spin-button,
.hide-number-spinners::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.hide-number-spinners[type='number'] {
  -moz-appearance: textfield;
}

.hide-number-spinners {
  appearance: none;
}
</file>

<file path="src/styles/components.css">
/* src/styles/components.css */

/* --- General Components & Buttons --- */
.btn {
    @apply font-bold py-2 px-4 rounded-md transition-all duration-200 cursor-pointer transform;
    color: #4a2c2a;
    border: 2px solid #8B4513; /* saddlebrown */
    text-shadow: 0 1px 0 rgba(255, 255, 255, 0.3);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
}
.btn:hover:not(:disabled) {
    @apply scale-105;
}
.btn-disabled, .btn:disabled {
    @apply cursor-not-allowed opacity-60;
    background: #d2b48c !important; /* tan */
    color: #6b4a2b !important;
    transform: scale(1);
}

.btn-primary, .btn-upgrade, .btn-confirm {
    background: linear-gradient(to bottom, #f0e68c, #cd853f); /* khaki to peru */
}
.btn-primary:hover:not(:disabled), .btn-upgrade:hover:not(:disabled), .btn-confirm:hover:not(:disabled) {
    background: linear-gradient(to bottom, #fff2b2, #d6914d);
}

.btn-danger {
    background: linear-gradient(to bottom, #fca5a5, #ef4444); /* light red to red */
    color: white;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    border-color: #991b1b; /* dark red */
}
.btn-danger:hover:not(:disabled) {
    background: linear-gradient(to bottom, #fecaca, #f87171);
}


.selection-card {
    @apply bg-gray-800 border-2 border-gray-700 cursor-pointer transition-all duration-200 rounded-lg p-4;
}
.selection-card.selected {
    @apply border-blue-500 transform scale-105 shadow-lg;
}

.resource-icon {
    @apply w-6 h-6 mr-2;
}

/* --- Layout Components --- */
.sidebar {
    @apply w-auto flex flex-col p-2 rounded-lg;
    background-image: url('../images/bg/nav_bar_bg.png');
    background-size: 110% 115%;
    background-position: center;
    border: none;
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
    
    /* Centered positioning for both views */
    @apply absolute top-[55%] -translate-y-1/2 z-30;
    
    /* #comment Transparency on hover effect */
    @apply opacity-50 transition-opacity duration-300 ease-in-out;
}

.sidebar:hover {
    @apply opacity-100;
}


.sidebar-button {
    @apply w-full relative flex items-center justify-start p-2 rounded-md transition-colors duration-200 font-semibold my-1 text-sm gap-3;
    color: #d4af37;
    border: 1px solid rounded;
    border-image-slice: 1;
    border-image-source: linear-gradient(to top, #d4af37, #b8860b);
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
    box-shadow: inset 0 2px 3px rgba(0, 0, 0, 0.5), 0 2px 2px rgba(255, 255, 255, 0.2);
}

.sidebar-button:hover:not(:disabled) {
    background: linear-gradient(to bottom, #5a5a5a, #3a3a3a);
}

.sidebar-button:disabled {
    @apply opacity-50 cursor-not-allowed;
    background: #d2b48c;
}

.sidebar-button .icon-container {
    @apply w-6 h-6 flex items-center justify-center;
}

.sidebar-button .notification-badge {
     @apply absolute top-1 right-1 bg-red-600 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center border-2 border-white;
}

.main-content {
    @apply flex-grow relative;
}

.nav-button {
    @apply bg-gray-700 text-gray-200 border border-gray-600 rounded-lg px-4 py-2 font-semibold transition-all duration-200;
}
.nav-button:hover {
    @apply bg-gray-600 transform scale-105;
}

/* --- Autocomplete Suggestions --- */
.autocomplete-suggestions-container {
    position: relative;
}

.autocomplete-suggestions-list {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    z-index: 100; /* High z-index to appear over other content */
    max-height: 150px;
    overflow-y: auto;
    list-style: none;
    margin: 2px 0 0 0;
    padding: 0;
    border-radius: 0.375rem; /* rounded-md */
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
}

.autocomplete-suggestions-list li {
    padding: 0.5rem 0.75rem; /* py-2 px-3 */
    cursor: pointer;
}

/* Styles for papyrus/light theme (Messages) */
.autocomplete-suggestions-list.light {
    background-color: #F5DEB3; /* wheat */
    border: 1px solid #8B4513;
}
.autocomplete-suggestions-list.light li {
    color: #4a2c2a;
}
.autocomplete-suggestions-list.light li:hover {
    background-color: #E6CBA8;
}

/* Styles for dark theme (Alliance Invites) */
.autocomplete-suggestions-list.dark {
    background-color: #374151; /* gray-700 */
    border: 1px solid #4b5563; /* gray-600 */
}
.autocomplete-suggestions-list.dark li {
    color: #f3f4f6; /* gray-100 */
}
.autocomplete-suggestions-list.dark li:hover {
    background-color: #4b5563; /* gray-600 */
}

/* --- Text Editor Color Palette --- */
.color-palette {
    position: absolute;
    top: 100%;
    left: 0;
    z-index: 110;
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 4px;
    background-color: #e6cba8;
    border: 1px solid #8B4513;
    padding: 4px;
    border-radius: 4px;
}

.color-swatch {
    width: 24px;
    height: 24px;
    border: 1px solid #4a2c2a;
    cursor: pointer;
}

/* --- Settings Modal Tabs --- */
.settings-tabs button.active {
    border-bottom: 2px solid #f0e68c;
    color: #f0e68c;
}

.settings-tabs button {
    @apply transition-colors duration-200;
}
</file>

<file path="src/styles/effects.css">
/* src/styles/effects.css */

/* --- Glowing Effect for Reports Button --- */
.glowing-border {
    animation: glowing-border-animation 2s infinite;
    border: 1px solid transparent;
}

@keyframes glowing-border-animation {
    0% {
        border-color: #fde047;
        box-shadow: 0 0 3px #fde047;
    }
    50% {
        border-color: #fef08a;
        box-shadow: 0 0 15px #fef08a, 0 0 5px #fef08a inset;
    }
    100% {
        border-color: #fde047;
        box-shadow: 0 0 3px #fde047;
    }
}

/* --- Glowing Effect for Attack Alert --- */
.glowing-attack {
    animation: glowing-attack-animation 1.5s infinite;
    border: 1px solid transparent;
}

@keyframes glowing-attack-animation {
    0% {
        border-color: #ef4444; /* red-500 */
        box-shadow: 0 0 5px #ef4444;
    }
    50% {
        border-color: #f87171; /* red-400 */
        box-shadow: 0 0 20px #f87171, 0 0 10px #f87171 inset;
    }
    100% {
        border-color: #ef4444; /* red-500 */
        box-shadow: 0 0 5px #ef4444;
    }
}

/* --- Screen Glow for Attack Alert --- */
.screen-glow-attack {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 9999;
    animation: screen-glow-animation 1.5s infinite;
    border: 4px solid transparent;
}

@keyframes screen-glow-animation {
    0% {
        border-color: rgba(239, 68, 68, 0.5);
        box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
    }
    50% {
        border-color: rgba(248, 113, 113, 0.8);
        box-shadow: 0 0 40px rgba(248, 113, 113, 0.8), 0 0 20px rgba(248, 113, 113, 0.8) inset;
    }
    100% {
        border-color: rgba(239, 68, 68, 0.5);
        box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
    }
}

/* --- Movement Indicator --- */
.movement-indicator {
    position: absolute;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    z-index: 30;
    filter: drop-shadow(0 0 5px currentColor);
    animation: pulse 1.5s infinite alternate;
}
@keyframes pulse {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(1.2); opacity: 0.8; }
}
.movement-indicator.outgoing { background-color: #ef4444; color: #ef4444; }
.movement-indicator.incoming { background-color: #10b981; color: #10b981; }
</file>

<file path="src/styles/map.css">
/* src/styles/map.css */

/* --- Map & Tile Styles --- */
.map-surface {
  background-image: url('../images/water.png');
  background-repeat: repeat;
  background-size: 250px;
  backface-visibility: hidden;
  transform: translateZ(0);
}

.map-viewport {
    @apply absolute inset-0 w-full h-full cursor-grab overflow-hidden;
}
.map-viewport:active {
    @apply cursor-grabbing;
}

.map-border {
    @apply absolute bg-red-500 pointer-events-none z-40 transition-opacity duration-200;
}
.map-border.top { @apply top-0 left-0 right-0 h-1; }
.map-border.bottom { @apply bottom-0 left-0 right-0 h-1; }
.map-border.left { @apply top-0 bottom-0 left-0 w-1; }
.map-border.right { @apply top-0 bottom-0 right-0 w-1; }

.map-grid {
    @apply grid;
}

.map-tile {
    @apply flex items-center justify-center relative;
}

/* City Slot Styles */
.city-slot {
    @apply w-6 h-6 rounded-full m-1 cursor-pointer relative transition-transform duration-150;
}

.city-sprite {
    @apply absolute w-12 h-10; /* 48px width, 40px height */
    bottom: -5px; /* Adjust vertical position */
    left: 50%;
    transform: translateX(-50%);
    background-repeat: no-repeat;
    pointer-events: none; /* Make sure it doesn't interfere with clicks */
    z-index: 10;
}


.city-slot:hover {
    @apply scale-125 ring-2 ring-white z-20;
}
.city-slot:hover .city-sprite {
    filter: drop-shadow(0 0 5px white);
}

.city-slot:hover .map-object-tooltip {
    @apply visible opacity-100;
}
.empty-slot {
    @apply bg-gray-500 border border-dashed border-gray-400;
}
.my-city {
    @apply bg-transparent border-2 border-yellow-200;
}
.alliance-city { /* Your own alliance */
    @apply bg-transparent border-2 border-blue-300;
}
.ally-city { /* Allied alliances */
    @apply bg-transparent border-2 border-green-300;
}
.enemy-city {
    @apply bg-transparent border-2 border-red-300;
}
.neutral-city {
    @apply bg-transparent border-2 border-amber-500;
}
.dummy-city-plot {
    @apply bg-purple-500 border-2 border-purple-300;
}
.dummy-placement-plot {
    @apply bg-gray-500 border-2 border-dashed border-yellow-400 cursor-crosshair animate-pulse;
}
.ghost-city {
    @apply bg-gray-600 border-2 border-gray-800;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="rgba(255,255,255,0.5)"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-5-9c.83 0 1.5-.67 1.5-1.5S7.83 8 7 8s-1.5.67-1.5 1.5S6.17 11 7 11zm10 0c.83 0 1.5-.67 1.5-1.5S17.83 8 17 8s-1.5.67-1.5 1.5S16.17 11 17 11zm-5 4c-1.66 0-3-1.34-3-3h6c0 1.66-1.34 3-3 3z"/></svg>');
    background-size: 70%;
    background-repeat: no-repeat;
    background-position: center;
}


/* Farming Village Styles */
.village-slot {
    @apply w-20 h-6 m-0 cursor-pointer relative transition-transform duration-150 bg-no-repeat;
    background-image: url('../images/villages.png');
    background-size: 300% 350%;
    /* Add a subtle shadow to blend with the terrain */
    filter: drop-shadow(2px 4px 3px rgba(0,0,0,0.4));
}
.village-slot:hover {
    @apply scale-125 z-20;
    filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.5));
}
.village-slot:hover .map-object-tooltip {
    @apply visible opacity-100;
}

/* #comment Define background positions for each village level */
.village-level-1 { background-position: 0% 0%; }
.village-level-2 { background-position: 100% 0%; }
.village-level-3 { background-position: 0% 50%; }
.village-level-4 { background-position: 100% 50%; }
.village-level-5 { background-position: 0% 100%; }
.village-level-6 { background-position: 100% 100%; }


.my-village {
    /* No special filter needed now */
}
.other-village-plot {
   /* No special filter needed now */
}

/* Ruin Styles */
.ruin-slot {
    @apply w-12 h-12 m-1 cursor-pointer relative transition-transform duration-150 bg-no-repeat;
    background-image: url('../images/ruins.png');
    background-size: 200% 100%;
    filter: drop-shadow(2px 4px 3px rgba(0,0,0,0.4));
}
.ruin-slot:hover {
    @apply scale-125 z-20;
    filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.5));
}
.ruin-slot:hover .map-object-tooltip {
    @apply visible opacity-100;
}

.ruin-unoccupied {
    background-position: 0% 0%;
}

.ruin-occupied {
    background-position: 100% 0%;
}
/* God Town Styles */
.god-town-slot {
    @apply w-8 h-8 m-1 cursor-pointer relative transition-transform duration-150;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
}
.god-town-slot:hover {
    @apply scale-125 ring-2 ring-yellow-300 z-20;
}
.god-town-slot:hover .map-object-tooltip {
    @apply visible opacity-100;
}
.god-town-slot.ruins {
    filter: hue-rotate(280deg) brightness(1.2);
}
.god-town-slot.city {
    filter: drop-shadow(0 0 8px #fde047);
}

/* Wonder Styles */
.wonder-spot-tile {
    @apply w-8 h-8 rounded-full relative bg-gray-600/50 border-2 border-gray-500;
}

.wonder-spot-tile.active {
    @apply cursor-pointer bg-yellow-400/50 border-yellow-300;
    animation: glowing-wonder-spot 2s infinite;
}

@keyframes glowing-wonder-spot {
    0% { box-shadow: 0 0 5px #fde047; }
    50% { box-shadow: 0 0 20px #fef08a, 0 0 10px #fef08a; }
    100% { box-shadow: 0 0 5px #fde047; }
}

.constructing-wonder-tile {
    @apply w-8 h-8 cursor-pointer relative;
    background-image: url('../images/special_buildings/alliance_wonders.jpg');
    background-size: contain;
}
</file>

<file path="src/styles/panels.css">
.troop-display-container {
    @apply w-40 p-1.5 flex flex-col gap-1.5;
    background-image: url('../images/bg/right_background.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    background-position: center;
    color: #4a2c2a;
}
.troop-section {
    @apply bg-black/5 rounded p-1;
}
.troop-section-header {
    @apply font-bold text-xs text-center pb-1 mb-1 border-b border-[#8B4513];
}
.troop-grid {
    @apply grid grid-cols-3 gap-1;
}
.troop-item {
    @apply relative w-full aspect-square bg-black/10 rounded-md overflow-hidden border border-transparent hover:border-yellow-600 transition-all;
}
.troop-image {
    @apply w-full h-full object-cover;
}
.troop-count {
    @apply absolute bottom-0 right-0.5 font-bold text-sm;
    color: white;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 1);
}
.worship-display-container {
    @apply w-40 p-1.5;
    background-image: url('../images/bg/right_background.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    background-position: center;
    color: #4a2c2a;
}
.worship-display-header {
    @apply font-title text-lg text-center mb-1;
}
.worship-display-container img {
    @apply w-16 h-16;
}
.spells-button {
    @apply rounded-full w-8 h-8 mt-1 mx-auto overflow-hidden transition-transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-yellow-400 flex justify-center items-center;
    background-color: rgba(0,0,0,0.1);
    border: 2px solid #8B4513;
}
.spells-button img {
    @apply w-6 h-6 object-contain;
}
.alliance-text-light {
    color: #000000;
}
.alliance-text-dark {
    color: #ffffff;
}
.alliance-bg-light {
    background-color: #f0e68c;
}
.alliance-bg-dark {
    background-color: #0d202b;
}
.status-badge {
    @apply px-2 py-1 rounded-full text-xs font-bold ml-2;
}
.status-open {
    background-color: #4ade80;
    color: #000000;
}
.status-invite_only {
    background-color: #fbbf24;
    color: #000000;
}
.status-closed {
    background-color: #f87171;
    color: #000000;
}
</file>

<file path="src/styles/tooltips.css">
/* src/styles/tooltips.css */

/* Generic tooltip for all map objects */
.map-object-tooltip {
    @apply invisible absolute w-auto min-w-[180px] max-w-xs text-left rounded-md py-2 px-3 z-30 bottom-full left-1/2 -translate-x-1/2 mb-2 opacity-0 transition-opacity;
    background-image: linear-gradient(rgba(245, 222, 179, 0.95), rgba(245, 222, 179, 0.95)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 4px solid #8B4513; /* saddlebrown */
    box-shadow: 0 0 15px rgba(0,0,0,0.5);
    color: #4a2c2a;
    pointer-events: none;
    font-size: 0.7rem;
}
.tooltip-hr {
    @apply my-1 border-t-2;
    border-color: #8B4513;
}

.tooltip-troop-grid {
    @apply grid grid-cols-3 gap-x-4 gap-y-1 mt-1;
}

.tooltip-troop-item {
    @apply flex items-center justify-start pr-2;
}

.tooltip-troop-image {
    @apply w-5 h-5 object-contain flex-shrink-0;
}

.tooltip-troop-count {
    @apply font-bold ml-1 whitespace-nowrap;
    font-size: 0.7rem;
}

.unit-tooltip {
    position: absolute;
    top: 50%;
    right: 100%;
    transform: translate(0, -50%);
    margin-right: 10px;
    width: 250px;
    background-color: #f5de99;
    border: 3px solid #8b4513;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    z-index: 100;
    color: #4a2c2a;
    pointer-events: none;
    display: flex;
    flex-direction: column;
}

.tooltip-lock-timer {
    position: absolute;
    bottom: -14px;
    right: -14px;
    width: 28px;
    height: 28px;
    background-color: #4a2c2a;
    color: #f0e68c;
    border: 2px solid #8B4513;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: bold;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    z-index: 101;
    pointer-events: all;
}

.tooltip-header {
    background-color: #4a2c2a;
    padding: 0.5rem;
    text-align: center;
}

.tooltip-title {
    font-family: 'IM Fell English SC', serif;
    font-size: 1.2rem;
    color: #f0e68c;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
}

.tooltip-body {
    padding: 1rem;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.tooltip-image {
    width: 100px;
    height: 100px;
    object-fit: cover;
    border: 2px solid #cd853f;
    border-radius: 4px;
    margin-bottom: 0.75rem;
}

.tooltip-stats {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    border-top: 1px solid #d2b48c;
    border-bottom: 1px solid #d2b48c;
    padding: 0.75rem 0;
    margin-bottom: 0.75rem;
}

.stat-row {
    display: flex;
    justify-content: space-between;
    font-size: 0.9rem;
    font-weight: bold;
}

.tooltip-counters {
    width: 100%;
    font-size: 0.8rem;
    text-align: center;
    padding: 0.5rem 0;
    margin-bottom: 0.75rem;
    border-top: 1px solid #d2b48c;
    border-bottom: 1px solid #d2b48c;
}

.tooltip-description {
    font-size: 0.8rem;
    text-align: center;
    font-style: italic;
    color: #6b4a2b;
}

/* #comment Corrected styles for resource tooltip */
.resource-tooltip {
    position: absolute;
    top: calc(100% + 5px); /* Position below the parent */
    left: 50%;
    transform: translateX(-50%); /* Center it */
    background-color: rgba(0, 0, 0, 0.9);
    border: 1px solid #4a2c2a;
    border-radius: 4px;
    padding: 0.5rem 0.75rem;
    color: white;
    box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    white-space: pre-wrap; /* Allow newlines and wrapping */
    z-index: 50;
    pointer-events: none;
}

.happiness-tooltip {
    left: auto;
    right: 0%;
    transform: none;
    margin-right: 10px;
}
</file>

<file path="src/utils/bbcodeParser.js">
export const parseBBCode = (text) => {
    if (!text) return '';
    let html = text;
    // #comment escape HTML to prevent XSS
    html = html.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    // #comment convert newlines to <br> tags
    html = html.replace(/\n/g, '<br />');
    // [b]bold[/b]
    html = html.replace(/\[b\](.*?)\[\/b\]/gs, '<strong>$1</strong>');
    // [i]italic[/i]
    html = html.replace(/\[i\](.*?)\[\/i\]/gs, '<em>$1</em>');
    // [u]underline[/u]
    html = html.replace(/\[u\](.*?)\[\/u\]/gs, '<u>$1</u>');
    // [color=red]red text[/color]
    html = html.replace(/\[color=(.*?)\](.*?)\[\/color\]/gs, '<span style="color: $1;">$2</span>');
    // [size=18]sized text[/size]
    html = html.replace(/\[size=(.*?)\](.*?)\[\/size\]/gs, '<span style="font-size: $1px;">$2</span>');
    // [quote]quoted text[/quote]
    html = html.replace(/\[quote\](.*?)\[\/quote\]/gs, '<blockquote class="bbcode-quote">$1</blockquote>');
    // [spoiler]spoiler text[/spoiler]
    html = html.replace(/\[spoiler\](.*?)\[\/spoiler\]/gs, '<details><summary>Spoiler</summary>$1</details>');
    // [img]image url[/img]
    html = html.replace(/\[img\](.*?)\[\/img\]/gs, '<img src="$1" alt="User Image" style="max-width: 100%;" />');
    // [url]url[/url] or [url=url]text[/url]
    html = html.replace(/\[url\](.*?)\[\/url\]/gs, '<a href="$1" target="_blank">$1</a>');
    html = html.replace(/\[url=(.*?)\](.*?)\[\/url\]/gs, '<a href="$1" target="_blank">$2</a>');
    // [action=type,id=someId]Click Me[/action]
    html = html.replace(/\[action=([^,\]]+),allianceId=([^\]]+)\](.*?)\[\/action\]/gs, (match, type, id, text) => {
        return `<span class="bbcode-action" data-action-type="${type}" data-action-id="${id}">${text}</span>`;
    });
    // [report]reportId[/report] - This will now be a placeholder for React to render the component
    html = html.replace(/\[report\](.*?)\[\/report\]/gs, '<div class="shared-report-placeholder" data-report-id="$1"></div>');
    // #comment New BBCode formats for reports
    // [player id=userId]Player Name[/player]
    html = html.replace(/\[player id=([^\]]+)\](.*?)\[\/player\]/gs, '<span class="bbcode-action" data-action-type="profile" data-action-id="$1">$2</span>');
    // [alliance id=allianceId]Alliance Name[/alliance]
    html = html.replace(/\[alliance id=([^\]]+)\](.*?)\[\/alliance\]/gs, '<span class="bbcode-action" data-action-type="alliance_profile" data-action-id="$1">$2</span>');
    // [city id=cityId owner=ownerId x=x y=y]City Name[/city]
    html = html.replace(/\[city id=([^ ]+) owner=([^ ]+) x=([\d.]+) y=([\d.]+)\](.*?)\[\/city\]/gs, '<span class="bbcode-action" data-action-type="city_link" data-action-id="$1" data-action-owner-id="$2" data-action-coords-x="$3" data-action-coords-y="$4">$5</span>');
    // [attack attacker="Player A" attacker_city="City A" defender="Player B" defender_city="City B"]...[/attack]
    html = html.replace(/\[attack attacker="([^"]*)" attacker_city="([^"]*)" defender="([^"]*)" defender_city="([^"]*)"\](.*?)\[\/attack\]/gs, '<b>Attack Report</b><br/>Attacker: $1 ($2)<br/>Defender: $3 ($4)');
    // [trade from_player="Player A" from_city="CityA" to_player="Player B" to_city="CityB"]...[/trade]
    html = html.replace(/\[trade from_player="([^"]*)" from_city="([^"]*)" to_player="([^"]*)" to_city="([^"]*)"\](.*?)\[\/trade\]/gs, '<b>Trade Report</b><br/>From: $1 ($2)<br/>To: $3 ($4)');
    // [scout attacker="Player A" attacker_city="City A" attacker_alliance="AllyA" defender="Player B" defender_city="City B" defender_alliance="AllyB"]...[/scout]
    html = html.replace(/\[scout attacker="([^"]*)" attacker_city="([^"]*)" attacker_alliance="([^"]*)" defender="([^"]*)" defender_city="([^"]*)" defender_alliance="([^"]*)"\](.*?)\[\/scout\]/gs, '<b>Scout Report</b><br/>Scout from: $1 ($2) [$3]<br/>Scouted: $4 ($5) [$6]');
    return html;
};
</file>

<file path="src/utils/combat.js">
// src/utils/combat.js
import unitConfig from '../gameData/units.json';
import heroesConfig from '../gameData/heroes.json';

/**
 * Resolves a battle between attacking and defending units of a specific type.
 * Incorporates phalanx, support, and counter unit logic.
 * @param {object} attackingUnits - Units of the attacker.
 * @param {object} defendingUnits - Units of the defender.
 * @param {string} unitType - 'land' or 'naval'.
 * @param {string|null} attackerPhalanx - The unit ID chosen as phalanx by the attacker.
 * @param {string|null} attackerSupport - The unit ID chosen as support by the attacker.
 * @param {string|null} defenderPhalanx - The unit ID chosen as phalanx by the defender.
 * @param {string|null} defenderSupport - The unit ID chosen as support by the defender.
 * @returns {object} Battle results including attackerWon, attackerLosses, defenderLosses.
 */
const resolveBattle = (attackingUnits, defendingUnits, unitType, attackerPhalanx, attackerSupport, defenderPhalanx, defenderSupport, attackingHero, defendingHero) => {
    // Check if either side has units of the required type
    const hasAttackingUnits = Object.entries(attackingUnits || {}).some(
        ([unitId, count]) => count > 0 && unitConfig[unitId]?.type === unitType && unitConfig[unitId]?.attack > 0
    );
    const hasDefendingUnits = Object.entries(defendingUnits || {}).some(
        ([unitId, count]) => count > 0 && unitConfig[unitId]?.type === unitType
    );

    // If the defender has no relevant units, the attacker automatically wins this phase.
    if (!hasDefendingUnits) {
        return {
            attackerWon: true,
            attackerLosses: {},
            defenderLosses: {},
            attackerLossRatio: 0,
            defenderLossRatio: 0,
        };
    }
    
    // If the attacker has no relevant combat units, but the defender does, the attacker loses.
    if (!hasAttackingUnits && !attackingHero) {
        return {
            attackerWon: false,
            attackerLosses: {},
            defenderLosses: {},
            attackerLossRatio: 1,
            defenderLossRatio: 0,
        };
    }

    let currentAttackingUnits = { ...attackingUnits };
    let currentDefendingUnits = { ...defendingUnits };

    // #comment Function to calculate effective power considering counters
    const calculateEffectivePower = (units, opponentUnits, isAttacker, phalanxUnit, supportUnit, heroId) => {
        let totalPower = 0;
        let phalanxPower = 0;
        let supportPower = 0;
        let otherPower = 0;

        const hero = heroId ? heroesConfig[heroId] : null;

        for (const unitId in units) {
            const unitCount = units[unitId] || 0;
            if (unitCount === 0) continue;

            const unitInfo = unitConfig[unitId];
            if (!unitInfo || unitInfo.type !== unitType) continue;

            let attack = unitInfo.attack;
            let defense = unitInfo.defense;

            // #comment Apply hero passives correctly to attack or defense
            if (hero && hero.passive.effect.type === 'city_buff' && unitInfo.type === 'land') {
                const effect = hero.passive.effect;
                const heroLevel = 1; // Placeholder: This should be passed in with hero data
                const bonus = effect.baseValue + (heroLevel - 1) * effect.valuePerLevel;
            
                if (effect.subtype === 'land_attack') {
                    // A "warrior's presence" should logically help in both attack and defense
                    attack *= (1 + bonus);
                    defense *= (1 + bonus);
                }
            }

            // Apply counter bonuses
            for (const opponentUnitId in opponentUnits) {
                const opponentUnitCount = opponentUnits[opponentUnitId] || 0;
                if (opponentUnitCount > 0) {
                    const opponentUnitInfo = unitConfig[opponentUnitId];
                    if (unitInfo.counters && opponentUnitInfo && unitInfo.counters.includes(opponentUnitId)) {
                        attack *= 1.2; // 20% attack bonus
                    }
                    if (opponentUnitInfo && opponentUnitInfo.counters && opponentUnitInfo.counters.includes(unitId)) {
                        defense *= 0.8; // 20% defense penalty
                    }
                }
            }

            const unitPower = unitCount * (isAttacker ? attack : defense);

            if (unitId === phalanxUnit) {
                phalanxPower += unitPower;
            } else if (unitId === supportUnit) {
                supportPower += unitPower;
            } else {
                otherPower += unitPower;
            }
            totalPower += unitPower;
        }
        return { totalPower, phalanxPower, supportPower, otherPower };
    };

    const attackerStats = calculateEffectivePower(currentAttackingUnits, currentDefendingUnits, true, attackerPhalanx, attackerSupport, attackingHero);
    const defenderStats = calculateEffectivePower(currentDefendingUnits, currentAttackingUnits, false, defenderPhalanx, defenderSupport, defendingHero);

    const attackerPower = (attackerStats.phalanxPower > 0 || attackerStats.supportPower > 0)
        ? attackerStats.phalanxPower + attackerStats.supportPower * 0.5 + attackerStats.otherPower * 0.2
        : attackerStats.totalPower;

    const defenderPower = (defenderStats.phalanxPower > 0 || defenderStats.supportPower > 0)
        ? defenderStats.phalanxPower + defenderStats.supportPower * 0.5 + defenderStats.otherPower * 0.2
        : defenderStats.totalPower;

    const attackerLossRatio = Math.min(1, defenderPower / (attackerPower || 1));
    const defenderLossRatio = Math.min(1, attackerPower / (defenderPower || 1));

    // #comment Simplified loss calculation for more robust and predictable outcomes.
    const applyLosses = (units, lossRatio, unitType) => {
        const losses = {};
        for (const unitId in units) {
            const unitInfo = unitConfig[unitId];
            if (unitInfo && unitInfo.type === unitType) {
                const unitCount = units[unitId] || 0;
                if (unitCount > 0) {
                    const lostCount = Math.round(unitCount * lossRatio);
                    losses[unitId] = Math.min(unitCount, lostCount);
                }
            }
        }
        return losses;
    };

    const finalAttackerLosses = applyLosses(currentAttackingUnits, attackerLossRatio, unitType);
    const finalDefenderLosses = applyLosses(currentDefendingUnits, defenderLossRatio, unitType);

    for (const unitId in finalAttackerLosses) {
        currentAttackingUnits[unitId] = Math.max(0, (currentAttackingUnits[unitId] || 0) - finalAttackerLosses[unitId]);
    }
    for (const unitId in finalDefenderLosses) {
        currentDefendingUnits[unitId] = Math.max(0, (currentDefendingUnits[unitId] || 0) - finalDefenderLosses[unitId]);
    }

    const finalAttackerPower = calculateEffectivePower(currentAttackingUnits, currentDefendingUnits, true, null, null, attackingHero).totalPower;
    const finalDefenderPower = calculateEffectivePower(currentDefendingUnits, currentAttackingUnits, false, null, null, defendingHero).totalPower;
    
    return {
        attackerWon: finalAttackerPower >= finalDefenderPower,
        attackerLosses: finalAttackerLosses,
        defenderLosses: finalDefenderLosses,
        attackerLossRatio: attackerLossRatio,
        defenderLossRatio: defenderLossRatio,
    };
};
export function getVillageTroops(villageData) {
    if (villageData.troops && Object.keys(villageData.troops).length > 0) {
        return villageData.troops;
    }

    const level = villageData.level || 1;
    let troops = {};
    switch (level) {
        case 1:
            troops = { swordsman: 15, archer: 10 };
            break;
        case 2:
            troops = { swordsman: 25, archer: 15, slinger: 5 };
            break;
        case 3:
            troops = { swordsman: 40, archer: 25, slinger: 10, hoplite: 5 };
            break;
        case 4:
            troops = { swordsman: 60, archer: 40, slinger: 20, hoplite: 15, cavalry: 5 };
            break;
        case 5:
            troops = { swordsman: 100, archer: 75, slinger: 50, hoplite: 40, cavalry: 20 };
            break;
        default:
            troops = { swordsman: 15, archer: 10 };
            break;
    }
    return troops;
}
export function resolveCombat(attackingUnits, defendingUnits, defendingResources, isNavalAttack, attackerPhalanx, attackerSupport, defenderPhalanx, defenderSupport, attackingHero, defendingHero) {
    let totalAttackerLosses = {};
    let totalDefenderLosses = {};
    let attackerWon = false;
    let plunder = { wood: 0, stone: 0, silver: 0 };
    let wounded = {};
    let capturedHero = null;
    let woundedHero = null;
    let landBattle;
    
    const safeDefendingResources = defendingResources || {};

    if (isNavalAttack) {
        const navalBattle = resolveBattle(attackingUnits, defendingUnits, 'naval', null, null, null, null); // No phalanx/support for naval
        totalAttackerLosses = { ...navalBattle.attackerLosses };
        totalDefenderLosses = { ...navalBattle.defenderLosses };

        if (navalBattle.attackerWon) {
            const survivingAttackers = { ...attackingUnits };
            for (const unitId in totalAttackerLosses) {
                survivingAttackers[unitId] = Math.max(0, (survivingAttackers[unitId] || 0) - totalAttackerLosses[unitId]);
            }

            landBattle = resolveBattle(survivingAttackers, defendingUnits, 'land', attackerPhalanx, attackerSupport, defenderPhalanx, defenderSupport, attackingHero, defendingHero);
            for (const unitId in landBattle.attackerLosses) {
                totalAttackerLosses[unitId] = (totalAttackerLosses[unitId] || 0) + landBattle.attackerLosses[unitId];
            }
            for (const unitId in landBattle.defenderLosses) {
                totalDefenderLosses[unitId] = (totalDefenderLosses[unitId] || 0) + landBattle.defenderLosses[unitId];
            }
            
            attackerWon = landBattle.attackerWon;

            if (landBattle.attackerWon) {
                plunder.wood = Math.floor((safeDefendingResources.wood || 0) * 0.25);
                plunder.stone = Math.floor((safeDefendingResources.stone || 0) * 0.25);
                plunder.silver = Math.floor((safeDefendingResources.silver || 0) * 0.25);
            }
        } else {
            // If naval battle is lost, all land units on transport ships are lost
            for (const unitId in attackingUnits) {
                if (unitConfig[unitId].type === 'land') {
                    totalAttackerLosses[unitId] = (totalAttackerLosses[unitId] || 0) + attackingUnits[unitId];
                }
            }
        }
    } else {
        landBattle = resolveBattle(attackingUnits, defendingUnits, 'land', attackerPhalanx, attackerSupport, defenderPhalanx, defenderSupport, attackingHero, defendingHero);
        totalAttackerLosses = landBattle.attackerLosses;
        totalDefenderLosses = landBattle.defenderLosses;
        attackerWon = landBattle.attackerWon;
        if (landBattle.attackerWon) {
            plunder.wood = Math.floor((safeDefendingResources.wood || 0) * 0.25);
            plunder.stone = Math.floor((safeDefendingResources.stone || 0) * 0.25);
            plunder.silver = Math.floor((safeDefendingResources.silver || 0) * 0.25);
        }
    }

    // #comment A hero is captured if they are present, their side loses, and all land units on their side are annihilated.
    const allAttackerLandUnitsLost = Object.entries(attackingUnits)
        .filter(([id]) => unitConfig[id]?.type === 'land')
        .every(([id, count]) => (totalAttackerLosses[id] || 0) >= count);

    const allDefenderLandUnitsLost = Object.entries(defendingUnits)
        .filter(([id]) => unitConfig[id]?.type === 'land')
        .every(([id, count]) => (totalDefenderLosses[id] || 0) >= count);

    if (attackerWon && defendingHero && allDefenderLandUnitsLost) {
        capturedHero = { heroId: defendingHero, capturedBy: 'attacker' };
    } else if (!attackerWon && attackingHero && allAttackerLandUnitsLost) {
        capturedHero = { heroId: attackingHero, capturedBy: 'defender' };
    }

    // #comment New Wounded Hero Logic
    if (landBattle) {
        if (attackerWon) {
            // Attacker won, but check if it was a close call.
            if (attackingHero && landBattle.attackerLossRatio > 0.7 && Math.random() < 0.5) { // 50% chance if winner's losses > 70%
                woundedHero = { heroId: attackingHero, side: 'attacker' };
            }
            // Defender lost, standard chance of being wounded.
            if (defendingHero && Math.random() < 0.25) {
                woundedHero = { heroId: defendingHero, side: 'defender' };
            }
        } else { // Defender won
            // Attacker lost, standard chance of being wounded.
            if (attackingHero && Math.random() < 0.25) {
                woundedHero = { heroId: attackingHero, side: 'attacker' };
            }
            // Defender won, but check if it was a close call.
            if (defendingHero && landBattle.defenderLossRatio > 0.7 && Math.random() < 0.5) { // 50% chance if winner's losses > 70%
                woundedHero = { heroId: defendingHero, side: 'defender' };
            }
        }
    }


    // Calculate wounded troops from attacker losses
    for (const unitId in totalAttackerLosses) {
        const losses = totalAttackerLosses[unitId];
        const unitType = unitConfig[unitId]?.type;
        // Only land units can be wounded and healed in a hospital
        if (unitType === 'land') {
            const woundedCount = Math.floor(losses * 0.15); // 15% of losses become wounded
            if (woundedCount > 0) {
                wounded[unitId] = woundedCount;
                totalAttackerLosses[unitId] = losses - woundedCount; // Reduce losses by the number of wounded
            }
        }
    }

    // #comment Calculate battle points for both sides
    const attackerBattlePoints = Object.entries(totalDefenderLosses).reduce((sum, [unitId, count]) => {
        return sum + (unitConfig[unitId]?.cost.population || 0) * count;
    }, 0);
    const defenderBattlePoints = Object.entries(totalAttackerLosses).reduce((sum, [unitId, count]) => {
        return sum + (unitConfig[unitId]?.cost.population || 0) * count;
    }, 0);

    return {
        attackerWon,
        attackerLosses: totalAttackerLosses,
        defenderLosses: totalDefenderLosses,
        plunder,
        wounded,
        attackerBattlePoints,
        defenderBattlePoints,
        capturedHero,
        woundedHero,
    };
}
export function resolveVillageRetaliation(playerUnits) {
    const losses = {};
    if (!playerUnits) return losses;

    const totalPopulation = Object.entries(playerUnits).reduce((sum, [id, count]) => {
        return sum + (unitConfig[id]?.cost.population || 0) * count;
    }, 0);

    if (totalPopulation === 0) return losses;

    // #comment village retaliation causes a flat 5% loss of total army population value
    let populationToLose = totalPopulation * 0.05;

    // #comment distribute losses proportionally among land units
    for (const unitId in playerUnits) {
        if (unitConfig[unitId]?.type === 'land') {
            const unitPopulation = unitConfig[unitId].cost.population;
            if (unitPopulation > 0) {
                const unitProportion = (unitPopulation * playerUnits[unitId]) / totalPopulation;
                const unitsToLose = Math.round((populationToLose / unitPopulation) * unitProportion);
                losses[unitId] = Math.min(playerUnits[unitId], unitsToLose);
            }
        }
    }
    return losses;
}
/**
 * Resolves a scouting mission.
 * @param {object} targetGameState - The game state of the target city.
 * @param {number} attackingSilver - The amount of silver used for the scouting mission.
 * @returns {object} An object containing the scouting outcome.
 */
export function resolveScouting(targetGameState, attackingSilver) {
    const defenderCaveSilver = targetGameState.cave?.silver || 0; // Get silver in cave
    const defenderSecurityBonus = defenderCaveSilver * 2; // Example: defender gets 2x bonus from silver in cave
    const attackerEspionagePower = attackingSilver;

    // A simple probability model: higher attackerEspionagePower and lower defenderSecurityBonus increase success chance
    const successThreshold = 0.5; // Base chance to succeed without any silver
    const adjustedSuccessChance = (attackerEspionagePower + 1) / (attackerEspionagePower + defenderSecurityBonus + 1); // +1 to avoid division by zero and ensure some chance

    const success = Math.random() < adjustedSuccessChance && adjustedSuccessChance > successThreshold; // Only succeed if above a certain threshold

    if (success) {
        // If scouting is successful, return a report of target's resources and units
        return {
            success: true,
            message: 'Scouting successful! Detailed report obtained.',
            targetCityName: targetGameState.cityName,
            targetOwnerUsername: targetGameState.playerInfo?.username || 'Unknown', // Safely access username
            resources: { ...targetGameState.resources },
            units: { ...targetGameState.units },
            buildings: { ...targetGameState.buildings },
            god: targetGameState.god || 'None', // Include worshipped god
        };
    } else {
        // If scouting fails, attacker loses their silver (already deducted in movementmodal),
        // and defender gains some of the attacking silver if their cave silver was higher or it was a close call.
        // Let's say defender gains 50% of the attacking silver if scout fails.
        const silverGainedByDefender = Math.floor(attackingSilver * 0.5);
        return {
            success: false,
            message: 'Scouting failed! Your spy was detected.',
            silverGained: silverGainedByDefender
        };
    }
    
}
</file>

<file path="src/utils/nationality.js">
// src/utils/nationality.js
import unitConfig from '../gameData/units.json';

const nationUnitMap = {
    'Athenian': {
        'swordsman': 'swordsman_athenian',
        'archer': 'archer_athenian',
        'hoplite': 'hoplite_athenian',
        'cavalry': 'cavalry_athenian',
        'trireme': 'trireme_athenian'
    },
    'Spartan': {
        'swordsman': 'swordsman_spartan',
        'archer': 'archer_spartan',
        'hoplite': 'hoplite_spartan',
        'cavalry': 'cavalry_spartan',
        'trireme': 'trireme_spartan'
    },
    'Corinthian': {
        'swordsman': 'swordsman_corinthian',
        'archer': 'archer_corinthian',
        'hoplite': 'hoplite_corinthian',
        'cavalry': 'cavalry_corinthian',
        'trireme': 'trireme_corinthian'
    },
    'Julian': {
        'swordsman': 'swordsman_roman',
        'archer': 'archer_roman',
        'hoplite': 'hoplite_roman',
        'cavalry': 'cavalry_roman',
        'trireme': 'trireme_roman'
    },
    'Cornelian': {
        'swordsman': 'swordsman_roman',
        'archer': 'archer_roman',
        'hoplite': 'hoplite_roman',
        'cavalry': 'cavalry_roman',
        'trireme': 'trireme_roman'
    },
    'Fabian': {
        'swordsman': 'swordsman_roman',
        'archer': 'archer_roman',
        'hoplite': 'hoplite_roman',
        'cavalry': 'cavalry_roman',
        'trireme': 'trireme_roman'
    }
};

export const getNationalUnitId = (nation, genericUnitType) => {
    return nationUnitMap[nation]?.[genericUnitType] || null;
};

// #comment Gets the specific unit ID for a reward based on a player's nation
export const getNationalUnitReward = (nation, genericUnitType) => {
    // Map Roman nations to a single unit set
    let effectiveNation = nation;
    if (['Julian', 'Cornelian', 'Fabian'].includes(nation)) {
        effectiveNation = 'Julian';
    }
    
    // Convert generic unit type (e.g., 'generic_archer') to base type ('archer')
    const baseType = genericUnitType.replace('generic_', '');
    
    // Look up the specific unit ID in the map
    return nationUnitMap[effectiveNation]?.[baseType] || baseType;
};

// #comment Helper to find the generic type of a national unit
export const getGenericUnitType = (nationalUnitId) => {
    for (const nation in nationUnitMap) {
        for (const genericType in nationUnitMap[nation]) {
            if (nationUnitMap[nation][genericType] === nationalUnitId) {
                return genericType;
            }
        }
    }
    return null; 
};


export const getTrainableUnits = (nation) => {
    const nationalUnits = Object.keys(unitConfig).filter(id => {
        const unit = unitConfig[id];
        // #comment Ensure we only get LAND units that are nation-specific
        if (unit.nation && unit.type === 'land') {
            if (['Julian', 'Cornelian', 'Fabian'].includes(nation)) {
                return unit.nation === 'Julian';
            }
            return unit.nation === nation;
        }
        return false;
    });

    // #comment Return only the national units, excluding the generic ones.
    return nationalUnits;
};

export const getTrainableNavalUnits = (nation) => {
    const nationalUnits = Object.keys(unitConfig).filter(id => {
        const unit = unitConfig[id];
        // #comment Make sure we only get nation-specific NAVAL units
        if (unit.nation && unit.type === 'naval') {
            if (['Julian', 'Cornelian', 'Fabian'].includes(nation)) {
                return unit.nation === 'Julian';
            }
            return unit.nation === nation;
        }
        return false;
    });

    // #comment Add generic NAVAL units that are not nation-specific
    const genericUnits = Object.keys(unitConfig).filter(id => {
        const unit = unitConfig[id];
        return !unit.nation && !unit.mythical && unit.type === 'naval';
    });
    
    return [...new Set([...nationalUnits, ...genericUnits])];
};
</file>

<file path="src/utils/sendSystemMessage.js">
import { collection, query, where, getDocs, doc, setDoc, addDoc, serverTimestamp, updateDoc } from "firebase/firestore";
import { db } from '../firebase/config';

export const sendSystemMessage = async (targetUserId, targetUsername, messageText, worldId) => {
    const systemId = 'system';
    const systemUsername = 'System';

    // #comment Use a sorted array for a consistent document ID/query
    const participants = [systemId, targetUserId].sort();
    const conversationQuery = query(
        collection(db, 'worlds', worldId, 'conversations'),
        where('participants', '==', participants)
    );
    const conversationSnapshot = await getDocs(conversationQuery);

    let conversationRef;
    if (conversationSnapshot.empty) {
        conversationRef = doc(collection(db, 'worlds', worldId, 'conversations'));
        await setDoc(conversationRef, {
            participants: participants,
            participantUsernames: {
                [systemId]: systemUsername,
                [targetUserId]: targetUsername,
            },
            lastMessage: { text: messageText.substring(0, 30) + '...', senderId: systemId, timestamp: serverTimestamp() },
            readBy: [], // #comment Initialize as unread for the target
        });
    } else {
        conversationRef = conversationSnapshot.docs[0].ref;
    }

    // #comment Add the actual message to the subcollection
    await addDoc(collection(conversationRef, 'messages'), {
        text: messageText,
        senderId: systemId,
        senderUsername: systemUsername,
        isSystem: true,
        timestamp: serverTimestamp(),
    });

    // #comment Update the conversation's last message and mark as unread for the recipient
    await updateDoc(conversationRef, {
        lastMessage: { text: messageText.substring(0, 30) + '...', senderId: systemId, timestamp: serverTimestamp() },
        readBy: [], // #comment Reset readBy to ensure it appears as a new message
    });
};
</file>

<file path="src/utils/travel.js">
// src/utils/travel.js
/**
 * Calculates the Euclidean distance between two points (cities).
 * @param {object} cityA - The starting city with x, y coordinates.
 * @param {object} cityB - The destination city with x, y coordinates.
 * @returns {number} The distance between the two cities in map tiles.
 */
export function calculateDistance(cityA, cityB) {
    if (!cityA || !cityB) return 0;
    const dx = cityA.x - cityB.x;
    const dy = cityA.y - cityB.y;
    return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Calculates the travel time in seconds based on distance, speed, and conditions.
 * @param {number} distance - The distance to travel.
 * @param {number} speed - The base speed of the slowest unit.
 * @param {string|null} mode - The type of movement.
 * @param {object|null} worldState - The current state of the world (for season/weather).
 * @param {Array<string>} unitTypes - An array of unit types in the army ('land', 'naval').
 * @param {number} windSpeed - A random wind speed value (0-10) based on weather.
 * @returns {number} The travel time in seconds.
 */
export function calculateTravelTime(distance, speed, mode = null, worldState = null, unitTypes = [], windSpeed = 0) {
    // #comment Special fast calculation for scout and trade modes
    if (mode === 'scout' || mode === 'trade') {
        const minTime = 15; // 15 seconds minimum
        const maxTime = 300; // 5 minutes maximum
        const timePerTile = 15; // 15 seconds per tile, making nearby islands very fast to reach
        return Math.max(minTime, Math.min(maxTime, distance * timePerTile));
    }

    let modifiedSpeed = speed;
    const hasLand = unitTypes.includes('land');
    const hasNaval = unitTypes.includes('naval');
    const hasFlying = unitTypes.includes('flying');

    if (worldState) {
        // #comment Season effects on LAND units
        if (hasLand) {
            switch(worldState.season) {
                case 'Summer':
                    modifiedSpeed *= 1.1; // 10% faster on dry summer roads
                    break;
                case 'Winter':
                    modifiedSpeed *= 0.8; // 20% slower in snow/mud
                    break;
                default: // Spring, Autumn
                    break;
            }
        }

        // #comment Weather effects on units
        if (hasNaval || hasFlying) {
            // #comment Wind speed modifier for naval units.
            // A speed of 5 is neutral. Lower is a headwind (slower), higher is a tailwind (faster).
            // Max headwind (0 knots) = -25% speed. Max tailwind (10 knots) = +25% speed.
            const windModifier = 1 + ((windSpeed - 5) / 10) * 0.5; // Ranges from 0.75 to 1.25
            modifiedSpeed *= windModifier;
        }

        switch(worldState.weather) {
            case 'Rainy':
                if (hasLand) modifiedSpeed *= 0.9; // 10% slower on muddy ground
                break;
            case 'Stormy':
                // #comment Storms have a general large penalty on top of wind effects
                if (hasNaval || hasFlying) modifiedSpeed *= 0.8; // Additional 20% penalty
                if (hasLand) modifiedSpeed *= 0.8;
                break;
            case 'Foggy':
                modifiedSpeed *= 0.75; // 25% slower for everyone due to low visibility
                break;
            default: // Clear, Windy
                break;
        }
    }

    // Regular calculation for other movements
    if (modifiedSpeed <= 0) return Infinity;
    const worldSpeedFactor = 5;
    const hours = distance / (modifiedSpeed * worldSpeedFactor);
    return hours * 3600; // Convert hours to seconds
}


/**
 * Formats a duration in seconds into a readable HH:MM:SS format.
 * @param {number} totalSeconds - The total seconds to format.
 * @returns {string} The formatted time string.
 */
export function formatTravelTime(totalSeconds) {
    if (totalSeconds === Infinity) return 'N/A';
    if (isNaN(totalSeconds)) return 'Invalid Time';

    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = Math.floor(totalSeconds % 60);

    const pad = (num) => num.toString().padStart(2, '0');

    return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
}
</file>

<file path="src/utils/worldGeneration.js">
// src/utils/worldGeneration.js

// Add a list of available island images
const islandImages = ['island_1.png'];

// INDICATORS:
// You can manually adjust the coordinates for city and village placements for each island image here.
// The 'x' and 'y' values are relative to the center of the island image.
// Positive 'x' is to the right, negative 'x' is to the left.
// Positive 'y' is down, negative 'y' is up.
const islandLayouts = {
    'island_1.png': {
        citySlots: [
            { x: -1, y: 4 },    // Bottom bay
            { x: 5, y: 1 },    // Right side
            { x: 2, y: 5 },    // Bottom right
            { x: 5, y: -1 },   // Far right peninsula
            { x: -6, y: 1 },   // Far left
            { x: -6, y: 1 },   // Left side
            { x: -3, y: 1 },   // Bottom left
            { x: -6, y: -2 },  // Far left top
            { x: 4, y: -4 },   // Top right
            { x: 0, y: -5 }    // Top middle
        ],
        villages: [
            { x: -3, y: -1 }, { x: 1, y: -1}, { x: 4, y: -1 }, { x: 0, y: 0}, { x:-2, y: 0}
        ]
    },
};


export const generateIslands = (width, height, count) => {
    const islands = [];
    const minMargin = 10; // Margin between islands
    const maxMargin = 12; // Margin between islands
    const mapEdgeMargin = 10; // Margin from the map edge
    const maxAttempts = 20;

    // If only one island is to be generated, create a large central one.
    if (count === 1) {
        const radius = Math.min(width, height) / 2.5; // Make it large
        islands.push({
            id: `island-0`,
            name: `The Central Isle`,
            x: Math.floor(width / 2),
            y: Math.floor(height / 2),
            radius: radius,
            imageName: islandImages[Math.floor(Math.random() * islandImages.length)],
        });
        return islands;
    }

    const checkCollision = (newIsland, existingIslands) => {
        for (const existing of existingIslands) {
            const distance = Math.sqrt(
                Math.pow(newIsland.x - existing.x, 2) +
                Math.pow(newIsland.y - existing.y, 2)
            );
            const margin = minMargin + Math.random() * (maxMargin - minMargin);
            if (distance < newIsland.radius + existing.radius + margin) {
                return true;
            }
        }
        return false;
    };

    for (let i = 0; i < count; i++) {
        let island = {};
        let hasCollision = true;
        let attempts = 0;

        while (hasCollision && attempts < maxAttempts) {
            const radius = Math.random() * 2 + 6; // Radius between 6 and 8 tiles

            // Calculate spawnable area, considering map edge margin and island radius
            const spawnableWidth = width - (mapEdgeMargin * 2) - (radius * 2);
            const spawnableHeight = height - (mapEdgeMargin * 2) - (radius * 2);

            if (spawnableWidth <= 0 || spawnableHeight <= 0) {
                // This can happen if the map is too small for the margins and islands
                console.error("Map is too small to generate islands with the specified margins.");
                break; // Exit the while loop
            }

            // Calculate random coordinates within the spawnable area
            const randomX = Math.floor(Math.random() * spawnableWidth);
            const randomY = Math.floor(Math.random() * spawnableHeight);

            island = {
                id: `island-${Date.now()}-${i}`,
                name: `Island ${i + 1}`,
                // Offset coordinates by the margin and radius
                x: mapEdgeMargin + radius + randomX,
                y: mapEdgeMargin + radius + randomY,
                radius: radius,
                imageName: islandImages[Math.floor(Math.random() * islandImages.length)],
            };
            hasCollision = checkCollision(island, islands);
            attempts++;
        }

        if (!hasCollision) {
            islands.push(island);
        }
    }
    return islands;
};

export const generateCitySlots = (islands, worldWidth, worldHeight) => {
    const citySlots = {};
    let slotIndex = 0;

    islands.forEach(island => {
        const layout = islandLayouts[island.imageName];
        if (layout) {
            // Use predefined layout for cities
            layout.citySlots.forEach(relativePos => {
                const x = Math.round(island.x + relativePos.x);
                const y = Math.round(island.y + relativePos.y);

                if (x >= 0 && x < worldWidth && y >= 0 && y < worldHeight) {
                    const slotId = `${island.id}-slot-${slotIndex++}`;
                    citySlots[slotId] = {
                        islandId: island.id,
                        x,
                        y,
                        ownerId: null,
                        cityName: 'Unclaimed',
                        ownerEmail: null,
                        ownerUsername: null,
                        ownerFaction: null
                    };
                }
            });
        }
        // NOTE: The procedural fallback has been removed to ensure consistency.
        // If an island image does not have a layout in islandLayouts, it will not have cities.
    });

    return citySlots;
};


function generateVillageTroops(level) {
    return { swordsman: 15, archer: 10 };
}

const villageNames = [
    "Oakhaven", "Willow Creek", "Stonebridge", "Riverbend", "Greenfield", "Fairview",
    "Maplewood", "Pinehurst", "Cedarbrook", "Elmwood", "Ashworth", "Birchwood",
    "Silver Creek", "Goldcrest", "Ironwood", "Copperhill", "Crystal Falls", "Amberwood"
];


export const generateFarmingVillages = (islands, citySlots, worldWidth, worldHeight) => {
    const villages = {};
    const occupiedSlots = new Set(Object.values(citySlots).map(slot => `${slot.x},${slot.y}`));
    let villageIndex = 0;

    const demandCooldowns = [300, 1200, 5400, 14400];

    islands.forEach(island => {
        const layout = islandLayouts[island.imageName];
        if (layout) {
            // Use predefined layout for villages
            layout.villages.forEach(relativePos => {
                const x = Math.round(island.x + relativePos.x);
                const y = Math.round(island.y + relativePos.y);
                if (occupiedSlots.has(`${x},${y}`)) return;

                const villageId = `v${island.id}-${villageIndex++}`;
                const resources = ['wood', 'stone', 'silver'];
                let demands = resources.splice(Math.floor(Math.random() * resources.length), 1)[0];
                let supplies = resources.splice(Math.floor(Math.random() * resources.length), 1)[0];

                villages[villageId] = {
                    id: villageId, x, y, islandId: island.id, name: villageNames[Math.floor(Math.random() * villageNames.length)],
                    level: 1, demandYield: { wood: 50, stone: 50, silver: 20 },
                    resources: { wood: 500, stone: 500, silver: 500 }, maxResources: 1200, lastDemandTime: 0,
                    demandCooldown: demandCooldowns[Math.floor(Math.random() * demandCooldowns.length)],
                    troops: generateVillageTroops(1), tradeRatio: 1.25, demands, supplies
                };
                occupiedSlots.add(`${x},${y}`);
            });
        } else {
            // Fallback procedural generation for inland villages
            const centerX = Math.round(island.x);
            const centerY = Math.round(island.y);
            const numVillages = Math.min(Math.floor(island.radius), 5);
            for (let i = 0; i < numVillages; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const distance = Math.random() * (island.radius - 3); // Place away from the edge
                const x = Math.round(centerX + distance * Math.cos(angle));
                const y = Math.round(centerY + distance * Math.sin(angle));

                if (!occupiedSlots.has(`${x},${y}`)) {
                    const villageId = `v${island.id}-${i}`;
                    villages[villageId] = { id: villageId, x, y, islandId: island.id, name: "Inland Hamlet", level: 1, /* ... other properties */ };
                    occupiedSlots.add(`${x},${y}`);
                }
            }
        }
    });

    return villages;
};

// Generates ruins in water tiles
export const generateRuins = (islands, worldWidth, worldHeight) => {
    const ruins = {};
    const ruinCount = Math.floor((worldWidth * worldHeight) / 500); // Adjust density as needed
    const minDistanceFromLand = 3; // Minimum tiles away from any land tile

    const isLand = (x, y) => {
        for (const island of islands) {
            const distSq = Math.pow(x - island.x, 2) + Math.pow(y - island.y, 2);
            if (distSq <= Math.pow(island.radius + minDistanceFromLand, 2)) {
                return true;
            }
        }
        return false;
    };

    for (let i = 0; i < ruinCount; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(Math.random() * worldWidth);
            y = Math.floor(Math.random() * worldHeight);
            attempts++;
        } while (isLand(x, y) && attempts < 100);

        if (attempts < 100) {
            const ruinId = `ruin-${x}-${y}`;
            ruins[ruinId] = {
                id: ruinId,
                x,
                y,
                name: "Forgotten Ruins",
                type: 'ruin', // To distinguish from villages
                troops: {
                    hoplite: 100 + Math.floor(Math.random() * 50),
                    cavalry: 50 + Math.floor(Math.random() * 25),
                    trireme: 20 + Math.floor(Math.random() * 10) // Naval defense
                },
                researchReward: `qol_research_${i % 3}` // Example reward cycles through the 3 QoL researches
            };
        }
    }
    return ruins;
};

export const generateGodTowns = (islands, worldWidth, worldHeight, count = 1) => {
    const godTowns = {};
    const minDistanceFromLand = 5;
    const transformationDuration = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

    const isLand = (x, y) => {
        for (const island of islands) {
            const distSq = Math.pow(x - island.x, 2) + Math.pow(y - island.y, 2);
            if (distSq <= Math.pow(island.radius + minDistanceFromLand, 2)) {
                return true;
            }
        }
        return false;
    };

    for (let i = 0; i < count; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(Math.random() * worldWidth);
            y = Math.floor(Math.random() * worldHeight);
            attempts++;
        } while (isLand(x, y) && attempts < 100);

        if (attempts < 100) {
            const townId = `god-town-${Date.now()}-${i}`;
            const spawnTime = new Date();
            godTowns[townId] = {
                id: townId,
                x,
                y,
                name: "Strange Ruins",
                stage: "ruins",
                puzzleId: `puzzle_${(i % 3) + 1}`,
                troops: { 
                    'manticore': 500,
                    'medusa': 500,
                    'pegasus': 500,
                    'sphinx': 500,
                    'phoenix': 500,
                    'serpopard': 500
                },
                spawnTime: spawnTime,
                transformationTime: new Date(spawnTime.getTime() + transformationDuration),
            };
        }
    }
    return godTowns;
};
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {
      fontFamily: {
        'sans': ['Inter', 'sans-serif'],
        'title': ['"IM Fell English SC"', 'serif'],
      },
      colors: {
        // You can define custom colors here if you want
      }
    },
  },
  plugins: [],
}
</file>

<file path="todo.txt">
- fix report
- make requirements for more than one building to show on different rows

Later:
- make it unzoom more and show dots instead of the models
- add an option to see the world map


Bugs:
</file>

<file path="Way later.txt">
Models:
- add a battle simulation
- add troops into the city
</file>

<file path="Zap stuff.txt">
Game Stuff:
- add more research and make them to actually work










========================================================================================================================
Ideas:
- make Tabs for different command like folders lists
- 








========================================================================================================================
Admin panel Bugs:
- When going to map view admin cheats get disable
- When putting resources it shows the amout you put for a second and then reverts itself to storage amount
- Admin Cheats don't work on Wonders
- Place dummy destoys cities mapS
- Cheat Code to work with demolish


========================================================================================================================

- EventTrigger









AdminCheatMenu
useAdminActions
CityView
GameContext
</file>

</files>
